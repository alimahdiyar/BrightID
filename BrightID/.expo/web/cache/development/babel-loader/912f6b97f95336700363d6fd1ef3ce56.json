{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { createSlice, createEntityAdapter, createAsyncThunk, createSelector } from '@reduxjs/toolkit';\nimport i18next from 'i18next';\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport { removeChannel, selectChannelById } from \"./channelSlice\";\nimport { selectConnectionById } from \"../../reducer/connectionsSlice\";\nimport { decryptData } from \"../../utils/cryptoHelper\";\nimport { PROFILE_VERSION } from \"../../utils/constants\";\nimport { createDeepEqualStringArraySelector } from \"../../utils/createDeepEqualStringArraySelector\";\nimport BrightidError, { USER_NOT_FOUND } from \"../../api/brightidError\";\nvar pendingConnectionsAdapter = createEntityAdapter({\n  selectId: function selectId(pendingConnection) {\n    return pendingConnection.profileId;\n  }\n});\nexport var pendingConnection_states;\n\n(function (pendingConnection_states) {\n  pendingConnection_states[\"INITIAL\"] = \"INITIAL\";\n  pendingConnection_states[\"DOWNLOADING\"] = \"DOWNLOADING\";\n  pendingConnection_states[\"UNCONFIRMED\"] = \"UNCONFIRMED\";\n  pendingConnection_states[\"CONFIRMING\"] = \"CONFIRMING\";\n  pendingConnection_states[\"CONFIRMED\"] = \"CONFIRMED\";\n  pendingConnection_states[\"ERROR\"] = \"ERROR\";\n  pendingConnection_states[\"MYSELF\"] = \"MYSELF\";\n  pendingConnection_states[\"EXPIRED\"] = \"EXPIRED\";\n})(pendingConnection_states || (pendingConnection_states = {}));\n\nexport var newPendingConnection = createAsyncThunk('pendingConnections/newPendingConnection', function _callee(_ref, _ref2) {\n  var channelId, profileId, api, getState, channel, profileData, sharedProfile, msg, _msg, alreadyPending, existingConnection, profileInfo, pendingConnectionData;\n\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          channelId = _ref.channelId, profileId = _ref.profileId, api = _ref.api;\n          getState = _ref2.getState;\n          console.log(\"new pending connection \" + profileId + \" in channel \" + channelId);\n          channel = selectChannelById(getState(), channelId);\n\n          if (channel) {\n            _context.next = 6;\n            break;\n          }\n\n          throw new Error('Channel does not exist');\n\n        case 6:\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(channel.api.download({\n            channelId: channelId,\n            dataId: profileId\n          }));\n\n        case 8:\n          profileData = _context.sent;\n          sharedProfile = decryptData(profileData, channel.aesKey);\n\n          if (!(sharedProfile.version === undefined || sharedProfile.version < PROFILE_VERSION)) {\n            _context.next = 16;\n            break;\n          }\n\n          msg = i18next.t('pendingConnection.alert.text.otherOutdated', {\n            name: \"\" + sharedProfile.name\n          });\n          Alert.alert(i18next.t('pendingConnection.alert.title.connectionImpossible'), msg);\n          throw new Error(msg);\n\n        case 16:\n          if (!(sharedProfile.version > PROFILE_VERSION)) {\n            _context.next = 20;\n            break;\n          }\n\n          _msg = i18next.t('pendingConnection.alert.text.localOutdated', {\n            name: \"\" + sharedProfile.name\n          });\n          Alert.alert(i18next.t('pendingConnection.alert.title.connectionImpossible'), _msg);\n          throw new Error(_msg);\n\n        case 20:\n          alreadyPending = selectAllUnconfirmedConnections(getState()).find(function (pc) {\n            return sharedProfile.id === pc.pendingConnectionData.sharedProfile.id;\n          });\n\n          if (!alreadyPending) {\n            _context.next = 23;\n            break;\n          }\n\n          throw new Error(\"PendingConnection \" + profileId + \": BrightId \" + sharedProfile.id + \" is already existing.\");\n\n        case 23:\n          existingConnection = selectConnectionById(getState(), sharedProfile.id);\n\n          if (existingConnection) {\n            console.log(sharedProfile.id + \" exists.\");\n          }\n\n          _context.prev = 25;\n          _context.next = 28;\n          return _regeneratorRuntime.awrap(api.getProfile(sharedProfile.id));\n\n        case 28:\n          profileInfo = _context.sent;\n          _context.next = 39;\n          break;\n\n        case 31:\n          _context.prev = 31;\n          _context.t0 = _context[\"catch\"](25);\n\n          if (!(_context.t0 instanceof BrightidError && _context.t0.errorNum === USER_NOT_FOUND)) {\n            _context.next = 38;\n            break;\n          }\n\n          if (!existingConnection) {\n            _context.next = 36;\n            break;\n          }\n\n          throw new Error(\"PendingConnection \" + profileId + \": User already connected, but unknown in node api.\");\n\n        case 36:\n          _context.next = 39;\n          break;\n\n        case 38:\n          throw _context.t0;\n\n        case 39:\n          pendingConnectionData = {\n            sharedProfile: sharedProfile,\n            profileInfo: profileInfo,\n            existingConnection: existingConnection,\n            myself: sharedProfile.id === getState().user.id\n          };\n          return _context.abrupt(\"return\", pendingConnectionData);\n\n        case 41:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[25, 31]], Promise);\n});\nvar initialState = pendingConnectionsAdapter.getInitialState();\nvar pendingConnectionsSlice = createSlice({\n  name: 'pendingConnections',\n  initialState: initialState,\n  reducers: {\n    addFakePendingConnection: pendingConnectionsAdapter.addOne,\n    removePendingConnection: pendingConnectionsAdapter.removeOne,\n    updatePendingConnection: pendingConnectionsAdapter.updateOne,\n    removeAllPendingConnections: pendingConnectionsAdapter.removeAll,\n    confirmPendingConnection: function confirmPendingConnection(state, action) {\n      var id = action.payload;\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: id,\n        changes: {\n          state: pendingConnection_states.CONFIRMED\n        }\n      });\n    }\n  },\n  extraReducers: function extraReducers(builder) {\n    builder.addCase(newPendingConnection.pending, function (state, action) {\n      state = pendingConnectionsAdapter.addOne(state, {\n        profileId: action.meta.arg.profileId,\n        channelId: action.meta.arg.channelId,\n        state: pendingConnection_states.DOWNLOADING\n      });\n    }).addCase(newPendingConnection.rejected, function (state, action) {\n      console.log(\"Error adding pending connection:\");\n      console.log(action.error.message);\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: action.meta.arg.profileId,\n        changes: {\n          state: pendingConnection_states.ERROR\n        }\n      });\n    }).addCase(newPendingConnection.fulfilled, function (state, _ref3) {\n      var meta = _ref3.meta,\n          payload = _ref3.payload;\n      var profileId = meta.arg.profileId;\n      var changes = {\n        state: payload.myself ? pendingConnection_states.MYSELF : pendingConnection_states.UNCONFIRMED,\n        pendingConnectionData: payload\n      };\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: profileId,\n        changes: changes\n      });\n    }).addCase(removeChannel, function (state, action) {\n      var channelId = action.payload;\n      var deleteIds = state.ids.filter(function (id) {\n        return state.entities[id].channelId === channelId;\n      });\n      console.log(\"Channel \" + channelId + \" deleted - removing \" + deleteIds.length + \" pending connections associated to channel\");\n      state = pendingConnectionsAdapter.removeMany(state, deleteIds);\n    });\n  }\n});\n\nvar _pendingConnectionsAd = pendingConnectionsAdapter.getSelectors(function (state) {\n  return state.pendingConnections;\n}),\n    selectAllPendingConnections = _pendingConnectionsAd.selectAll,\n    selectPendingConnectionById = _pendingConnectionsAd.selectById,\n    selectAllPendingConnectionIds = _pendingConnectionsAd.selectIds;\n\nexport { selectAllPendingConnections, selectPendingConnectionById, selectAllPendingConnectionIds };\nexport var selectAllUnconfirmedConnections = createSelector(selectAllPendingConnections, function (pendingConnections) {\n  return pendingConnections.filter(function (pc) {\n    return pc.state === pendingConnection_states.UNCONFIRMED;\n  });\n});\nexport var selectPendingConnectionByBrightId = createSelector(selectAllPendingConnections, function (_, brightId) {\n  return brightId;\n}, function (pendingConnections, brightId) {\n  return pendingConnections.find(function (pc) {\n    return brightId === pc.brightId;\n  });\n});\nexport var selectAllPendingConnectionsByChannelIds = createDeepEqualStringArraySelector(selectAllPendingConnections, function (_, channelIds) {\n  return channelIds;\n}, function (pendingConnections, channelIds) {\n  console.log(\"selectAllPendingConnectionsByChannelIds \" + channelIds + \"...\");\n  return pendingConnections.filter(function (pc) {\n    return channelIds.includes(pc.channelId);\n  });\n});\nexport var selectAllUnconfirmedConnectionsByChannelIds = createDeepEqualStringArraySelector(selectAllUnconfirmedConnections, function (_, channelIds) {\n  return channelIds;\n}, function (pendingConnections, channelIds) {\n  console.log(\"selectAllUnconfirmedConnectionsByChannelIds \" + channelIds + \"...\");\n  return pendingConnections.filter(function (pc) {\n    return channelIds.includes(pc.channelId);\n  });\n});\nvar _pendingConnectionsSl = pendingConnectionsSlice.actions,\n    updatePendingConnection = _pendingConnectionsSl.updatePendingConnection,\n    removePendingConnection = _pendingConnectionsSl.removePendingConnection,\n    removeAllPendingConnections = _pendingConnectionsSl.removeAllPendingConnections,\n    confirmPendingConnection = _pendingConnectionsSl.confirmPendingConnection,\n    addFakePendingConnection = _pendingConnectionsSl.addFakePendingConnection;\nexport { updatePendingConnection, removePendingConnection, removeAllPendingConnections, confirmPendingConnection, addFakePendingConnection };\nexport default pendingConnectionsSlice.reducer;","map":{"version":3,"names":["createSlice","createEntityAdapter","createAsyncThunk","createSelector","i18next","removeChannel","selectChannelById","selectConnectionById","decryptData","PROFILE_VERSION","createDeepEqualStringArraySelector","BrightidError","USER_NOT_FOUND","pendingConnectionsAdapter","selectId","pendingConnection","profileId","pendingConnection_states","newPendingConnection","channelId","api","getState","console","log","channel","Error","download","dataId","profileData","sharedProfile","aesKey","version","undefined","msg","t","name","Alert","alert","alreadyPending","selectAllUnconfirmedConnections","find","pc","id","pendingConnectionData","existingConnection","getProfile","profileInfo","errorNum","myself","user","initialState","getInitialState","pendingConnectionsSlice","reducers","addFakePendingConnection","addOne","removePendingConnection","removeOne","updatePendingConnection","updateOne","removeAllPendingConnections","removeAll","confirmPendingConnection","state","action","payload","changes","CONFIRMED","extraReducers","builder","addCase","pending","meta","arg","DOWNLOADING","rejected","error","message","ERROR","fulfilled","MYSELF","UNCONFIRMED","deleteIds","ids","filter","entities","length","removeMany","getSelectors","pendingConnections","selectAllPendingConnections","selectAll","selectPendingConnectionById","selectById","selectAllPendingConnectionIds","selectIds","selectPendingConnectionByBrightId","_","brightId","selectAllPendingConnectionsByChannelIds","channelIds","includes","selectAllUnconfirmedConnectionsByChannelIds","actions","reducer"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/pendingConnectionSlice.ts"],"sourcesContent":["import {\n  createSlice,\n  createEntityAdapter,\n  createAsyncThunk,\n  createSelector,\n  PayloadAction,\n} from '@reduxjs/toolkit';\nimport i18next from 'i18next';\nimport { Alert } from 'react-native';\nimport {\n  removeChannel,\n  selectChannelById,\n} from '@/components/PendingConnections/channelSlice';\nimport { selectConnectionById } from '@/reducer/connectionsSlice';\nimport { decryptData } from '@/utils/cryptoHelper';\nimport { PROFILE_VERSION } from '@/utils/constants';\nimport { createDeepEqualStringArraySelector } from '@/utils/createDeepEqualStringArraySelector';\nimport BrightidError, { USER_NOT_FOUND } from '@/api/brightidError';\nimport { NodeApi } from '@/api/brightId';\n\nconst pendingConnectionsAdapter = createEntityAdapter<PendingConnection>({\n  selectId: (pendingConnection) => pendingConnection.profileId,\n});\n\n/*\n  PendingConnection slice contains all pending connections and their profile info\n\n  What is a pendingConnection:\n   - 'id': unique id of this pending connection. Is also profileId on the profile server.\n   - 'channelId': channel this pendingConnection is associated with\n   - 'state': state of this pending connection (valid states TBD)\n   - 'brightId': the brightId if the connection\n   - 'name'\n   - 'photo' (base64-encoded)\n */\nexport enum pendingConnection_states {\n  INITIAL = 'INITIAL',\n  DOWNLOADING = 'DOWNLOADING',\n  UNCONFIRMED = 'UNCONFIRMED',\n  CONFIRMING = 'CONFIRMING',\n  CONFIRMED = 'CONFIRMED',\n  ERROR = 'ERROR',\n  MYSELF = 'MYSELF',\n  EXPIRED = 'EXPIRED',\n}\n\nexport const newPendingConnection = createAsyncThunk<\n  PendingConnectionData,\n  { channelId: string; profileId: string; api: NodeApi },\n  { state: State }\n>(\n  'pendingConnections/newPendingConnection',\n  async ({ channelId, profileId, api }, { getState }) => {\n    console.log(`new pending connection ${profileId} in channel ${channelId}`);\n\n    const channel = selectChannelById(getState(), channelId);\n\n    if (!channel) {\n      throw new Error('Channel does not exist');\n    }\n\n    // download profile\n    const profileData: string = await channel.api.download({\n      channelId,\n      dataId: profileId,\n    });\n\n    const sharedProfile = decryptData(\n      profileData,\n      channel.aesKey,\n    ) as SharedProfile;\n\n    // compare profile version\n    if (\n      sharedProfile.version === undefined || // very old client version\n      sharedProfile.version < PROFILE_VERSION // old client version\n    ) {\n      // other user needs to update his client\n      const msg = i18next.t('pendingConnection.alert.text.otherOutdated', {\n        name: `${sharedProfile.name}`,\n      });\n      Alert.alert(\n        i18next.t('pendingConnection.alert.title.connectionImpossible'),\n        msg,\n      );\n      throw new Error(msg);\n    } else if (sharedProfile.version > PROFILE_VERSION) {\n      // I need to update my client\n      const msg = i18next.t('pendingConnection.alert.text.localOutdated', {\n        name: `${sharedProfile.name}`,\n      });\n      Alert.alert(\n        i18next.t('pendingConnection.alert.title.connectionImpossible'),\n        msg,\n      );\n      throw new Error(msg);\n    }\n    // Is this brightID already in the list of unconfirmed pending connections? Can happen if the same user joins a\n    // channel multiple times (e.g. if users app crashed)\n    const alreadyPending = selectAllUnconfirmedConnections(getState()).find(\n      (pc) => sharedProfile.id === pc.pendingConnectionData.sharedProfile.id,\n    );\n    if (alreadyPending) {\n      throw new Error(\n        `PendingConnection ${profileId}: BrightId ${sharedProfile.id} is already existing.`,\n      );\n    }\n\n    // Is this a known connection reconnecting?\n    const existingConnection = selectConnectionById(\n      getState(),\n      sharedProfile.id,\n    );\n    if (existingConnection) {\n      console.log(`${sharedProfile.id} exists.`);\n    }\n\n    let profileInfo: ProfileInfo;\n    try {\n      profileInfo = await api.getProfile(sharedProfile.id);\n    } catch (err) {\n      if (err instanceof BrightidError && err.errorNum === USER_NOT_FOUND) {\n        // this must be a new user not yet existing on backend.\n        if (existingConnection) {\n          // handle edge case:\n          // The other user is not known in the backend, but already connected with us. This should never happen :/\n          // Since profileInfo is required for reconnecting we can not start the reconnect flow.\n          throw new Error(\n            `PendingConnection ${profileId}: User already connected, but unknown in node api.`,\n          );\n        }\n      } else {\n        throw err;\n      }\n    }\n\n    const pendingConnectionData: PendingConnectionData = {\n      sharedProfile,\n      profileInfo,\n      existingConnection,\n      myself: sharedProfile.id === getState().user.id,\n    };\n    return pendingConnectionData;\n  },\n);\n\n// By default, `createEntityAdapter` gives you `{ ids: [], entities: {} }`.\n// If you want to track 'loading' or other keys, you would initialize them here:\n// `getInitialState({ loading: false, activeRequestId: null })`\nconst initialState = pendingConnectionsAdapter.getInitialState();\n\nconst pendingConnectionsSlice = createSlice({\n  name: 'pendingConnections',\n  initialState,\n  reducers: {\n    addFakePendingConnection: pendingConnectionsAdapter.addOne,\n    removePendingConnection: pendingConnectionsAdapter.removeOne,\n    updatePendingConnection: pendingConnectionsAdapter.updateOne,\n    removeAllPendingConnections: pendingConnectionsAdapter.removeAll,\n    confirmPendingConnection(state, action: PayloadAction<string>) {\n      const id = action.payload;\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id,\n        changes: {\n          state: pendingConnection_states.CONFIRMED,\n        },\n      });\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(newPendingConnection.pending, (state, action) => {\n        // This is called before actual thunk code is executed. Thunk argument is available via\n        // action.meta.arg.\n\n        // Add pending connection in DOWNLOADING state.\n        state = pendingConnectionsAdapter.addOne(state, {\n          profileId: action.meta.arg.profileId,\n          channelId: action.meta.arg.channelId,\n          state: pendingConnection_states.DOWNLOADING,\n        });\n      })\n      .addCase(newPendingConnection.rejected, (state, action) => {\n        // This is called if anything goes wrong\n        console.log(`Error adding pending connection:`);\n        console.log(action.error.message);\n\n        state = pendingConnectionsAdapter.updateOne(state, {\n          id: action.meta.arg.profileId,\n          changes: {\n            state: pendingConnection_states.ERROR,\n          },\n        });\n      })\n      .addCase(newPendingConnection.fulfilled, (state, { meta, payload }) => {\n        // thunk arguments are available via action.meta.arg:\n        const { profileId } = meta.arg;\n\n        // data returned by thunk is available via action.payload:\n        const changes: Partial<PendingConnection> = {\n          state: payload.myself\n            ? pendingConnection_states.MYSELF\n            : pendingConnection_states.UNCONFIRMED,\n          pendingConnectionData: payload,\n        };\n\n        // Perform the update in redux\n        state = pendingConnectionsAdapter.updateOne(state, {\n          id: profileId,\n          changes,\n        });\n      })\n      .addCase(removeChannel, (state, action) => {\n        const channelId = action.payload;\n        const deleteIds = state.ids.filter(\n          (id) => state.entities[id].channelId === channelId,\n        );\n        console.log(\n          `Channel ${channelId} deleted - removing ${deleteIds.length} pending connections associated to channel`,\n        );\n        state = pendingConnectionsAdapter.removeMany(state, deleteIds);\n      });\n  },\n});\n\n// export selectors\n\nexport const {\n  selectAll: selectAllPendingConnections,\n  selectById: selectPendingConnectionById,\n  selectIds: selectAllPendingConnectionIds,\n} = pendingConnectionsAdapter.getSelectors(\n  (state: State) => state.pendingConnections,\n);\n\nexport const selectAllUnconfirmedConnections = createSelector(\n  selectAllPendingConnections,\n  (pendingConnections) =>\n    pendingConnections.filter(\n      (pc) => pc.state === pendingConnection_states.UNCONFIRMED,\n    ),\n);\n\nexport const selectPendingConnectionByBrightId = createSelector(\n  selectAllPendingConnections,\n  (_, brightId: string) => brightId,\n  (pendingConnections, brightId) => {\n    return pendingConnections.find((pc) => brightId === pc.brightId);\n  },\n);\n\n/*\n  Using DeepEqualStringArraySelector here because there are different inputs:\n  - selectAllPendingConnections/selectAllUnconfirmedConnections:\n    Returns an array of objects directly from state. This is immutable, so we can use\n    referential equality check.\n  - channelIds:\n    This array is created dynamically and will be a new object with each invocation. Therefore\n    we have to use deep equality check\n */\nexport const selectAllPendingConnectionsByChannelIds =\n  createDeepEqualStringArraySelector(\n    selectAllPendingConnections,\n    (_, channelIds: string[]) => channelIds,\n    (pendingConnections, channelIds) => {\n      console.log(`selectAllPendingConnectionsByChannelIds ${channelIds}...`);\n      return pendingConnections.filter((pc) =>\n        channelIds.includes(pc.channelId),\n      );\n    },\n  );\nexport const selectAllUnconfirmedConnectionsByChannelIds =\n  createDeepEqualStringArraySelector(\n    selectAllUnconfirmedConnections,\n    (_, channelIds: string[]) => channelIds,\n    (pendingConnections, channelIds) => {\n      console.log(\n        `selectAllUnconfirmedConnectionsByChannelIds ${channelIds}...`,\n      );\n      return pendingConnections.filter((pc) =>\n        channelIds.includes(pc.channelId),\n      );\n    },\n  );\n\n// export actions\n\nexport const {\n  updatePendingConnection,\n  removePendingConnection,\n  removeAllPendingConnections,\n  confirmPendingConnection,\n  addFakePendingConnection,\n} = pendingConnectionsSlice.actions;\n\nexport default pendingConnectionsSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}