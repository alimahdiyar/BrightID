{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport i18next from 'i18next';\nimport { GROUPS_TYPE, INVITE_ACTIVE, MIN_CONNECTIONS_FOR_RECOVERY_NOTIFICATION, MIN_RECOVERY_CONNECTIONS, MISC_TYPE, connection_levels } from \"../utils/constants\";\nimport { getInvites } from \"../utils/invites\";\nimport { getGroupName } from \"../utils/groups\";\nimport { setInvites } from \"./index\";\nimport { recoveryConnectionsSelector, verifiedConnectionsSelector } from \"../reducer/connectionsSlice\";\nexport var SET_BACKUP_PENDING = 'SET_BACKUP_PENDING';\nexport var SET_DEVICE_TOKEN = 'SET_DEVICE_TOKEN';\nexport var SET_NOTIFICATION_TOKEN = 'SET_NOTIFICATION_TOKEN';\nexport var SET_ACTIVE_NOTIFICATION = 'SET_ACTIVE_NOTIFICATION';\nexport var REMOVE_ACTIVE_NOTIFICATION = 'REMOVE_ACTIVE_NOTIFICATION';\nexport var SET_RECOVERY_CONNECTIONS_PENDING = 'SET_RECOVERY_CONNECTIONS_PENDING';\nexport var setBackupPending = function setBackupPending(backupPending) {\n  return {\n    type: SET_BACKUP_PENDING,\n    backupPending: backupPending\n  };\n};\nexport var setRecoveryConnectionsPending = function setRecoveryConnectionsPending(recoveryConnectionsPending) {\n  return {\n    type: SET_RECOVERY_CONNECTIONS_PENDING,\n    recoveryConnectionsPending: recoveryConnectionsPending\n  };\n};\nexport var setDeviceToken = function setDeviceToken(deviceToken) {\n  return {\n    type: SET_DEVICE_TOKEN,\n    deviceToken: deviceToken\n  };\n};\nexport var setNotificationToken = function setNotificationToken(notificationToken) {\n  return {\n    type: SET_NOTIFICATION_TOKEN,\n    notificationToken: notificationToken\n  };\n};\nexport var setActiveNotification = function setActiveNotification(notification) {\n  return {\n    type: SET_ACTIVE_NOTIFICATION,\n    notification: notification\n  };\n};\nexport var removeActiveNotification = function removeActiveNotification() {\n  return {\n    type: REMOVE_ACTIVE_NOTIFICATION\n  };\n};\nexport var updateNotifications = function updateNotifications(api) {\n  return function _callee(dispatch, getState) {\n    var password, verifiedConnections, knownLevels, recoveryEligibleConnections, recoveryConnections, _getState, oldInvites, invites, activeInvites, groupName, message;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            try {\n              password = getState().user.password;\n\n              if (!password) {\n                dispatch(setBackupPending(true));\n                dispatch(setActiveNotification({\n                  title: i18next.t('notificationBar.title.backupPassword'),\n                  message: i18next.t('notificationBar.text.backupPassword'),\n                  type: MISC_TYPE,\n                  oncePerSession: true,\n                  navigationTarget: 'Notifications',\n                  icon: 'PhoneLock'\n                }));\n              } else {\n                dispatch(setBackupPending(false));\n              }\n            } catch (err) {\n              console.log(err);\n            }\n\n            try {\n              verifiedConnections = verifiedConnectionsSelector(getState());\n              knownLevels = Array(connection_levels.ALREADY_KNOWN, connection_levels.RECOVERY);\n              recoveryEligibleConnections = verifiedConnections.filter(function (conn) {\n                return knownLevels.includes(conn.level) && knownLevels.includes(conn.incomingLevel);\n              });\n              recoveryConnections = recoveryConnectionsSelector(getState());\n\n              if (recoveryConnections.length < MIN_RECOVERY_CONNECTIONS && recoveryEligibleConnections.length >= MIN_CONNECTIONS_FOR_RECOVERY_NOTIFICATION) {\n                dispatch(setRecoveryConnectionsPending(true));\n                dispatch(setActiveNotification({\n                  title: i18next.t('notificationBar.title.socialRecovery'),\n                  message: i18next.t('notificationBar.text.socialRecovery'),\n                  type: MISC_TYPE,\n                  oncePerSession: true,\n                  navigationTarget: 'Notifications',\n                  icon: 'PhoneLock'\n                }));\n              } else {\n                dispatch(setRecoveryConnectionsPending(false));\n              }\n            } catch (err) {\n              console.log(err);\n            }\n\n            if (!api) {\n              _context.next = 15;\n              break;\n            }\n\n            _context.prev = 3;\n            _getState = getState(), oldInvites = _getState.groups.invites;\n            _context.next = 7;\n            return _regeneratorRuntime.awrap(getInvites(api));\n\n          case 7:\n            invites = _context.sent;\n            dispatch(setInvites(invites));\n\n            if (invites.length > oldInvites.length) {\n              activeInvites = invites.filter(function (invite) {\n                return invite.state === INVITE_ACTIVE;\n              });\n              groupName = getGroupName(activeInvites[activeInvites.length - 1].group);\n              message = \"You've been invited to join \" + groupName;\n              dispatch(setActiveNotification({\n                title: 'Group Invitation',\n                message: message,\n                type: GROUPS_TYPE,\n                navigationTarget: 'Notifications',\n                icon: 'AddGroup'\n              }));\n            }\n\n            _context.next = 15;\n            break;\n\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](3);\n            console.log(_context.t0);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[3, 12]], Promise);\n  };\n};","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/actions/notifications.ts"],"names":["SET_BACKUP_PENDING","SET_DEVICE_TOKEN","SET_NOTIFICATION_TOKEN","SET_ACTIVE_NOTIFICATION","REMOVE_ACTIVE_NOTIFICATION","SET_RECOVERY_CONNECTIONS_PENDING","setBackupPending","type","backupPending","setRecoveryConnectionsPending","recoveryConnectionsPending","setDeviceToken","deviceToken","setNotificationToken","notificationToken","setActiveNotification","notification","removeActiveNotification","updateNotifications","password","getState","dispatch","title","i18next","message","oncePerSession","navigationTarget","icon","console","verifiedConnections","verifiedConnectionsSelector","knownLevels","Array","connection_levels","recoveryEligibleConnections","conn","recoveryConnections","recoveryConnectionsSelector","oldInvites","invites","getInvites","setInvites","activeInvites","invite","groupName","getGroupName"],"mappings":"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","sourcesContent":["import i18next from 'i18next';\nimport { NodeApi } from '@/api/brightId';\nimport {\n  GROUPS_TYPE,\n  INVITE_ACTIVE,\n  MIN_CONNECTIONS_FOR_RECOVERY_NOTIFICATION,\n  MIN_RECOVERY_CONNECTIONS,\n  MISC_TYPE,\n  connection_levels,\n} from '@/utils/constants';\nimport { getInvites } from '@/utils/invites';\nimport { getGroupName } from '@/utils/groups';\nimport { setInvites } from './index';\nimport {\n  recoveryConnectionsSelector,\n  verifiedConnectionsSelector,\n} from '@/reducer/connectionsSlice';\n\nexport const SET_BACKUP_PENDING = 'SET_BACKUP_PENDING';\nexport const SET_DEVICE_TOKEN = 'SET_DEVICE_TOKEN';\nexport const SET_NOTIFICATION_TOKEN = 'SET_NOTIFICATION_TOKEN';\nexport const SET_ACTIVE_NOTIFICATION = 'SET_ACTIVE_NOTIFICATION';\nexport const REMOVE_ACTIVE_NOTIFICATION = 'REMOVE_ACTIVE_NOTIFICATION';\nexport const SET_RECOVERY_CONNECTIONS_PENDING =\n  'SET_RECOVERY_CONNECTIONS_PENDING';\n\nexport const setBackupPending = (backupPending: boolean) => ({\n  type: SET_BACKUP_PENDING,\n  backupPending,\n});\n\nexport const setRecoveryConnectionsPending = (\n  recoveryConnectionsPending: boolean,\n) => ({\n  type: SET_RECOVERY_CONNECTIONS_PENDING,\n  recoveryConnectionsPending,\n});\n\nexport const setDeviceToken = (deviceToken: string) => ({\n  type: SET_DEVICE_TOKEN,\n  deviceToken,\n});\n\nexport const setNotificationToken = (notificationToken: string) => ({\n  type: SET_NOTIFICATION_TOKEN,\n  notificationToken,\n});\n\nexport const setActiveNotification = (notification: BannerNotification) => ({\n  type: SET_ACTIVE_NOTIFICATION,\n  notification,\n});\n\nexport const removeActiveNotification = () => ({\n  type: REMOVE_ACTIVE_NOTIFICATION,\n});\n\nexport const updateNotifications =\n  (api?: NodeApi) => async (dispatch: dispatch, getState: () => State) => {\n    // check for pending backup setup\n    try {\n      const { password } = getState().user;\n      if (!password) {\n        dispatch(setBackupPending(true));\n        dispatch(\n          setActiveNotification({\n            title: i18next.t('notificationBar.title.backupPassword'),\n            message: i18next.t('notificationBar.text.backupPassword'),\n            type: MISC_TYPE,\n            oncePerSession: true,\n            navigationTarget: 'Notifications',\n            icon: 'PhoneLock',\n          }),\n        );\n      } else {\n        dispatch(setBackupPending(false));\n      }\n    } catch (err) {\n      console.log(err);\n    }\n\n    // check for pending recovery connections\n    try {\n      const verifiedConnections = verifiedConnectionsSelector(getState());\n      const knownLevels = Array<ConnectionLevel>(\n        connection_levels.ALREADY_KNOWN,\n        connection_levels.RECOVERY,\n      );\n      const recoveryEligibleConnections = verifiedConnections.filter(\n        (conn) =>\n          knownLevels.includes(conn.level) &&\n          knownLevels.includes(conn.incomingLevel),\n      );\n      const recoveryConnections = recoveryConnectionsSelector(getState());\n      if (\n        recoveryConnections.length < MIN_RECOVERY_CONNECTIONS &&\n        recoveryEligibleConnections.length >=\n          MIN_CONNECTIONS_FOR_RECOVERY_NOTIFICATION\n      ) {\n        dispatch(setRecoveryConnectionsPending(true));\n        dispatch(\n          setActiveNotification({\n            title: i18next.t('notificationBar.title.socialRecovery'),\n            message: i18next.t('notificationBar.text.socialRecovery'),\n            type: MISC_TYPE,\n            oncePerSession: true,\n            navigationTarget: 'Notifications',\n            icon: 'PhoneLock',\n          }),\n        );\n      } else {\n        dispatch(setRecoveryConnectionsPending(false));\n      }\n    } catch (err) {\n      console.log(err);\n    }\n\n    // check for invites\n    if (api) {\n      try {\n        const {\n          groups: { invites: oldInvites },\n        } = getState();\n        // this can not be done in reducer because it should be in an async function\n        const invites = await getInvites(api);\n        dispatch(setInvites(invites));\n        if (invites.length > oldInvites.length) {\n          const activeInvites = invites.filter(\n            (invite) => invite.state === INVITE_ACTIVE,\n          );\n          const groupName = getGroupName(\n            activeInvites[activeInvites.length - 1].group,\n          );\n          const message = `You've been invited to join ${groupName}`;\n          dispatch(\n            setActiveNotification({\n              title: 'Group Invitation',\n              message,\n              type: GROUPS_TYPE,\n              navigationTarget: 'Notifications',\n              icon: 'AddGroup',\n            }),\n          );\n        }\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  };\n"]},"metadata":{},"sourceType":"module"}