{"ast":null,"code":"'use strict';\n\nvar pna = require('process-nextick-args');\n\nmodule.exports = Readable;\n\nvar isArray = require('isarray');\n\nvar Duplex;\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n\nvar Stream = require(\"./internal/streams/stream\");\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n\nvar debugUtil = require('util');\n\nvar debug = void 0;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n\nvar BufferList = require(\"./internal/streams/BufferList\");\n\nvar destroyImpl = require(\"./internal/streams/destroy\");\n\nvar StringDecoder;\nutil.inherits(Readable, Stream);\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require(\"./_stream_duplex\");\n  options = options || {};\n  var isDuplex = stream instanceof Duplex;\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n  this.highWaterMark = Math.floor(this.highWaterMark);\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n  this.sync = true;\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.destroyed = false;\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n  this.awaitDrain = 0;\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require(\"./_stream_duplex\");\n  if (!(this instanceof Readable)) return new Readable(options);\n  this._readableState = new ReadableState(options, this);\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    if (!this._readableState) {\n      return;\n    }\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n\n  return er;\n}\n\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\nvar MAX_HWM = 0x800000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n}\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    if (state.length === 0) state.needReadable = true;\n\n    this._read(state.highWaterMark);\n\n    state.sync = false;\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    if (!state.ended) state.needReadable = true;\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n  emitReadable(stream);\n}\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) break;else len = state.length;\n  }\n\n  state.readingMore = false;\n}\n\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup');\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n\n    if (false === ret && !increasedAwaitDrain) {\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n\n      src.pause();\n    }\n  }\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  prependListener(dest, 'error', onerror);\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  dest.emit('pipe', src);\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n  if (state.pipesCount === 0) return this;\n\n  if (state.pipesCount === 1) {\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  if (!dest) {\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }\n\n    return this;\n  }\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {}\n}\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nReadable._fromList = fromList;\n\nfunction fromList(n, state) {\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n  return ret;\n}\n\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n\n  if (n < list.head.data.length) {\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    ret = list.shift();\n  } else {\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n\n  return ret;\n}\n\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n\n      break;\n    }\n\n    ++c;\n  }\n\n  list.length -= c;\n  return ret;\n}\n\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n\n      break;\n    }\n\n    ++c;\n  }\n\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","map":{"version":3,"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/readable-stream/lib/_stream_readable.js"],"names":["pna","require","module","isArray","Readable","EE","EElistenerCount","emitter","Stream","Buffer","OurUint8Array","global","obj","util","Object","debugUtil","debug","BufferList","destroyImpl","kProxyEvents","Duplex","options","isDuplex","stream","hwm","readableHwm","defaultHwm","Math","StringDecoder","get","set","cb","state","encoding","chunk","skipChunkCheck","readableAddChunk","onEofChunk","er","chunkInvalid","_uint8ArrayToBuffer","addChunk","maybeReadMore","needMoreData","emitReadable","_isUint8Array","MAX_HWM","n","computeNewHighWaterMark","parseInt","nOrig","endReadable","howMuchToRead","doRead","ret","fromList","emitReadable_","flow","len","src","doEnd","pipeOpts","dest","process","endFn","readable","unpipeInfo","cleanup","ondrain","pipeOnDrain","cleanedUp","increasedAwaitDrain","indexOf","unpipe","prependListener","hasUnpiped","dests","i","index","res","ev","self","resume","_this","paused","enumerable","fromListPartial","list","hasStrings","copyFromBufferString","copyFromBuffer","p","c","str","nb","buf","l","xs"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}"]},"metadata":{},"sourceType":"script"}