{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport any from 'promise.any';\nimport { satisfies } from 'compare-versions';\nimport { NODE_CHOOSER_TIMEOUT_MS, requiredSemVer } from \"./constants\";\nany.shim();\n\nvar chooseNode = function _callee(nodeUrls) {\n  var promises, _iterator, _step, baseUrl, winner;\n\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          promises = [];\n          promises.push(new Promise(function (resolve) {\n            setTimeout(resolve, NODE_CHOOSER_TIMEOUT_MS, 'TIMEOUT');\n          }));\n\n          for (_iterator = _createForOfIteratorHelperLoose(nodeUrls); !(_step = _iterator()).done;) {\n            baseUrl = _step.value;\n            promises.push(validateNode(baseUrl));\n          }\n\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(Promise.any(promises));\n\n        case 5:\n          winner = _context.sent;\n          return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n            if (winner === 'TIMEOUT') {\n              return reject(new Error('No node responded in time'));\n            } else {\n              console.log(\"Nodechooser: Fastest node is \" + winner + \".\");\n              return resolve(winner);\n            }\n          }));\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar validateNode = function _callee2(baseUrl) {\n  var start, validationTasks, elapsed;\n  return _regeneratorRuntime.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          start = Date.now();\n          validationTasks = [validateAPI(baseUrl, 5), validateAPI(baseUrl, 6), validateProfileService(baseUrl)];\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(Promise.all(validationTasks));\n\n        case 4:\n          elapsed = Date.now() - start;\n          console.log(\"Nodechooser: Node \" + baseUrl + \" passed all tests after \" + elapsed + \"ms\");\n          return _context2.abrupt(\"return\", baseUrl);\n\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar validateProfileService = function validateProfileService(baseUrl) {\n  return new Promise(function (resolve, reject) {\n    fetch(baseUrl + \"/profile/list/abc123\").then(function (response) {\n      if (!response.ok) {\n        console.log(\"Nodechooser profile service: Invalid http response from \" + baseUrl + \": \" + response.status + \" \" + response.statusText);\n        throw new Error('Profile Response not ok');\n      } else {\n        return response.json();\n      }\n    }).then(function (json) {\n      validateProfileJsonResponse(json);\n      resolve(baseUrl);\n    }).catch(function (error) {\n      console.log(\"Nodechooser: Node \" + baseUrl + \" failed with \" + error);\n      reject(error);\n    });\n  });\n};\n\nvar validateAPI = function validateAPI(baseUrl, apiVersion) {\n  return new Promise(function (resolve, reject) {\n    var stateUrl = baseUrl + \"/brightid/v\" + apiVersion + \"/state\";\n    fetch(stateUrl).then(function (response) {\n      if (!response.ok) {\n        console.log(\"Nodechooser: Invalid http response from \" + stateUrl + \": \" + response.status + \" \" + response.statusText);\n        throw new Error('Response not ok');\n      } else {\n        return response.json();\n      }\n    }).then(function (json) {\n      validateAPIJsonResponse(json, apiVersion);\n      resolve(baseUrl);\n    }).catch(function (error) {\n      console.log(\"Nodechooser: Node \" + baseUrl + \" failed v\" + apiVersion + \" test with \" + error);\n      reject(error);\n    });\n  });\n};\n\nvar expectedAPIRootKey = 'data';\nvar expectedAPIBodyKeys = {\n  5: ['lastProcessedBlock', 'verificationsBlock', 'initOp', 'sentOp', 'verificationsHashes'],\n  6: ['lastProcessedBlock', 'verificationsBlock', 'initOp', 'sentOp', 'verificationsHashes', 'wISchnorrPublic', 'ethSigningAddress', 'consensusSenderAddress', 'version']\n};\n\nvar validateAPIJsonResponse = function validateAPIJsonResponse(json, apiVersion) {\n  var body = json[expectedAPIRootKey];\n\n  if (!body) {\n    throw new Error(\"Missing rootkey \" + expectedAPIRootKey);\n  }\n\n  var keys = Object.keys(body);\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(expectedAPIBodyKeys[apiVersion]), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n\n    if (keys.indexOf(key) === -1) {\n      throw new Error(\"Missing bodykey \" + key);\n    }\n  }\n\n  if (apiVersion >= 6) {\n    if (!satisfies(body.version, requiredSemVer)) {\n      throw new Error(\"Node version \" + body.version + \" does not satisfy required version \" + requiredSemVer);\n    }\n  }\n};\n\nvar expectedProfileKey = 'profileIds';\n\nvar validateProfileJsonResponse = function validateProfileJsonResponse(json) {\n  var keys = Object.keys(json);\n\n  if (keys.indexOf(expectedProfileKey) === -1) {\n    throw new Error(\"Missing profile key \" + expectedProfileKey);\n  }\n\n  var data = json[expectedProfileKey];\n\n  if (JSON.stringify(data) !== '[]') {\n    throw new Error(\"Unexpected profile response \" + data + \" - Expected empty array\");\n  }\n\n  return true;\n};\n\nexport default chooseNode;","map":{"version":3,"names":["any","satisfies","NODE_CHOOSER_TIMEOUT_MS","requiredSemVer","shim","chooseNode","nodeUrls","promises","push","Promise","resolve","setTimeout","baseUrl","validateNode","winner","reject","Error","console","log","start","Date","now","validationTasks","validateAPI","validateProfileService","all","elapsed","fetch","then","response","ok","status","statusText","json","validateProfileJsonResponse","catch","error","apiVersion","stateUrl","validateAPIJsonResponse","expectedAPIRootKey","expectedAPIBodyKeys","body","keys","Object","key","indexOf","version","expectedProfileKey","data","JSON","stringify"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/utils/nodeChooser.ts"],"sourcesContent":["// Shim Promise.any() which is not yet available in react native\nimport any from 'promise.any';\nimport { satisfies } from 'compare-versions';\nimport { NODE_CHOOSER_TIMEOUT_MS, requiredSemVer } from '@/utils/constants';\n\nany.shim();\n\n/**\n * Returns a promise that\n *  -> Resolves with the baseUrl that is providing the fastest response\n *  -> Rejects if no url is providing a valid answer in time\n * @param nodeUrls String array of baseUrls\n */\nconst chooseNode = async (nodeUrls: Array<string>) => {\n  const promises: Array<Promise<string>> = [];\n\n  // add timeout promise to limit waiting time\n  promises.push(\n    new Promise((resolve) => {\n      setTimeout(resolve, NODE_CHOOSER_TIMEOUT_MS, 'TIMEOUT');\n    }),\n  );\n\n  // create validation promise for each candidate\n  for (const baseUrl of nodeUrls) {\n    promises.push(validateNode(baseUrl));\n  }\n\n  // Wait for the first promise to resolve with Promise.any()\n  // @ts-ignore: Property 'any' does not exist on type 'PromiseConstructor'\n  const winner: string = await Promise.any(promises);\n\n  return new Promise<string>((resolve, reject) => {\n    if (winner === 'TIMEOUT') {\n      // no node responded within my time limit\n      return reject(new Error('No node responded in time'));\n    } else {\n      console.log(`Nodechooser: Fastest node is ${winner}.`);\n      return resolve(winner);\n    }\n  });\n};\n\n/*\n */\nconst validateNode = async (baseUrl: string) => {\n  const start = Date.now();\n  const validationTasks = [\n    validateAPI(baseUrl, 5),\n    validateAPI(baseUrl, 6),\n    validateProfileService(baseUrl),\n  ];\n  await Promise.all(validationTasks);\n  const elapsed = Date.now() - start;\n  console.log(\n    `Nodechooser: Node ${baseUrl} passed all tests after ${elapsed}ms`,\n  );\n  return baseUrl;\n};\n\n/**\n *   Check if the provided Url points to a working BrightID profile service.\n *   Get the response from /brightid/profile/list endpoint and check\n *   if the reply makes sense.\n * @param baseUrl\n */\nconst validateProfileService = (baseUrl: string) =>\n  new Promise<string>((resolve, reject) => {\n    // fetch a random channel. Response should be an empty array\n    fetch(`${baseUrl}/profile/list/abc123`)\n      .then((response) => {\n        // network request was okay, now check server response on http level\n        if (!response.ok) {\n          console.log(\n            `Nodechooser profile service: Invalid http response from ${baseUrl}: ${response.status} ${response.statusText}`,\n          );\n          throw new Error('Profile Response not ok');\n        } else {\n          // Response is fine on http level. Now see if the content is also fine.\n          return response.json(); // will throw if response body is not JSON\n        }\n      })\n      .then((json) => {\n        // Body contains JSON. Now check if JSON content is acceptable.\n        validateProfileJsonResponse(json); // will throw if invalid\n        resolve(baseUrl);\n      })\n      .catch((error) => {\n        console.log(`Nodechooser: Node ${baseUrl} failed with ${error}`);\n        reject(error);\n      });\n  });\n\n/**\n *   Check if the provided Url points to a working BrightID node.\n *   Get the response from /brightid/v5/state endpoint and check\n *   if the reply makes sense.\n * @param baseUrl\n */\nconst validateAPI = (baseUrl: string, apiVersion: number) =>\n  new Promise<string>((resolve, reject) => {\n    const stateUrl = `${baseUrl}/brightid/v${apiVersion}/state`;\n    fetch(stateUrl)\n      .then((response) => {\n        // network request was okay, now check server response on http level\n        if (!response.ok) {\n          console.log(\n            `Nodechooser: Invalid http response from ${stateUrl}: ${response.status} ${response.statusText}`,\n          );\n          throw new Error('Response not ok');\n        } else {\n          // Response is fine on http level. Now see if the content is also fine.\n          return response.json(); // will throw if response body is not JSON\n        }\n      })\n      .then((json) => {\n        // Body contains JSON. Now check if JSON content is acceptable.\n        validateAPIJsonResponse(json, apiVersion); // will throw if invalid\n        resolve(baseUrl);\n      })\n      .catch((error) => {\n        console.log(\n          `Nodechooser: Node ${baseUrl} failed v${apiVersion} test with ${error}`,\n        );\n        reject(error);\n      });\n  });\n\n/**\n * Check if json API response contains expected content.\n *\n * Expected schema:\n * {\n *   \"data\": {\n *     \"lastProcessedBlock\": number,\n *     \"verificationsBlock\": number,\n *     \"initOp\": number,\n *     \"sentOp\": number,\n *     \"verificationsHashes\": object\n *   }\n * }\n *\n * @param json\n */\nconst expectedAPIRootKey = 'data';\nconst expectedAPIBodyKeys = {\n  5: [\n    'lastProcessedBlock',\n    'verificationsBlock',\n    'initOp',\n    'sentOp',\n    'verificationsHashes',\n  ],\n  6: [\n    'lastProcessedBlock',\n    'verificationsBlock',\n    'initOp',\n    'sentOp',\n    'verificationsHashes',\n    'wISchnorrPublic',\n    'ethSigningAddress',\n    'consensusSenderAddress',\n    'version',\n  ],\n};\n\nconst validateAPIJsonResponse = (json, apiVersion: number) => {\n  const body = json[expectedAPIRootKey];\n  if (!body) {\n    throw new Error(`Missing rootkey ${expectedAPIRootKey}`);\n  }\n  const keys = Object.keys(body);\n  for (const key of expectedAPIBodyKeys[apiVersion]) {\n    if (keys.indexOf(key) === -1) {\n      throw new Error(`Missing bodykey ${key}`);\n    }\n  }\n  if (apiVersion >= 6) {\n    // starting with v6, BrightID node state response includes a version string. Check if it satisfies client requirements\n    if (!satisfies(body.version, requiredSemVer)) {\n      throw new Error(\n        `Node version ${body.version} does not satisfy required version ${requiredSemVer}`,\n      );\n    }\n  }\n};\n\n/**\n * Check if json profile server response contains expected content.\n *\n * Expected schema:\n * {\n *   \"profileIds\": []\n * }\n *\n * @param json\n */\n\nconst expectedProfileKey = 'profileIds';\nconst validateProfileJsonResponse = (json) => {\n  const keys = Object.keys(json);\n  if (keys.indexOf(expectedProfileKey) === -1) {\n    throw new Error(`Missing profile key ${expectedProfileKey}`);\n  }\n  const data = json[expectedProfileKey];\n  if (JSON.stringify(data) !== '[]') {\n    throw new Error(\n      `Unexpected profile response ${data} - Expected empty array`,\n    );\n  }\n  return true;\n};\n\nexport default chooseNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}