{"ast":null,"code":"'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require(\"./_stream_duplex\");\n\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n  this._readableState.needReadable = true;\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) stream.push(data);\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n  return stream.push(null);\n}","map":{"version":3,"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/readable-stream/lib/_stream_transform.js"],"names":["module","Duplex","require","util","Object","ts","cb","data","rs","afterTransform","needTransform","transforming","writecb","writechunk","writeencoding","options","_this","done","Transform","_this2","stream"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}"]},"metadata":{},"sourceType":"script"}