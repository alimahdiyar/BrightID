{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.confirmPendingConnectionThunk = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _channelSlice = require(\"../channelSlice\");\n\nvar _actions = require(\"../../../actions\");\n\nvar _filesystem = require(\"../../../utils/filesystem\");\n\nvar _backupThunks = require(\"../../Onboarding/RecoveryFlow/thunks/backupThunks\");\n\nvar _pendingConnectionSlice = require(\"../pendingConnectionSlice\");\n\nvar _channelThunks = require(\"./channelThunks\");\n\nvar _constants = require(\"../../../utils/constants\");\n\nvar confirmPendingConnectionThunk = function confirmPendingConnectionThunk(id, level, api, reportReason) {\n  return function _callee(dispatch, getState) {\n    var connection, _connection$pendingCo, profileInfo, sharedProfile, channel, _getState, _getState$user, brightId, backupCompleted, connectionTimestamp, op, _op, filename, connectionData, reported;\n\n    return _regenerator.default.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            connection = (0, _pendingConnectionSlice.selectPendingConnectionById)(getState(), id);\n\n            if (!(connection.state !== _pendingConnectionSlice.pendingConnection_states.UNCONFIRMED)) {\n              _context.next = 4;\n              break;\n            }\n\n            console.log(\"Can't confirm - Connection is in state \" + connection.state);\n            return _context.abrupt(\"return\");\n\n          case 4:\n            _connection$pendingCo = connection.pendingConnectionData, profileInfo = _connection$pendingCo.profileInfo, sharedProfile = _connection$pendingCo.sharedProfile;\n            dispatch((0, _pendingConnectionSlice.updatePendingConnection)({\n              id: id,\n              changes: {\n                state: _pendingConnectionSlice.pendingConnection_states.CONFIRMING\n              }\n            }));\n            channel = (0, _channelSlice.selectChannelById)(getState(), connection.channelId);\n            console.log(\"confirming connection \" + id + \" in channel \" + channel.id + \" with level '\" + level + \"'\");\n            _getState = getState(), _getState$user = _getState.user, brightId = _getState$user.id, backupCompleted = _getState$user.backupCompleted;\n            connectionTimestamp = sharedProfile.profileTimestamp;\n            _context.next = 12;\n            return _regenerator.default.awrap(api.addConnection(brightId, sharedProfile.id, level, connectionTimestamp, reportReason, sharedProfile.requestProof));\n\n          case 12:\n            op = _context.sent;\n            dispatch((0, _actions.addOperation)(op));\n\n            if (!__DEV__) {\n              _context.next = 20;\n              break;\n            }\n\n            if (!sharedProfile.secretKey) {\n              _context.next = 20;\n              break;\n            }\n\n            _context.next = 18;\n            return _regenerator.default.awrap(api.addConnection(sharedProfile.id, brightId, level, connectionTimestamp, reportReason, sharedProfile.requestProof, {\n              id: sharedProfile.id,\n              secretKey: sharedProfile.secretKey\n            }));\n\n          case 18:\n            _op = _context.sent;\n            dispatch((0, _actions.addOperation)(_op));\n\n          case 20:\n            _context.next = 22;\n            return _regenerator.default.awrap((0, _filesystem.saveImage)({\n              imageName: sharedProfile.id,\n              base64Image: sharedProfile.photo\n            }));\n\n          case 22:\n            filename = _context.sent;\n            connectionData = {\n              id: sharedProfile.id,\n              name: sharedProfile.name,\n              connectionDate: connectionTimestamp,\n              photo: {\n                filename: filename\n              },\n              status: 'initiated',\n              notificationToken: sharedProfile.notificationToken,\n              secretKey: sharedProfile.secretKey,\n              level: level,\n              reportReason: reportReason,\n              socialMedia: sharedProfile.socialMedia,\n              verifications: (profileInfo == null ? void 0 : profileInfo.verifications) || []\n            };\n            dispatch((0, _actions.addConnection)(connectionData));\n            dispatch((0, _pendingConnectionSlice.confirmPendingConnection)(connection.profileId));\n            reported = Array(_constants.connection_levels.SUSPICIOUS, _constants.connection_levels.REPORTED).includes(level);\n\n            if (!(connection.profileId === channel.initiatorProfileId)) {\n              _context.next = 34;\n              break;\n            }\n\n            if (reported) {\n              _context.next = 33;\n              break;\n            }\n\n            _context.next = 31;\n            return _regenerator.default.awrap(dispatch((0, _channelThunks.encryptAndUploadProfileToChannel)(channel.id)));\n\n          case 31:\n            _context.next = 34;\n            break;\n\n          case 33:\n            if (channel.type === _channelSlice.channel_types.GROUP) {\n              console.log(\"Leaving group channel \" + channel.id + \" cause I don't trust the initiator (level: '\" + level + \"')\");\n              dispatch((0, _channelThunks.leaveChannel)(channel.id));\n            }\n\n          case 34:\n            if (channel.type === _channelSlice.channel_types.SINGLE || channel.type === _channelSlice.channel_types.STAR && channel.initiatorProfileId !== channel.myProfileId) {\n              dispatch((0, _channelThunks.leaveChannel)(channel.id));\n            }\n\n            if (!backupCompleted) {\n              _context.next = 40;\n              break;\n            }\n\n            _context.next = 38;\n            return _regenerator.default.awrap(dispatch((0, _backupThunks.backupPhoto)(sharedProfile.id, filename)));\n\n          case 38:\n            _context.next = 40;\n            return _regenerator.default.awrap(dispatch((0, _backupThunks.backupUser)()));\n\n          case 40:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nexports.confirmPendingConnectionThunk = confirmPendingConnectionThunk;","map":{"version":3,"names":["confirmPendingConnectionThunk","id","level","api","reportReason","dispatch","getState","connection","selectPendingConnectionById","state","pendingConnection_states","UNCONFIRMED","console","log","pendingConnectionData","profileInfo","sharedProfile","updatePendingConnection","changes","CONFIRMING","channel","selectChannelById","channelId","user","brightId","backupCompleted","connectionTimestamp","profileTimestamp","addConnection","requestProof","op","addOperation","__DEV__","secretKey","saveImage","imageName","base64Image","photo","filename","connectionData","name","connectionDate","status","notificationToken","socialMedia","verifications","confirmPendingConnection","profileId","reported","Array","connection_levels","SUSPICIOUS","REPORTED","includes","initiatorProfileId","encryptAndUploadProfileToChannel","type","channel_types","GROUP","leaveChannel","SINGLE","STAR","myProfileId","backupPhoto","backupUser"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/actions/pendingConnectionThunks.ts"],"sourcesContent":["import {\n  channel_types,\n  selectChannelById,\n} from '@/components/PendingConnections/channelSlice';\nimport { addConnection, addOperation } from '@/actions';\nimport { saveImage } from '@/utils/filesystem';\nimport {\n  backupPhoto,\n  backupUser,\n} from '@/components/Onboarding/RecoveryFlow/thunks/backupThunks';\nimport {\n  confirmPendingConnection,\n  pendingConnection_states,\n  selectPendingConnectionById,\n  updatePendingConnection,\n} from '@/components/PendingConnections/pendingConnectionSlice';\nimport {\n  leaveChannel,\n  encryptAndUploadProfileToChannel,\n} from '@/components/PendingConnections/actions/channelThunks';\nimport { NodeApi } from '@/api/brightId';\nimport { connection_levels } from '@/utils/constants';\n\nexport const confirmPendingConnectionThunk =\n  (\n    id: string,\n    level: ConnectionLevel,\n    api: NodeApi,\n    reportReason?: ReportReason,\n  ) =>\n  async (dispatch: dispatch, getState: getState) => {\n    const connection: PendingConnection = selectPendingConnectionById(\n      getState(),\n      id,\n    );\n    // validate pendingConnection state\n    if (connection.state !== pendingConnection_states.UNCONFIRMED) {\n      console.log(`Can't confirm - Connection is in state ${connection.state}`);\n      return;\n    }\n\n    const {\n      pendingConnectionData: { profileInfo, sharedProfile },\n    } = connection;\n\n    dispatch(\n      updatePendingConnection({\n        id,\n        changes: {\n          state: pendingConnection_states.CONFIRMING,\n        },\n      }),\n    );\n\n    const channel = selectChannelById(getState(), connection.channelId);\n    console.log(\n      `confirming connection ${id} in channel ${channel.id} with level '${level}'`,\n    );\n\n    const {\n      user: { id: brightId, backupCompleted },\n    } = getState();\n\n    const connectionTimestamp = sharedProfile.profileTimestamp;\n    const op = await api.addConnection(\n      brightId,\n      sharedProfile.id,\n      level,\n      connectionTimestamp,\n      reportReason,\n      sharedProfile.requestProof,\n    );\n    dispatch(addOperation(op));\n\n    if (__DEV__) {\n      // if peer is a fake connection also submit opposite addConnection operation\n      if (sharedProfile.secretKey) {\n        const op = await api.addConnection(\n          sharedProfile.id,\n          brightId,\n          level,\n          connectionTimestamp,\n          reportReason,\n          sharedProfile.requestProof,\n          {\n            id: sharedProfile.id,\n            secretKey: sharedProfile.secretKey,\n          },\n        );\n        dispatch(addOperation(op));\n      }\n    }\n\n    // save connection photo\n    const filename = await saveImage({\n      imageName: sharedProfile.id,\n      base64Image: sharedProfile.photo,\n    });\n\n    // create established connection from pendingConnection\n    const connectionData: LocalConnectionData = {\n      id: sharedProfile.id,\n      name: sharedProfile.name,\n      connectionDate: connectionTimestamp,\n      photo: { filename },\n      status: 'initiated',\n      notificationToken: sharedProfile.notificationToken,\n      secretKey: sharedProfile.secretKey,\n      level,\n      reportReason,\n      socialMedia: sharedProfile.socialMedia,\n      verifications: profileInfo?.verifications || [],\n    };\n\n    dispatch(addConnection(connectionData));\n    dispatch(confirmPendingConnection(connection.profileId));\n\n    const reported = Array<ConnectionLevel>(\n      connection_levels.SUSPICIOUS,\n      connection_levels.REPORTED,\n    ).includes(level);\n\n    // check connection level with initiator to decide next steps\n    if (connection.profileId === channel.initiatorProfileId) {\n      if (!reported) {\n        // upload profile to channel only *after* accepting the connection with creator\n        // to prevent leaking my profile info to unwanted connections\n        await dispatch(encryptAndUploadProfileToChannel(channel.id));\n      } else if (channel.type === channel_types.GROUP) {\n        // immediately leave group connection channel if initiator got reported\n        console.log(\n          `Leaving group channel ${channel.id} cause I don't trust the initiator (level: '${level}')`,\n        );\n        dispatch(leaveChannel(channel.id));\n      }\n    }\n\n    // Leave channel if no additional connections are expected\n    if (\n      channel.type === channel_types.SINGLE ||\n      (channel.type === channel_types.STAR &&\n        channel.initiatorProfileId !== channel.myProfileId)\n    ) {\n      dispatch(leaveChannel(channel.id));\n    }\n\n    if (backupCompleted) {\n      await dispatch(backupPhoto(sharedProfile.id, filename));\n      await dispatch(backupUser());\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}