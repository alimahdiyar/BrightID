{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Animated, { Easing as OldEasing, EasingNode } from 'react-native-reanimated';\nimport memoize from \"./memoize\";\nvar Easing = EasingNode || OldEasing;\nvar multiply = Animated.multiply,\n    Extrapolate = Animated.Extrapolate;\nvar interpolate = Animated.interpolateNode || Animated.interpolate;\n\nvar TabBarIndicator = function (_React$Component) {\n  _inherits(TabBarIndicator, _React$Component);\n\n  var _super = _createSuper(TabBarIndicator);\n\n  function TabBarIndicator() {\n    var _this;\n\n    _classCallCheck(this, TabBarIndicator);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"fadeInIndicator\", function () {\n      var _this$props = _this.props,\n          navigationState = _this$props.navigationState,\n          layout = _this$props.layout,\n          width = _this$props.width,\n          getTabWidth = _this$props.getTabWidth;\n\n      if (!_this.isIndicatorShown && width === 'auto' && layout.width && navigationState.routes.every(function (_, i) {\n        return getTabWidth(i);\n      })) {\n        _this.isIndicatorShown = true;\n        Animated.timing(_this.opacity, {\n          duration: 150,\n          toValue: 1,\n          easing: Easing.in(Easing.linear)\n        }).start();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isIndicatorShown\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"opacity\", new Animated.Value(_this.props.width === 'auto' ? 0 : 1));\n\n    _defineProperty(_assertThisInitialized(_this), \"getTranslateX\", memoize(function (position, routes, getTabWidth) {\n      var inputRange = routes.map(function (_, i) {\n        return i;\n      });\n      var outputRange = routes.reduce(function (acc, _, i) {\n        if (i === 0) return [0];\n        return [].concat(_toConsumableArray(acc), [acc[i - 1] + getTabWidth(i - 1)]);\n      }, []);\n      var translateX = interpolate(position, {\n        inputRange: inputRange,\n        outputRange: outputRange,\n        extrapolate: Extrapolate.CLAMP\n      });\n      return multiply(translateX, I18nManager.isRTL ? -1 : 1);\n    }));\n\n    _defineProperty(_assertThisInitialized(_this), \"getWidth\", memoize(function (position, routes, getTabWidth) {\n      var inputRange = routes.map(function (_, i) {\n        return i;\n      });\n      var outputRange = inputRange.map(getTabWidth);\n      return interpolate(position, {\n        inputRange: inputRange,\n        outputRange: outputRange,\n        extrapolate: Extrapolate.CLAMP\n      });\n    }));\n\n    return _this;\n  }\n\n  _createClass(TabBarIndicator, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.fadeInIndicator();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.fadeInIndicator();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          position = _this$props2.position,\n          navigationState = _this$props2.navigationState,\n          getTabWidth = _this$props2.getTabWidth,\n          width = _this$props2.width,\n          style = _this$props2.style,\n          layout = _this$props2.layout;\n      var routes = navigationState.routes;\n      var translateX = routes.length > 1 ? this.getTranslateX(position, routes, getTabWidth) : 0;\n      var indicatorWidth = width === 'auto' ? routes.length > 1 ? this.getWidth(position, routes, getTabWidth) : getTabWidth(0) : width;\n      return React.createElement(Animated.View, {\n        style: [styles.indicator, {\n          width: indicatorWidth\n        }, layout.width ? {\n          transform: [{\n            translateX: translateX\n          }]\n        } : {\n          left: \"\".concat(100 / routes.length * navigationState.index, \"%\")\n        }, width === 'auto' ? {\n          opacity: this.opacity\n        } : null, style]\n      });\n    }\n  }]);\n\n  return TabBarIndicator;\n}(React.Component);\n\nexport { TabBarIndicator as default };\nvar styles = StyleSheet.create({\n  indicator: {\n    backgroundColor: '#ffeb3b',\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 2\n  }\n});","map":{"version":3,"sources":["TabBarIndicator.tsx"],"names":["Easing","EasingNode","multiply","Extrapolate","Animated","interpolate","TabBarIndicator","React","Component","componentDidMount","componentDidUpdate","navigationState","layout","width","getTabWidth","duration","toValue","easing","memoize","inputRange","routes","outputRange","i","acc","translateX","extrapolate","I18nManager","render","position","style","indicatorWidth","styles","transform","left","opacity","StyleSheet","indicator","backgroundColor","bottom","right","height"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, I18nManager, StyleProp, ViewStyle } from 'react-native';\nimport Animated, {\n  Easing as OldEasing,\n  // @ts-ignore\n  EasingNode,\n} from 'react-native-reanimated';\n\nimport memoize from './memoize';\nimport { Route, SceneRendererProps, NavigationState } from './types';\n\nconst Easing = EasingNode || OldEasing;\n\nexport type GetTabWidth = (index: number) => number;\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  width: string | number;\n  style?: StyleProp<ViewStyle>;\n  getTabWidth: GetTabWidth;\n};\n\nconst { multiply, Extrapolate } = Animated;\n\n// @ts-ignore\nconst interpolate = Animated.interpolateNode || Animated.interpolate;\n\nexport default class TabBarIndicator<T extends Route> extends React.Component<\n  Props<T>\n> {\n  componentDidMount() {\n    this.fadeInIndicator();\n  }\n\n  componentDidUpdate() {\n    this.fadeInIndicator();\n  }\n\n  private fadeInIndicator = () => {\n    const { navigationState, layout, width, getTabWidth } = this.props;\n\n    if (\n      !this.isIndicatorShown &&\n      width === 'auto' &&\n      layout.width &&\n      // We should fade-in the indicator when we have widths for all the tab items\n      navigationState.routes.every((_, i) => getTabWidth(i))\n    ) {\n      this.isIndicatorShown = true;\n\n      Animated.timing(this.opacity, {\n        duration: 150,\n        toValue: 1,\n        easing: Easing.in(Easing.linear),\n      }).start();\n    }\n  };\n\n  private isIndicatorShown = false;\n\n  private opacity = new Animated.Value(this.props.width === 'auto' ? 0 : 1);\n\n  private getTranslateX = memoize(\n    (\n      position: Animated.Node<number>,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n    ) => {\n      const inputRange = routes.map((_, i) => i);\n\n      // every index contains widths at all previous indices\n      const outputRange = routes.reduce<number[]>((acc, _, i) => {\n        if (i === 0) return [0];\n        return [...acc, acc[i - 1] + getTabWidth(i - 1)];\n      }, []);\n\n      const translateX = interpolate(position, {\n        inputRange,\n        outputRange,\n        extrapolate: Extrapolate.CLAMP,\n      });\n\n      return multiply(translateX, I18nManager.isRTL ? -1 : 1);\n    }\n  );\n\n  private getWidth = memoize(\n    (\n      position: Animated.Node<number>,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n    ) => {\n      const inputRange = routes.map((_, i) => i);\n      const outputRange = inputRange.map(getTabWidth);\n\n      return interpolate(position, {\n        inputRange,\n        outputRange,\n        extrapolate: Extrapolate.CLAMP,\n      });\n    }\n  );\n\n  render() {\n    const {\n      position,\n      navigationState,\n      getTabWidth,\n      width,\n      style,\n      layout,\n    } = this.props;\n    const { routes } = navigationState;\n\n    const translateX =\n      routes.length > 1 ? this.getTranslateX(position, routes, getTabWidth) : 0;\n\n    const indicatorWidth =\n      width === 'auto'\n        ? routes.length > 1\n          ? this.getWidth(position, routes, getTabWidth)\n          : getTabWidth(0)\n        : width;\n\n    return (\n      <Animated.View\n        style={[\n          styles.indicator,\n          // If layout is not available, use `left` property for positioning the indicator\n          // This avoids rendering delay until we are able to calculate translateX\n          { width: indicatorWidth },\n          layout.width\n            ? { transform: [{ translateX }] as any }\n            : { left: `${(100 / routes.length) * navigationState.index}%` },\n          width === 'auto' ? { opacity: this.opacity } : null,\n          style,\n        ]}\n      />\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  indicator: {\n    backgroundColor: '#ffeb3b',\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 2,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}