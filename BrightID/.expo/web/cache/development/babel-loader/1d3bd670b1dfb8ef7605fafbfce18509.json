{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { asyncCreateMigrate } from \"./asyncCreateMigrate\";\nimport { connection_levels, RECOVERY_COOLDOWN_EXEMPTION } from \"../../utils/constants\";\n\nvar findId = function findId(conn) {\n  return conn.id;\n};\n\nvar connectionsMigrations = {\n  11: function _(state) {\n    var _state$connections, recoveryConnections;\n\n    return _regeneratorRuntime.async(function _$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!state.firstRecoveryTime) {\n              if (state != null && (_state$connections = state.connections) != null && _state$connections.entities) {\n                recoveryConnections = Object.values(state.connections.entities).filter(function (conn) {\n                  return conn.level === connection_levels.RECOVERY;\n                });\n\n                if (recoveryConnections.length) {\n                  state.firstRecoveryTime = Date.now() - (RECOVERY_COOLDOWN_EXEMPTION + 60 * 1000);\n                }\n              }\n            }\n\n            return _context.abrupt(\"return\", state);\n\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  10: function _(state) {\n    var filteredConnections, ids, entities;\n    return _regeneratorRuntime.async(function _$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (Array.isArray(state.connections)) {\n              filteredConnections = state.connections.filter(findId);\n              ids = filteredConnections.map(findId);\n              entities = {};\n              filteredConnections.forEach(function (conn) {\n                entities[findId(conn)] = conn;\n              });\n              state.connections = {\n                ids: ids,\n                entities: entities\n              };\n            }\n\n            return _context2.abrupt(\"return\", state);\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\nexport var connectionsMigrate = asyncCreateMigrate(connectionsMigrations, {\n  debug: __DEV__\n});","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/store/migrations/connections.ts"],"names":["findId","conn","connectionsMigrations","state","recoveryConnections","Object","connection_levels","Date","RECOVERY_COOLDOWN_EXEMPTION","Array","filteredConnections","ids","entities","connectionsMigrate","asyncCreateMigrate","debug"],"mappings":";AACA,SAAA,kBAAA;AACA,SAAA,iBAAA,EAAA,2BAAA;;AAKA,IAAMA,MAAM,GAANA,SAAAA,MAAAA,CAAS,IAATA,EAAS;EAAA,OAAsBC,IAAI,CAA1B,EAAA;AAAf,CAAA;;AAYA,IAAMC,qBAAwC,GAAG;EAC/C,IAAI,SAAA,CAAA,CAAA,KAAA,EAAA;IAAA,IAAA,kBAAA,EAAA,mBAAA;;IAAA,OAAA,mBAAA,CAAA,KAAA,CAAA,SAAA,EAAA,CAAA,QAAA,EAAA;MAAA,OAAA,CAAA,EAAA;QAAA,QAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;UAAA,KAAA,CAAA;YAEF,IAAI,CAACC,KAAK,CAAV,iBAAA,EAA8B;cAC5B,IAAIA,KAAJ,IAAA,IAAIA,IAAJ,CAAA,kBAAA,GAAIA,KAAK,CAAT,WAAA,KAAA,IAAIA,IAAAA,kBAAAA,CAAJ,QAAA,EAAkC;gBAC1BC,mBAD0B,GACJC,MAAM,CAANA,MAAAA,CAC1BF,KAAK,CAALA,WAAAA,CAD0BE,QAAAA,EAAAA,MAAAA,CAEnB,UAAA,IAAA,EAAA;kBAAA,OAAUJ,IAAI,CAAJA,KAAAA,KAAeK,iBAAiB,CAA1C,QAAA;gBAHuB,CACJD,CAAtBD;;gBAGN,IAAIA,mBAAmB,CAAvB,MAAA,EAAgC;kBAE9BD,KAAK,CAALA,iBAAAA,GACEI,IAAI,CAAJA,GAAAA,MAAcC,2BAA2B,GAAG,KAD9CL,IACEI,CADFJ;gBAGH;cACF;YAbC;;YAAA,OAAA,QAAA,CAAA,MAAA,CAAA,QAAA,EAAA,KAAA,CAAA;;UAAA,KAAA,CAAA;UAAA,KAAA,KAAA;YAAA,OAAA,QAAA,CAAA,IAAA,EAAA;QAAA;MAAA;IAAA,CAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA,CAAA;EAD2C,CAAA;EAiB/C,IAAI,SAAA,CAAA,CAAA,KAAA,EAAA;IAAA,IAAA,mBAAA,EAAA,GAAA,EAAA,QAAA;IAAA,OAAA,mBAAA,CAAA,KAAA,CAAA,SAAA,EAAA,CAAA,SAAA,EAAA;MAAA,OAAA,CAAA,EAAA;QAAA,QAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;UAAA,KAAA,CAAA;YAEF,IAAIM,KAAK,CAALA,OAAAA,CAAcN,KAAK,CAAvB,WAAIM,CAAJ,EAAsC;cAC9BC,mBAD8B,GACRP,KAAK,CAALA,WAAAA,CAAAA,MAAAA,CADQ,MACRA,CAAtBO;cAEAC,GAH8B,GAGxBD,mBAAmB,CAAnBA,GAAAA,CAHwB,MAGxBA,CAANC;cAEAC,QAL8B,GAAA,EAK9BA;cAENF,mBAAmB,CAAnBA,OAAAA,CAA4B,UAAA,IAAA,EAAU;gBACpCE,QAAQ,CAACZ,MAAM,CAAfY,IAAe,CAAP,CAARA,GAAAA,IAAAA;cADFF,CAAAA;cAIAP,KAAK,CAALA,WAAAA,GAAoB;gBAAEQ,GAAG,EAAL,GAAA;gBAAOC,QAAQ,EAAnCT;cAAoB,CAApBA;YAbA;;YAAA,OAAA,SAAA,CAAA,MAAA,CAAA,QAAA,EAAA,KAAA,CAAA;;UAAA,KAAA,CAAA;UAAA,KAAA,KAAA;YAAA,OAAA,SAAA,CAAA,IAAA,EAAA;QAAA;MAAA;IAAA,CAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA,CAAA;EAjBN;AAAiD,CAAjD;AAoCA,OAAO,IAAMU,kBAAkB,GAAGC,kBAAkB,CAAA,qBAAA,EAAwB;EAC1EC,KAAK,EADA;AAAqE,CAAxB,CAA7C","sourcesContent":["import { PersistedState } from 'redux-persist';\nimport { asyncCreateMigrate, MigrationManifest } from './asyncCreateMigrate';\nimport {\n  connection_levels,\n  RECOVERY_COOLDOWN_EXEMPTION,\n} from '@/utils/constants';\n\nconst findId = (conn: Connection) => conn.id;\n\ntype V9State = {\n  connections: Connection[];\n  connectionsSort: string;\n  searchParam: string;\n  searchOpen: boolean;\n  filters: ConnectionLevel[];\n} & PersistedState;\n\ntype V10State = ConnectionsState & PersistedState;\n\nconst connectionsMigrations: MigrationManifest = {\n  11: async (state: ConnectionsState & PersistedState) => {\n    // Set first recovery time if not yet set and user has existing RECOVERY connections\n    if (!state.firstRecoveryTime) {\n      if (state?.connections?.entities) {\n        const recoveryConnections = Object.values(\n          state.connections.entities,\n        ).filter((conn) => conn.level === connection_levels.RECOVERY);\n        if (recoveryConnections.length) {\n          // assume existing connection was made longer ago than cooldown exception duration\n          state.firstRecoveryTime =\n            Date.now() - (RECOVERY_COOLDOWN_EXEMPTION + 60 * 1000);\n        }\n      }\n    }\n    return state;\n  },\n  10: async (state: V9State | V10State) => {\n    // migrate connections to entity adapter\n    if (Array.isArray(state.connections)) {\n      const filteredConnections = state.connections.filter(findId);\n\n      const ids = filteredConnections.map(findId);\n\n      const entities = {};\n\n      filteredConnections.forEach((conn) => {\n        entities[findId(conn)] = conn;\n      });\n\n      state.connections = { ids, entities };\n    }\n    return state;\n  },\n};\n\nexport const connectionsMigrate = asyncCreateMigrate(connectionsMigrations, {\n  debug: __DEV__,\n});\n"]},"metadata":{},"sourceType":"module"}