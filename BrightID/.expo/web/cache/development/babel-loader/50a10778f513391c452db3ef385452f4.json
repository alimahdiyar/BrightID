{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport NativeEventEmitter from \"react-native-web/dist/exports/NativeEventEmitter\";\nimport log from \"./logging\";\n\nmodule.exports = function (NativeCodePush) {\n  var remote = function remote(reportStatusDownload) {\n    return {\n      download: function download(downloadProgressCallback) {\n        var _this = this;\n\n        return function _callee() {\n          var downloadProgressSubscription, codePushEventEmitter, updatePackageCopy, downloadedPackage;\n          return _regeneratorRuntime.async(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (_this.downloadUrl) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  throw new Error(\"Cannot download an update without a download url\");\n\n                case 2:\n                  if (downloadProgressCallback) {\n                    codePushEventEmitter = new NativeEventEmitter(NativeCodePush);\n                    downloadProgressSubscription = codePushEventEmitter.addListener(\"CodePushDownloadProgress\", downloadProgressCallback);\n                  }\n\n                  _context.prev = 3;\n                  updatePackageCopy = _extends({}, _this);\n                  Object.keys(updatePackageCopy).forEach(function (key) {\n                    return typeof updatePackageCopy[key] === 'function' && delete updatePackageCopy[key];\n                  });\n                  _context.next = 8;\n                  return _regeneratorRuntime.awrap(NativeCodePush.downloadUpdate(updatePackageCopy, !!downloadProgressCallback));\n\n                case 8:\n                  downloadedPackage = _context.sent;\n\n                  if (reportStatusDownload) {\n                    reportStatusDownload(_this).catch(function (err) {\n                      log(\"Report download status failed: \" + err);\n                    });\n                  }\n\n                  return _context.abrupt(\"return\", _objectSpread(_objectSpread({}, downloadedPackage), local));\n\n                case 11:\n                  _context.prev = 11;\n                  downloadProgressSubscription && downloadProgressSubscription.remove();\n                  return _context.finish(11);\n\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, null, null, [[3,, 11, 14]], Promise);\n        }();\n      },\n      isPending: false\n    };\n  };\n\n  var local = {\n    install: function install() {\n      var _this2 = this;\n\n      var installMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NativeCodePush.codePushInstallModeOnNextRestart;\n      var minimumBackgroundDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var updateInstalledCallback = arguments.length > 2 ? arguments[2] : undefined;\n      return function _callee2() {\n        var localPackage, localPackageCopy;\n        return _regeneratorRuntime.async(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                localPackage = _this2;\n                localPackageCopy = _extends({}, localPackage);\n                _context2.next = 4;\n                return _regeneratorRuntime.awrap(NativeCodePush.installUpdate(localPackageCopy, installMode, minimumBackgroundDuration));\n\n              case 4:\n                updateInstalledCallback && updateInstalledCallback();\n\n                if (installMode == NativeCodePush.codePushInstallModeImmediate) {\n                  NativeCodePush.restartApp(false);\n                } else {\n                  NativeCodePush.clearPendingRestart();\n                  localPackage.isPending = true;\n                }\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      }();\n    },\n    isPending: false\n  };\n  return {\n    local: local,\n    remote: remote\n  };\n};","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/node_modules/react-native-code-push/package-mixins.js"],"names":["module","remote","download","codePushEventEmitter","downloadProgressSubscription","updatePackageCopy","Object","downloadedPackage","NativeCodePush","reportStatusDownload","log","isPending","local","install","installMode","codePushInstallModeOnNextRestart","minimumBackgroundDuration","updateInstalledCallback","localPackage","localPackageCopy"],"mappings":"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","sourcesContent":["import { NativeEventEmitter } from \"react-native\";\nimport log from \"./logging\";\n\n// This function is used to augment remote and local\n// package objects with additional functionality/properties\n// beyond what is included in the metadata sent by the server.\nmodule.exports = (NativeCodePush) => {\n  const remote = (reportStatusDownload) => {\n    return {\n      async download(downloadProgressCallback) {\n        if (!this.downloadUrl) {\n          throw new Error(\"Cannot download an update without a download url\");\n        }\n\n        let downloadProgressSubscription;\n        if (downloadProgressCallback) {\n          const codePushEventEmitter = new NativeEventEmitter(NativeCodePush);\n          // Use event subscription to obtain download progress.\n          downloadProgressSubscription = codePushEventEmitter.addListener(\n            \"CodePushDownloadProgress\",\n            downloadProgressCallback\n          );\n        }\n\n        // Use the downloaded package info. Native code will save the package info\n        // so that the client knows what the current package version is.\n        try {\n          const updatePackageCopy = Object.assign({}, this);\n          Object.keys(updatePackageCopy).forEach((key) => (typeof updatePackageCopy[key] === 'function') && delete updatePackageCopy[key]);\n\n          const downloadedPackage = await NativeCodePush.downloadUpdate(updatePackageCopy, !!downloadProgressCallback);\n\n          if (reportStatusDownload) {\n            reportStatusDownload(this)\n            .catch((err) => {\n              log(`Report download status failed: ${err}`);\n            });\n          }\n\n          return { ...downloadedPackage, ...local };\n        } finally {\n          downloadProgressSubscription && downloadProgressSubscription.remove();\n        }\n      },\n\n      isPending: false // A remote package could never be in a pending state\n    };\n  };\n\n  const local = {\n    async install(installMode = NativeCodePush.codePushInstallModeOnNextRestart, minimumBackgroundDuration = 0, updateInstalledCallback) {\n      const localPackage = this;\n      const localPackageCopy = Object.assign({}, localPackage); // In dev mode, React Native deep freezes any object queued over the bridge\n      await NativeCodePush.installUpdate(localPackageCopy, installMode, minimumBackgroundDuration);\n      updateInstalledCallback && updateInstalledCallback();\n      if (installMode == NativeCodePush.codePushInstallModeImmediate) {\n        NativeCodePush.restartApp(false);\n      } else {\n        NativeCodePush.clearPendingRestart();\n        localPackage.isPending = true; // Mark the package as pending since it hasn't been applied yet\n      }\n    },\n\n    isPending: false // A local package wouldn't be pending until it was installed\n  };\n\n  return { local, remote };\n};"]},"metadata":{},"sourceType":"module"}