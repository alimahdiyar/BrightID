{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { saveImage } from \"../../../../utils/filesystem\";\nimport { decryptData } from \"../../../../utils/cryptoHelper\";\nimport { b64ToUrlSafeB64 } from \"../../../../utils/encoding\";\nimport { addConnection, upsertGroup, selectAllConnections } from \"../../../../actions\";\nimport { RecoveryError, RecoveryErrorType } from \"../RecoveryError\";\nimport { setSig, updateNamePhoto, increaseRecoveredConnections, increaseRecoveredGroups, setRecoveryError } from \"../recoveryDataSlice\";\n\nvar downloadConnection = function _callee(_ref) {\n  var dataId, channelApi, aesKey, channelId, encrypted, connectionData;\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          dataId = _ref.dataId, channelApi = _ref.channelApi, aesKey = _ref.aesKey, channelId = _ref.channelId;\n          _context.prev = 1;\n          console.log(channelId, dataId);\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(channelApi.download({\n            channelId: channelId,\n            dataId: dataId,\n            deleteAfterDownload: true\n          }));\n\n        case 5:\n          encrypted = _context.sent;\n          connectionData = decryptData(encrypted, aesKey);\n\n          if (!(!connectionData || !(connectionData != null && connectionData.id) || !(connectionData != null && connectionData.name))) {\n            _context.next = 10;\n            break;\n          }\n\n          console.log('missing connection data');\n          return _context.abrupt(\"return\");\n\n        case 10:\n          console.log(\"Downloaded profile data of \" + connectionData.name + \" (\" + (connectionData == null ? void 0 : connectionData.id) + \")\");\n          return _context.abrupt(\"return\", connectionData);\n\n        case 14:\n          _context.prev = 14;\n          _context.t0 = _context[\"catch\"](1);\n          console.error(\"downloadConnection: \" + _context.t0.message);\n          throw _context.t0;\n\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[1, 14]], Promise);\n};\n\nexport var downloadConnections = function downloadConnections(_ref2) {\n  var channelApi = _ref2.channelApi,\n      dataIds = _ref2.dataIds;\n  return function _callee2(dispatch, getState) {\n    var _getState, signingKey, _getState$recoveryDat, recoveryId, aesKey, channelId, connections, existingConnIds, isConn, connId, uploader, connectionDataIds, count, _iterator, _step, dataId, connectionData, filename, newConnection;\n\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _getState = getState(), signingKey = _getState.keypair.publicKey, _getState$recoveryDat = _getState.recoveryData, recoveryId = _getState$recoveryDat.id, aesKey = _getState$recoveryDat.aesKey, channelId = _getState$recoveryDat.channel.channelId;\n            connections = selectAllConnections(getState());\n            existingConnIds = connections.map(function (c) {\n              return c.id;\n            });\n\n            isConn = function isConn(id) {\n              return id.startsWith('connection_');\n            };\n\n            connId = function connId(id) {\n              return id.replace('connection_', '').split(':')[0];\n            };\n\n            uploader = function uploader(id) {\n              return id.replace('connection_', '').split(':')[1];\n            };\n\n            connectionDataIds = dataIds.filter(function (id) {\n              return isConn(id) && uploader(id) !== b64ToUrlSafeB64(signingKey) && !existingConnIds.includes(connId(id)) && connId(id) !== recoveryId;\n            });\n            count = 0;\n            _iterator = _createForOfIteratorHelperLoose(connectionDataIds);\n\n          case 10:\n            if ((_step = _iterator()).done) {\n              _context2.next = 26;\n              break;\n            }\n\n            dataId = _step.value;\n            _context2.next = 14;\n            return _regeneratorRuntime.awrap(downloadConnection({\n              dataId: dataId,\n              channelApi: channelApi,\n              aesKey: aesKey,\n              channelId: channelId\n            }));\n\n          case 14:\n            connectionData = _context2.sent;\n\n            if (!connectionData) {\n              _context2.next = 24;\n              break;\n            }\n\n            filename = void 0;\n\n            if (!connectionData.photo) {\n              _context2.next = 21;\n              break;\n            }\n\n            _context2.next = 20;\n            return _regeneratorRuntime.awrap(saveImage({\n              imageName: connectionData.id,\n              base64Image: connectionData.photo\n            }));\n\n          case 20:\n            filename = _context2.sent;\n\n          case 21:\n            newConnection = _objectSpread(_objectSpread({}, connectionData), {}, {\n              photo: {\n                filename: filename\n              }\n            });\n            dispatch(addConnection(newConnection));\n            count++;\n\n          case 24:\n            _context2.next = 10;\n            break;\n\n          case 26:\n            if (count > 0) {\n              dispatch(increaseRecoveredConnections(count));\n            }\n\n            return _context2.abrupt(\"return\", connectionDataIds.length);\n\n          case 30:\n            _context2.prev = 30;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.error(\"downloadingConnections: \" + _context2.t0.message);\n\n          case 33:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 30]], Promise);\n  };\n};\nexport var downloadNamePhoto = function downloadNamePhoto(_ref3) {\n  var channelApi = _ref3.channelApi,\n      dataIds = _ref3.dataIds;\n  return function _callee3(dispatch, getState) {\n    var _getState2, signingKey, _getState2$recoveryDa, recoveryId, aesKey, channelId, connId, uploader, dataId, connectionData, _getState3, name, filename;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _getState2 = getState(), signingKey = _getState2.keypair.publicKey, _getState2$recoveryDa = _getState2.recoveryData, recoveryId = _getState2$recoveryDa.id, aesKey = _getState2$recoveryDa.aesKey, channelId = _getState2$recoveryDa.channel.channelId;\n\n            connId = function connId(id) {\n              return id.replace('connection_', '').split(':')[0];\n            };\n\n            uploader = function uploader(id) {\n              return id.replace('connection_', '').split(':')[1];\n            };\n\n            dataId = dataIds.find(function (id) {\n              return connId(id) === recoveryId && uploader(id) !== b64ToUrlSafeB64(signingKey);\n            });\n\n            if (!dataId) {\n              _context3.next = 15;\n              break;\n            }\n\n            _context3.next = 7;\n            return _regeneratorRuntime.awrap(downloadConnection({\n              dataId: dataId,\n              channelApi: channelApi,\n              aesKey: aesKey,\n              channelId: channelId\n            }));\n\n          case 7:\n            connectionData = _context3.sent;\n            _getState3 = getState(), name = _getState3.recoveryData.name;\n\n            if (!(!name && connectionData)) {\n              _context3.next = 15;\n              break;\n            }\n\n            if (!connectionData.photo) {\n              _context3.next = 14;\n              break;\n            }\n\n            _context3.next = 13;\n            return _regeneratorRuntime.awrap(saveImage({\n              imageName: connectionData.id,\n              base64Image: connectionData.photo\n            }));\n\n          case 13:\n            filename = _context3.sent;\n\n          case 14:\n            dispatch(updateNamePhoto({\n              name: connectionData.name,\n              photo: {\n                filename: filename\n              }\n            }));\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nvar downloadGroup = function _callee4(_ref4) {\n  var dataId, channelApi, aesKey, channelId, encrypted, groupData, filename;\n  return _regeneratorRuntime.async(function _callee4$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          dataId = _ref4.dataId, channelApi = _ref4.channelApi, aesKey = _ref4.aesKey, channelId = _ref4.channelId;\n          _context4.prev = 1;\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(channelApi.download({\n            channelId: channelId,\n            dataId: dataId,\n            deleteAfterDownload: true\n          }));\n\n        case 4:\n          encrypted = _context4.sent;\n          groupData = decryptData(encrypted, aesKey);\n\n          if (!(!groupData || !(groupData != null && groupData.id) || !(groupData != null && groupData.aesKey))) {\n            _context4.next = 9;\n            break;\n          }\n\n          console.log('missing group data');\n          return _context4.abrupt(\"return\");\n\n        case 9:\n          if (!groupData.photo) {\n            _context4.next = 13;\n            break;\n          }\n\n          _context4.next = 12;\n          return _regeneratorRuntime.awrap(saveImage({\n            imageName: groupData.id,\n            base64Image: groupData.photo\n          }));\n\n        case 12:\n          filename = _context4.sent;\n\n        case 13:\n          groupData.photo = {\n            filename: filename\n          };\n          return _context4.abrupt(\"return\", groupData);\n\n        case 17:\n          _context4.prev = 17;\n          _context4.t0 = _context4[\"catch\"](1);\n          console.error(\"downloadGroup: \" + _context4.t0.message);\n\n        case 20:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 17]], Promise);\n};\n\nexport var downloadGroups = function downloadGroups(_ref5) {\n  var channelApi = _ref5.channelApi,\n      dataIds = _ref5.dataIds;\n  return function _callee5(dispatch, getState) {\n    var _getState4, signingKey, _getState4$recoveryDa, aesKey, channelId, isGroup, uploader, groupDataIds, count, _iterator2, _step2, dataId, groupData;\n\n    return _regeneratorRuntime.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            _getState4 = getState(), signingKey = _getState4.keypair.publicKey, _getState4$recoveryDa = _getState4.recoveryData, aesKey = _getState4$recoveryDa.aesKey, channelId = _getState4$recoveryDa.channel.channelId;\n\n            isGroup = function isGroup(id) {\n              return id.startsWith('group_');\n            };\n\n            uploader = function uploader(id) {\n              return id.replace('group_', '').split(':')[1];\n            };\n\n            groupDataIds = dataIds.filter(function (id) {\n              return isGroup(id) && uploader(id) !== b64ToUrlSafeB64(signingKey);\n            });\n            count = 0;\n            _iterator2 = _createForOfIteratorHelperLoose(groupDataIds);\n\n          case 7:\n            if ((_step2 = _iterator2()).done) {\n              _context5.next = 15;\n              break;\n            }\n\n            dataId = _step2.value;\n            _context5.next = 11;\n            return _regeneratorRuntime.awrap(downloadGroup({\n              dataId: dataId,\n              channelApi: channelApi,\n              aesKey: aesKey,\n              channelId: channelId\n            }));\n\n          case 11:\n            groupData = _context5.sent;\n\n            if (groupData) {\n              dispatch(upsertGroup(groupData));\n              count++;\n            }\n\n          case 13:\n            _context5.next = 7;\n            break;\n\n          case 15:\n            if (count > 0) {\n              dispatch(increaseRecoveredGroups(count));\n            }\n\n            return _context5.abrupt(\"return\", groupDataIds.length);\n\n          case 19:\n            _context5.prev = 19;\n            _context5.t0 = _context5[\"catch\"](0);\n            console.error(\"downloadingGroups: \" + _context5.t0.message);\n\n          case 22:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, [[0, 19]], Promise);\n  };\n};\nexport var downloadSigs = function downloadSigs(_ref6) {\n  var channelApi = _ref6.channelApi,\n      dataIds = _ref6.dataIds;\n  return function _callee6(dispatch, getState) {\n    var _getState5, _getState5$recoveryDa, sigs, channelId, id, isSig, sigId, sigDataIds, _iterator3, _step3, dataId, signer, sig;\n\n    return _regeneratorRuntime.async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _getState5 = getState(), _getState5$recoveryDa = _getState5.recoveryData, sigs = _getState5$recoveryDa.sigs, channelId = _getState5$recoveryDa.channel.channelId, id = _getState5$recoveryDa.id;\n\n            isSig = function isSig(id) {\n              return id.startsWith('sig_');\n            };\n\n            sigId = function sigId(id) {\n              return id.replace('sig_', '').split(':')[0];\n            };\n\n            sigDataIds = dataIds.filter(function (dataId) {\n              return isSig(dataId) && !sigs[sigId(dataId)];\n            });\n            _iterator3 = _createForOfIteratorHelperLoose(sigDataIds);\n\n          case 6:\n            if ((_step3 = _iterator3()).done) {\n              _context6.next = 17;\n              break;\n            }\n\n            dataId = _step3.value;\n            signer = sigId(dataId);\n            _context6.next = 11;\n            return _regeneratorRuntime.awrap(channelApi.download({\n              channelId: channelId,\n              dataId: dataId\n            }));\n\n          case 11:\n            sig = _context6.sent;\n\n            if (!(id && sig.id !== id)) {\n              _context6.next = 14;\n              break;\n            }\n\n            throw new RecoveryError(RecoveryErrorType.MISMATCH_ID);\n\n          case 14:\n            dispatch(setSig({\n              signer: signer,\n              sig: sig\n            }));\n\n          case 15:\n            _context6.next = 6;\n            break;\n\n          case 17:\n            return _context6.abrupt(\"return\", sigDataIds.length);\n\n          case 20:\n            _context6.prev = 20;\n            _context6.t0 = _context6[\"catch\"](0);\n\n            if (_context6.t0 instanceof RecoveryError) {\n              console.error(\"downloadingSigs: \" + _context6.t0.errorType);\n              dispatch(setRecoveryError({\n                errorType: _context6.t0.errorType\n              }));\n            } else {\n              console.error(\"downloadingSigs: \" + _context6.t0.message);\n              dispatch(setRecoveryError({\n                errorType: RecoveryErrorType.GENERIC,\n                errorMessage: _context6.t0.message\n              }));\n            }\n\n          case 23:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, [[0, 20]], Promise);\n  };\n};","map":{"version":3,"names":["saveImage","decryptData","b64ToUrlSafeB64","addConnection","upsertGroup","selectAllConnections","RecoveryError","RecoveryErrorType","setSig","updateNamePhoto","increaseRecoveredConnections","increaseRecoveredGroups","setRecoveryError","downloadConnection","dataId","channelApi","aesKey","channelId","console","log","download","deleteAfterDownload","encrypted","connectionData","id","name","error","message","downloadConnections","dataIds","dispatch","getState","signingKey","keypair","publicKey","recoveryData","recoveryId","channel","connections","existingConnIds","map","c","isConn","startsWith","connId","replace","split","uploader","connectionDataIds","filter","includes","count","filename","photo","imageName","base64Image","newConnection","length","downloadNamePhoto","find","downloadGroup","groupData","downloadGroups","isGroup","groupDataIds","downloadSigs","sigs","isSig","sigId","sigDataIds","signer","sig","MISMATCH_ID","errorType","GENERIC","errorMessage"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/channelDownloadThunks.ts"],"sourcesContent":["import ChannelAPI from '@/api/channelService';\nimport { saveImage } from '@/utils/filesystem';\nimport { decryptData } from '@/utils/cryptoHelper';\nimport { hash, b64ToUrlSafeB64 } from '@/utils/encoding';\nimport { addConnection, upsertGroup, selectAllConnections } from '@/actions';\nimport {\n  RecoveryError,\n  RecoveryErrorType,\n} from '@/components/Onboarding/RecoveryFlow/RecoveryError';\nimport {\n  setSig,\n  updateNamePhoto,\n  increaseRecoveredConnections,\n  increaseRecoveredGroups,\n  setRecoveryError,\n} from '../recoveryDataSlice';\n\nconst downloadConnection = async ({\n  dataId,\n  channelApi,\n  aesKey,\n  channelId,\n}: {\n  dataId: string;\n  channelApi: ChannelAPI;\n  aesKey: string;\n  channelId: string;\n}): Promise<SyncConnection> => {\n  try {\n    console.log(channelId, dataId);\n    const encrypted = await channelApi.download({\n      channelId,\n      dataId,\n      deleteAfterDownload: true,\n    });\n    const connectionData = decryptData(encrypted, aesKey) as SyncConnection;\n\n    // missing data\n    if (!connectionData || !connectionData?.id || !connectionData?.name) {\n      console.log('missing connection data');\n      return;\n    }\n    console.log(\n      `Downloaded profile data of ${connectionData.name} (${connectionData?.id})`,\n    );\n\n    return connectionData;\n  } catch (err) {\n    console.error(`downloadConnection: ${err.message}`);\n    throw err;\n  }\n};\n\nexport const downloadConnections =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        keypair: { publicKey: signingKey },\n        recoveryData: {\n          id: recoveryId,\n          aesKey,\n          channel: { channelId },\n        },\n      } = getState();\n\n      const connections = selectAllConnections(getState());\n\n      const existingConnIds = connections.map((c) => c.id);\n\n      const isConn = (id) => id.startsWith('connection_');\n      const connId = (id) => id.replace('connection_', '').split(':')[0];\n      const uploader = (id) => id.replace('connection_', '').split(':')[1];\n\n      const connectionDataIds = dataIds.filter(\n        (id) =>\n          isConn(id) &&\n          uploader(id) !== b64ToUrlSafeB64(signingKey) &&\n          !existingConnIds.includes(connId(id)) &&\n          connId(id) !== recoveryId,\n      );\n\n      let count = 0;\n      for (const dataId of connectionDataIds) {\n        const connectionData = await downloadConnection({\n          dataId,\n          channelApi,\n          aesKey,\n          channelId,\n        });\n        if (connectionData) {\n          let filename: string;\n          if (connectionData.photo) {\n            filename = await saveImage({\n              imageName: connectionData.id,\n              base64Image: connectionData.photo,\n            });\n          }\n          const newConnection: Connection = {\n            ...connectionData,\n            photo: { filename },\n          };\n\n          dispatch(addConnection(newConnection));\n          count++;\n        }\n      }\n      if (count > 0) {\n        dispatch(increaseRecoveredConnections(count));\n      }\n      return connectionDataIds.length;\n    } catch (err) {\n      console.error(`downloadingConnections: ${err.message}`);\n    }\n  };\n\nexport const downloadNamePhoto =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    const {\n      keypair: { publicKey: signingKey },\n      recoveryData: {\n        id: recoveryId,\n        aesKey,\n        channel: { channelId },\n      },\n    } = getState();\n\n    const connId = (id) => id.replace('connection_', '').split(':')[0];\n    const uploader = (id) => id.replace('connection_', '').split(':')[1];\n\n    const dataId = dataIds.find(\n      (id) =>\n        connId(id) === recoveryId &&\n        uploader(id) !== b64ToUrlSafeB64(signingKey),\n    );\n\n    if (dataId) {\n      const connectionData = await downloadConnection({\n        dataId,\n        channelApi,\n        aesKey,\n        channelId,\n      });\n\n      const {\n        recoveryData: { name },\n      } = getState();\n\n      if (!name && connectionData) {\n        let filename: string;\n        if (connectionData.photo) {\n          filename = await saveImage({\n            imageName: connectionData.id,\n            base64Image: connectionData.photo,\n          });\n        }\n        dispatch(\n          updateNamePhoto({ name: connectionData.name, photo: { filename } }),\n        );\n      }\n    }\n  };\n\nconst downloadGroup = async ({\n  dataId,\n  channelApi,\n  aesKey,\n  channelId,\n}: {\n  dataId: string;\n  channelApi: ChannelAPI;\n  aesKey: string;\n  channelId: string;\n}) => {\n  try {\n    const encrypted = await channelApi.download({\n      channelId,\n      dataId,\n      deleteAfterDownload: true,\n    });\n    const groupData = decryptData(encrypted, aesKey);\n    // group data missing\n    if (!groupData || !groupData?.id || !groupData?.aesKey) {\n      console.log('missing group data');\n      return;\n    }\n\n    let filename;\n    if (groupData.photo) {\n      filename = await saveImage({\n        imageName: groupData.id,\n        base64Image: groupData.photo,\n      });\n    }\n    groupData.photo = { filename };\n    return groupData;\n  } catch (err) {\n    console.error(`downloadGroup: ${err.message}`);\n  }\n};\n\nexport const downloadGroups =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        keypair: { publicKey: signingKey },\n        recoveryData: {\n          aesKey,\n          channel: { channelId },\n        },\n      } = getState();\n\n      const isGroup = (id) => id.startsWith('group_');\n      const uploader = (id) => id.replace('group_', '').split(':')[1];\n      const groupDataIds = dataIds.filter(\n        (id) => isGroup(id) && uploader(id) !== b64ToUrlSafeB64(signingKey),\n      );\n      let count = 0;\n      for (const dataId of groupDataIds) {\n        const groupData = await downloadGroup({\n          dataId,\n          channelApi,\n          aesKey,\n          channelId,\n        });\n        if (groupData) {\n          dispatch(upsertGroup(groupData));\n          count++;\n        }\n      }\n      if (count > 0) {\n        dispatch(increaseRecoveredGroups(count));\n      }\n      return groupDataIds.length;\n    } catch (err) {\n      console.error(`downloadingGroups: ${err.message}`);\n    }\n  };\n\nexport const downloadSigs =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        recoveryData: {\n          sigs,\n          channel: { channelId },\n          id,\n        },\n      } = getState();\n\n      const isSig = (id: string) => id.startsWith('sig_');\n      const sigId = (id: string) => id.replace('sig_', '').split(':')[0];\n\n      const sigDataIds = dataIds.filter(\n        (dataId) => isSig(dataId) && !sigs[sigId(dataId)],\n      );\n\n      for (const dataId of sigDataIds) {\n        const signer = sigId(dataId);\n        const sig: Signature = await channelApi.download({ channelId, dataId });\n        if (id && sig.id !== id) {\n          // recovery connections disagree on which account is being recovered!\n          throw new RecoveryError(RecoveryErrorType.MISMATCH_ID);\n        }\n        dispatch(setSig({ signer, sig }));\n      }\n      return sigDataIds.length;\n    } catch (err) {\n      if (err instanceof RecoveryError) {\n        console.error(`downloadingSigs: ${err.errorType}`);\n        dispatch(setRecoveryError({ errorType: err.errorType }));\n      } else {\n        console.error(`downloadingSigs: ${err.message}`);\n        dispatch(\n          setRecoveryError({\n            errorType: RecoveryErrorType.GENERIC,\n            errorMessage: err.message,\n          }),\n        );\n      }\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}