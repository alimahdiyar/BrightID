{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _ from 'lodash';\nimport nacl from 'tweetnacl';\nimport stringify from 'fast-json-stable-stringify';\nimport { b64ToUrlSafeB64, strToUint8Array, uInt8ArrayToB64, hash } from \"../../../../utils/encoding\";\nimport { selectAllConnections } from \"../../../../reducer/connectionsSlice\";\nimport { store } from \"../../../../store\";\nimport { loadRecoveryData } from \"../../../../utils/recovery\";\nimport { uploadConnection, uploadGroup } from \"../../../../utils/channels\";\nexport var uploadSig = function uploadSig(_ref) {\n  var id = _ref.id,\n      aesKey = _ref.aesKey,\n      channelApi = _ref.channelApi;\n  return function _callee(_, getState) {\n    var _getState, secretKey, signer, _await$loadRecoveryDa, signingKey, timestamp, op, message, sig, data;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _getState = getState(), secretKey = _getState.keypair.secretKey, signer = _getState.user.id;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(loadRecoveryData(channelApi, aesKey));\n\n          case 3:\n            _await$loadRecoveryDa = _context.sent;\n            signingKey = _await$loadRecoveryDa.signingKey;\n            timestamp = _await$loadRecoveryDa.timestamp;\n            op = {\n              name: 'Social Recovery',\n              id: id,\n              signingKey: signingKey,\n              timestamp: timestamp,\n              v: 6\n            };\n            message = stringify(op);\n            sig = uInt8ArrayToB64(nacl.sign.detached(strToUint8Array(message), secretKey));\n            data = {\n              signer: signer,\n              id: id,\n              sig: sig\n            };\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(channelApi.upload({\n              channelId: hash(aesKey),\n              dataId: \"sig_\" + signer,\n              data: data\n            }));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var uploadMutualInfo = function _callee2(_ref2) {\n  var conn, aesKey, channelApi, nodeApi, _store$getState, signingKey, groups, user, dataIds, connections, connectionsById, groupsById, otherSideConnections, knownLevels, mutualConnections, otherSideGroups, mutualGroups, _iterator, _step, c, _iterator2, _step2, g;\n\n  return _regeneratorRuntime.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          conn = _ref2.conn, aesKey = _ref2.aesKey, channelApi = _ref2.channelApi, nodeApi = _ref2.nodeApi;\n          _store$getState = store.getState(), signingKey = _store$getState.keypair.publicKey, groups = _store$getState.groups.groups, user = _store$getState.user;\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(channelApi.list(hash(aesKey)));\n\n        case 4:\n          dataIds = _context2.sent;\n\n          if (dataIds.includes(\"connection_\" + conn.id + \":\" + b64ToUrlSafeB64(signingKey))) {\n            _context2.next = 9;\n            break;\n          }\n\n          console.log(\"uploading recovery data for connection\");\n          _context2.next = 9;\n          return _regeneratorRuntime.awrap(uploadConnection({\n            conn: conn,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 9:\n          connections = selectAllConnections(store.getState());\n          connectionsById = _.keyBy(connections, 'id');\n          groupsById = _.keyBy(groups, 'id');\n          _context2.next = 14;\n          return _regeneratorRuntime.awrap(nodeApi.getConnections(conn.id, 'inbound'));\n\n        case 14:\n          otherSideConnections = _context2.sent;\n          knownLevels = ['just met', 'already known', 'recovery'];\n          mutualConnections = otherSideConnections ? otherSideConnections.filter(function (c) {\n            return connectionsById[c.id] && connectionsById[c.id].name && knownLevels.includes(c.level) && !dataIds.includes(\"connection_\" + c.id + \":\" + b64ToUrlSafeB64(signingKey));\n          }).map(function (c) {\n            return connectionsById[c.id];\n          }) : [];\n\n          if (!dataIds.includes(\"connection_\" + user.id + \":\" + b64ToUrlSafeB64(signingKey))) {\n            mutualConnections.push(user);\n          }\n\n          _context2.next = 20;\n          return _regeneratorRuntime.awrap(nodeApi.getMemberships(conn.id));\n\n        case 20:\n          otherSideGroups = _context2.sent;\n          mutualGroups = otherSideGroups ? otherSideGroups.filter(function (g) {\n            return groupsById[g.id];\n          }).map(function (g) {\n            return groupsById[g.id];\n          }) : [];\n          console.log('uploading mutual connections');\n          _iterator = _createForOfIteratorHelperLoose(mutualConnections);\n\n        case 24:\n          if ((_step = _iterator()).done) {\n            _context2.next = 30;\n            break;\n          }\n\n          c = _step.value;\n          _context2.next = 28;\n          return _regeneratorRuntime.awrap(uploadConnection({\n            conn: c,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 28:\n          _context2.next = 24;\n          break;\n\n        case 30:\n          console.log('uploading mutual groups');\n          _iterator2 = _createForOfIteratorHelperLoose(mutualGroups);\n\n        case 32:\n          if ((_step2 = _iterator2()).done) {\n            _context2.next = 38;\n            break;\n          }\n\n          g = _step2.value;\n          _context2.next = 36;\n          return _regeneratorRuntime.awrap(uploadGroup({\n            group: g,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 36:\n          _context2.next = 32;\n          break;\n\n        case 38:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/channelUploadThunks.ts"],"names":["uploadSig","id","aesKey","channelApi","secretKey","signer","getState","signingKey","timestamp","loadRecoveryData","op","name","v","message","stringify","sig","uInt8ArrayToB64","nacl","strToUint8Array","data","channelId","hash","dataId","uploadMutualInfo","conn","nodeApi","groups","user","store","dataIds","b64ToUrlSafeB64","console","uploadConnection","connections","selectAllConnections","connectionsById","_","groupsById","otherSideConnections","knownLevels","mutualConnections","c","otherSideGroups","mutualGroups","g","uploadGroup","group"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport nacl from 'tweetnacl';\nimport stringify from 'fast-json-stable-stringify';\nimport {\n  b64ToUrlSafeB64,\n  strToUint8Array,\n  uInt8ArrayToB64,\n  hash,\n} from '@/utils/encoding';\nimport { selectAllConnections } from '@/reducer/connectionsSlice';\nimport ChannelAPI from '@/api/channelService';\nimport { NodeApi } from '@/api/brightId';\nimport { store } from '@/store';\nimport { loadRecoveryData } from '@/utils/recovery';\nimport { uploadConnection, uploadGroup } from '@/utils/channels';\n\nexport const uploadSig =\n  ({\n    id,\n    aesKey,\n    channelApi,\n  }: {\n    id: string;\n    aesKey: string;\n    channelApi: ChannelAPI;\n  }) =>\n  async (_, getState) => {\n    const {\n      keypair: { secretKey },\n      user: { id: signer },\n    } = getState();\n\n    const { signingKey, timestamp } = await loadRecoveryData(\n      channelApi,\n      aesKey,\n    );\n\n    const op = {\n      name: 'Social Recovery',\n      id,\n      signingKey,\n      timestamp,\n      v: 6,\n    };\n    const message = stringify(op);\n    const sig = uInt8ArrayToB64(\n      nacl.sign.detached(strToUint8Array(message), secretKey),\n    );\n\n    const data = { signer, id, sig };\n\n    await channelApi.upload({\n      channelId: hash(aesKey),\n      dataId: `sig_${signer}`,\n      data,\n    });\n  };\n\nexport const uploadMutualInfo = async ({\n  conn,\n  aesKey,\n  channelApi,\n  nodeApi,\n}: {\n  conn: Connection;\n  aesKey: string;\n  channelApi: ChannelAPI;\n  nodeApi: NodeApi;\n}) => {\n  const {\n    keypair: { publicKey: signingKey },\n    groups: { groups },\n    user,\n  } = store.getState();\n  const dataIds = await channelApi.list(hash(aesKey));\n  if (\n    !dataIds.includes(`connection_${conn.id}:${b64ToUrlSafeB64(signingKey)}`)\n  ) {\n    console.log(`uploading recovery data for connection`);\n    await uploadConnection({\n      conn,\n      channelApi,\n      aesKey,\n      signingKey,\n    });\n  }\n  const connections = selectAllConnections(store.getState());\n\n  const connectionsById = _.keyBy(connections, 'id');\n  const groupsById = _.keyBy(groups, 'id');\n\n  const otherSideConnections = await nodeApi.getConnections(conn.id, 'inbound');\n  const knownLevels = ['just met', 'already known', 'recovery'];\n  const mutualConnections = otherSideConnections\n    ? otherSideConnections\n        .filter(\n          (c) =>\n            connectionsById[c.id] &&\n            connectionsById[c.id].name &&\n            knownLevels.includes(c.level) &&\n            !dataIds.includes(\n              `connection_${c.id}:${b64ToUrlSafeB64(signingKey)}`,\n            ),\n        )\n        .map((c) => connectionsById[c.id])\n    : [];\n\n  if (\n    !dataIds.includes(`connection_${user.id}:${b64ToUrlSafeB64(signingKey)}`)\n  ) {\n    mutualConnections.push(user);\n  }\n\n  const otherSideGroups = await nodeApi.getMemberships(conn.id);\n  const mutualGroups = otherSideGroups\n    ? otherSideGroups\n        .filter((g) => groupsById[g.id])\n        .map((g) => groupsById[g.id])\n    : [];\n\n  console.log('uploading mutual connections');\n  for (const c of mutualConnections) {\n    await uploadConnection({\n      conn: c,\n      channelApi,\n      aesKey,\n      signingKey,\n    });\n  }\n  console.log('uploading mutual groups');\n  for (const g of mutualGroups) {\n    await uploadGroup({ group: g, channelApi, aesKey, signingKey });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}