{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { channel_types, selectChannelById } from \"../channelSlice\";\nimport { addConnection, addOperation } from \"../../../actions\";\nimport { saveImage } from \"../../../utils/filesystem\";\nimport { backupPhoto, backupUser } from \"../../Onboarding/RecoveryFlow/thunks/backupThunks\";\nimport { confirmPendingConnection, pendingConnection_states, selectPendingConnectionById, updatePendingConnection } from \"../pendingConnectionSlice\";\nimport { leaveChannel, encryptAndUploadProfileToChannel } from \"./channelThunks\";\nimport { connection_levels } from \"../../../utils/constants\";\nexport var confirmPendingConnectionThunk = function confirmPendingConnectionThunk(id, level, api, reportReason) {\n  return function _callee(dispatch, getState) {\n    var connection, _connection$pendingCo, profileInfo, sharedProfile, channel, _getState, _getState$user, brightId, backupCompleted, connectionTimestamp, op, _op, filename, connectionData, reported;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            connection = selectPendingConnectionById(getState(), id);\n\n            if (!(connection.state !== pendingConnection_states.UNCONFIRMED)) {\n              _context.next = 4;\n              break;\n            }\n\n            console.log(\"Can't confirm - Connection is in state \" + connection.state);\n            return _context.abrupt(\"return\");\n\n          case 4:\n            _connection$pendingCo = connection.pendingConnectionData, profileInfo = _connection$pendingCo.profileInfo, sharedProfile = _connection$pendingCo.sharedProfile;\n            dispatch(updatePendingConnection({\n              id: id,\n              changes: {\n                state: pendingConnection_states.CONFIRMING\n              }\n            }));\n            channel = selectChannelById(getState(), connection.channelId);\n            console.log(\"confirming connection \" + id + \" in channel \" + channel.id + \" with level '\" + level + \"'\");\n            _getState = getState(), _getState$user = _getState.user, brightId = _getState$user.id, backupCompleted = _getState$user.backupCompleted;\n            connectionTimestamp = sharedProfile.profileTimestamp;\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(api.addConnection(brightId, sharedProfile.id, level, connectionTimestamp, reportReason, sharedProfile.requestProof));\n\n          case 12:\n            op = _context.sent;\n            dispatch(addOperation(op));\n\n            if (!__DEV__) {\n              _context.next = 20;\n              break;\n            }\n\n            if (!sharedProfile.secretKey) {\n              _context.next = 20;\n              break;\n            }\n\n            _context.next = 18;\n            return _regeneratorRuntime.awrap(api.addConnection(sharedProfile.id, brightId, level, connectionTimestamp, reportReason, sharedProfile.requestProof, {\n              id: sharedProfile.id,\n              secretKey: sharedProfile.secretKey\n            }));\n\n          case 18:\n            _op = _context.sent;\n            dispatch(addOperation(_op));\n\n          case 20:\n            _context.next = 22;\n            return _regeneratorRuntime.awrap(saveImage({\n              imageName: sharedProfile.id,\n              base64Image: sharedProfile.photo\n            }));\n\n          case 22:\n            filename = _context.sent;\n            connectionData = {\n              id: sharedProfile.id,\n              name: sharedProfile.name,\n              connectionDate: connectionTimestamp,\n              photo: {\n                filename: filename\n              },\n              status: 'initiated',\n              notificationToken: sharedProfile.notificationToken,\n              secretKey: sharedProfile.secretKey,\n              level: level,\n              reportReason: reportReason,\n              socialMedia: sharedProfile.socialMedia,\n              verifications: (profileInfo == null ? void 0 : profileInfo.verifications) || []\n            };\n            dispatch(addConnection(connectionData));\n            dispatch(confirmPendingConnection(connection.profileId));\n            reported = Array(connection_levels.SUSPICIOUS, connection_levels.REPORTED).includes(level);\n\n            if (!(connection.profileId === channel.initiatorProfileId)) {\n              _context.next = 34;\n              break;\n            }\n\n            if (reported) {\n              _context.next = 33;\n              break;\n            }\n\n            _context.next = 31;\n            return _regeneratorRuntime.awrap(dispatch(encryptAndUploadProfileToChannel(channel.id)));\n\n          case 31:\n            _context.next = 34;\n            break;\n\n          case 33:\n            if (channel.type === channel_types.GROUP) {\n              console.log(\"Leaving group channel \" + channel.id + \" cause I don't trust the initiator (level: '\" + level + \"')\");\n              dispatch(leaveChannel(channel.id));\n            }\n\n          case 34:\n            if (channel.type === channel_types.SINGLE || channel.type === channel_types.STAR && channel.initiatorProfileId !== channel.myProfileId) {\n              dispatch(leaveChannel(channel.id));\n            }\n\n            if (!backupCompleted) {\n              _context.next = 40;\n              break;\n            }\n\n            _context.next = 38;\n            return _regeneratorRuntime.awrap(dispatch(backupPhoto(sharedProfile.id, filename)));\n\n          case 38:\n            _context.next = 40;\n            return _regeneratorRuntime.awrap(dispatch(backupUser()));\n\n          case 40:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"names":["channel_types","selectChannelById","addConnection","addOperation","saveImage","backupPhoto","backupUser","confirmPendingConnection","pendingConnection_states","selectPendingConnectionById","updatePendingConnection","leaveChannel","encryptAndUploadProfileToChannel","connection_levels","confirmPendingConnectionThunk","id","level","api","reportReason","dispatch","getState","connection","state","UNCONFIRMED","console","log","pendingConnectionData","profileInfo","sharedProfile","changes","CONFIRMING","channel","channelId","user","brightId","backupCompleted","connectionTimestamp","profileTimestamp","requestProof","op","__DEV__","secretKey","imageName","base64Image","photo","filename","connectionData","name","connectionDate","status","notificationToken","socialMedia","verifications","profileId","reported","Array","SUSPICIOUS","REPORTED","includes","initiatorProfileId","type","GROUP","SINGLE","STAR","myProfileId"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/actions/pendingConnectionThunks.ts"],"sourcesContent":["import {\n  channel_types,\n  selectChannelById,\n} from '@/components/PendingConnections/channelSlice';\nimport { addConnection, addOperation } from '@/actions';\nimport { saveImage } from '@/utils/filesystem';\nimport {\n  backupPhoto,\n  backupUser,\n} from '@/components/Onboarding/RecoveryFlow/thunks/backupThunks';\nimport {\n  confirmPendingConnection,\n  pendingConnection_states,\n  selectPendingConnectionById,\n  updatePendingConnection,\n} from '@/components/PendingConnections/pendingConnectionSlice';\nimport {\n  leaveChannel,\n  encryptAndUploadProfileToChannel,\n} from '@/components/PendingConnections/actions/channelThunks';\nimport { NodeApi } from '@/api/brightId';\nimport { connection_levels } from '@/utils/constants';\n\nexport const confirmPendingConnectionThunk =\n  (\n    id: string,\n    level: ConnectionLevel,\n    api: NodeApi,\n    reportReason?: ReportReason,\n  ) =>\n  async (dispatch: dispatch, getState: getState) => {\n    const connection: PendingConnection = selectPendingConnectionById(\n      getState(),\n      id,\n    );\n    // validate pendingConnection state\n    if (connection.state !== pendingConnection_states.UNCONFIRMED) {\n      console.log(`Can't confirm - Connection is in state ${connection.state}`);\n      return;\n    }\n\n    const {\n      pendingConnectionData: { profileInfo, sharedProfile },\n    } = connection;\n\n    dispatch(\n      updatePendingConnection({\n        id,\n        changes: {\n          state: pendingConnection_states.CONFIRMING,\n        },\n      }),\n    );\n\n    const channel = selectChannelById(getState(), connection.channelId);\n    console.log(\n      `confirming connection ${id} in channel ${channel.id} with level '${level}'`,\n    );\n\n    const {\n      user: { id: brightId, backupCompleted },\n    } = getState();\n\n    const connectionTimestamp = sharedProfile.profileTimestamp;\n    const op = await api.addConnection(\n      brightId,\n      sharedProfile.id,\n      level,\n      connectionTimestamp,\n      reportReason,\n      sharedProfile.requestProof,\n    );\n    dispatch(addOperation(op));\n\n    if (__DEV__) {\n      // if peer is a fake connection also submit opposite addConnection operation\n      if (sharedProfile.secretKey) {\n        const op = await api.addConnection(\n          sharedProfile.id,\n          brightId,\n          level,\n          connectionTimestamp,\n          reportReason,\n          sharedProfile.requestProof,\n          {\n            id: sharedProfile.id,\n            secretKey: sharedProfile.secretKey,\n          },\n        );\n        dispatch(addOperation(op));\n      }\n    }\n\n    // save connection photo\n    const filename = await saveImage({\n      imageName: sharedProfile.id,\n      base64Image: sharedProfile.photo,\n    });\n\n    // create established connection from pendingConnection\n    const connectionData: LocalConnectionData = {\n      id: sharedProfile.id,\n      name: sharedProfile.name,\n      connectionDate: connectionTimestamp,\n      photo: { filename },\n      status: 'initiated',\n      notificationToken: sharedProfile.notificationToken,\n      secretKey: sharedProfile.secretKey,\n      level,\n      reportReason,\n      socialMedia: sharedProfile.socialMedia,\n      verifications: profileInfo?.verifications || [],\n    };\n\n    dispatch(addConnection(connectionData));\n    dispatch(confirmPendingConnection(connection.profileId));\n\n    const reported = Array<ConnectionLevel>(\n      connection_levels.SUSPICIOUS,\n      connection_levels.REPORTED,\n    ).includes(level);\n\n    // check connection level with initiator to decide next steps\n    if (connection.profileId === channel.initiatorProfileId) {\n      if (!reported) {\n        // upload profile to channel only *after* accepting the connection with creator\n        // to prevent leaking my profile info to unwanted connections\n        await dispatch(encryptAndUploadProfileToChannel(channel.id));\n      } else if (channel.type === channel_types.GROUP) {\n        // immediately leave group connection channel if initiator got reported\n        console.log(\n          `Leaving group channel ${channel.id} cause I don't trust the initiator (level: '${level}')`,\n        );\n        dispatch(leaveChannel(channel.id));\n      }\n    }\n\n    // Leave channel if no additional connections are expected\n    if (\n      channel.type === channel_types.SINGLE ||\n      (channel.type === channel_types.STAR &&\n        channel.initiatorProfileId !== channel.myProfileId)\n    ) {\n      dispatch(leaveChannel(channel.id));\n    }\n\n    if (backupCompleted) {\n      await dispatch(backupPhoto(sharedProfile.id, filename));\n      await dispatch(backupUser());\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}