{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsubscribeFromConnectionRequests = exports.subscribeToConnectionRequests = exports.leaveChannel = exports.leaveAllChannels = exports.joinChannel = exports.fetchChannelProfiles = exports.encryptAndUploadProfileToChannel = exports.createChannel = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _tweetnacl = _interopRequireDefault(require(\"tweetnacl\"));\n\nvar _channelSlice = require(\"../channelSlice\");\n\nvar _socialMediaSlice = require(\"../../../reducer/socialMediaSlice\");\n\nvar _filesystem = require(\"../../../utils/filesystem\");\n\nvar _cryptoHelper = require(\"../../../utils/cryptoHelper\");\n\nvar _channels = require(\"../../../utils/channels\");\n\nvar _constants = require(\"../../../utils/constants\");\n\nvar _pendingConnectionSlice = require(\"../pendingConnectionSlice\");\n\nvar _settingsSlice = require(\"../../../reducer/settingsSlice\");\n\nvar _encoding = require(\"../../../utils/encoding\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar createChannel = function createChannel(channelType, api) {\n  return function _callee(dispatch, getState) {\n    var channel, baseUrl, url, channelInfo;\n    return _regenerator.default.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            baseUrl = (0, _settingsSlice.selectBaseUrl)(getState());\n            url = new URL(baseUrl + \"/profile\");\n            _context.next = 5;\n            return _regenerator.default.awrap((0, _channels.generateChannelData)(channelType, url));\n\n          case 5:\n            channel = _context.sent;\n            channel.timeoutId = setTimeout(function () {\n              console.log(\"timer expired for channel \" + channel.id);\n              dispatch(leaveChannel(channel.id));\n            }, channel.ttl);\n            dispatch((0, _channelSlice.addChannel)(channel));\n            dispatch((0, _channelSlice.setMyChannel)({\n              channelId: channel.id,\n              channelType: channel.type\n            }));\n            channelInfo = (0, _channels.createChannelInfo)(channel);\n            _context.next = 12;\n            return _regenerator.default.awrap(channel.api.upload({\n              channelId: channel.id,\n              data: channelInfo,\n              dataId: _constants.CHANNEL_INFO_NAME,\n              requestedTtl: channel.ttl\n            }));\n\n          case 12:\n            _context.next = 14;\n            return _regenerator.default.awrap(dispatch(encryptAndUploadProfileToChannel(channel.id)));\n\n          case 14:\n            dispatch(subscribeToConnectionRequests(channel.id, api));\n            _context.next = 22;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](0);\n\n            if (channel && channel.id) {\n              dispatch(leaveChannel(channel.id));\n            }\n\n            console.log(\"Error while creating channel: \" + _context.t0);\n            throw _context.t0;\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 17]], Promise);\n  };\n};\n\nexports.createChannel = createChannel;\n\nvar joinChannel = function joinChannel(channel, api) {\n  return function _callee2(dispatch, getState) {\n    var channelIds, ttl_remain, entries, channelInfoIndex;\n    return _regenerator.default.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            console.log(\"Joining channel \" + channel.id + \" at \" + channel.url.href);\n            channelIds = (0, _channelSlice.selectAllChannelIds)(getState());\n\n            if (!channelIds.includes(channel.id)) {\n              _context2.next = 5;\n              break;\n            }\n\n            console.log(\"Channel \" + channel.id + \" already joined\");\n            return _context2.abrupt(\"return\");\n\n          case 5:\n            ttl_remain = channel.timestamp + channel.ttl - Date.now();\n            _context2.prev = 6;\n\n            if (!(ttl_remain < _constants.MIN_CHANNEL_JOIN_TTL)) {\n              _context2.next = 10;\n              break;\n            }\n\n            console.log(\"Remaining ttl \" + ttl_remain + \" of channel \" + channel.id + \" too low. Aborting join.\");\n            throw new Error('Channel expired');\n\n          case 10:\n            _context2.next = 12;\n            return _regenerator.default.awrap(channel.api.list(channel.id));\n\n          case 12:\n            entries = _context2.sent;\n            channelInfoIndex = entries.indexOf(_constants.CHANNEL_INFO_NAME);\n\n            if (channelInfoIndex > -1) {\n              entries.splice(channelInfoIndex, 1);\n            }\n\n            if (!(entries.length >= _constants.CHANNEL_CONNECTION_LIMIT)) {\n              _context2.next = 17;\n              break;\n            }\n\n            throw new Error(\"Channel is full\");\n\n          case 17:\n            channel.timeoutId = setTimeout(function () {\n              console.log(\"timer expired for channel \" + channel.id);\n              dispatch(leaveChannel(channel.id));\n            }, ttl_remain);\n            dispatch((0, _channelSlice.addChannel)(channel));\n            dispatch(subscribeToConnectionRequests(channel.id, api));\n            _context2.next = 26;\n            break;\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](6);\n            dispatch(leaveChannel(channel.id));\n            throw _context2.t0;\n\n          case 26:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[6, 22]], Promise);\n  };\n};\n\nexports.joinChannel = joinChannel;\n\nvar leaveChannel = function leaveChannel(channelId) {\n  return function (dispatch, getState) {\n    var channel = (0, _channelSlice.selectChannelById)(getState(), channelId);\n\n    if (channel) {\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channelId));\n      dispatch((0, _channelSlice.removeChannel)(channelId));\n    }\n  };\n};\n\nexports.leaveChannel = leaveChannel;\n\nvar leaveAllChannels = function leaveAllChannels() {\n  return function (dispatch, getState) {\n    var channels = (0, _channelSlice.selectAllChannels)(getState());\n\n    for (var _iterator = _createForOfIteratorHelperLoose(channels), _step; !(_step = _iterator()).done;) {\n      var channel = _step.value;\n      console.log(\"Leaving channel \" + channel.id);\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n      dispatch((0, _channelSlice.removeChannel)(channel.id));\n    }\n  };\n};\n\nexports.leaveAllChannels = leaveAllChannels;\n\nvar subscribeToConnectionRequests = function subscribeToConnectionRequests(channelId, api) {\n  return function (dispatch, getState) {\n    var _selectChannelById = (0, _channelSlice.selectChannelById)(getState(), channelId),\n        pollTimerId = _selectChannelById.pollTimerId;\n\n    if (pollTimerId) {\n      console.log(\"Stopping previous timer \" + pollTimerId + \" for channel \" + channelId);\n      clearInterval(pollTimerId);\n    }\n\n    pollTimerId = setInterval(function () {\n      dispatch(fetchChannelProfiles(channelId, api));\n    }, _constants.PROFILE_POLL_INTERVAL);\n    console.log(\"Start polling channel \" + channelId + \", pollTImerId \" + pollTimerId);\n    dispatch((0, _channelSlice.updateChannel)({\n      id: channelId,\n      changes: {\n        pollTimerId: pollTimerId\n      }\n    }));\n  };\n};\n\nexports.subscribeToConnectionRequests = subscribeToConnectionRequests;\n\nvar unsubscribeFromConnectionRequests = function unsubscribeFromConnectionRequests(channelId) {\n  return function (dispatch, getState) {\n    var _selectChannelById2 = (0, _channelSlice.selectChannelById)(getState(), channelId),\n        pollTimerId = _selectChannelById2.pollTimerId;\n\n    if (pollTimerId) {\n      console.log(\"Stop polling channel \" + channelId + \" (timer \" + pollTimerId + \")\");\n      clearInterval(pollTimerId);\n      dispatch((0, _channelSlice.updateChannel)({\n        id: channelId,\n        changes: {\n          pollTimerId: null\n        }\n      }));\n    }\n  };\n};\n\nexports.unsubscribeFromConnectionRequests = unsubscribeFromConnectionRequests;\n\nvar fetchChannelProfiles = function fetchChannelProfiles(channelId, api) {\n  return function _callee3(dispatch, getState) {\n    var channel, profileIds, channelInfoIndex, knownProfileIds, stopPolling, _iterator2, _step2, profileId, foundInitiator, _iterator3, _step3, _profileId, _iterator4, _step4, _profileId2;\n\n    return _regenerator.default.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            channel = (0, _channelSlice.selectChannelById)(getState(), channelId);\n            _context3.next = 3;\n            return _regenerator.default.awrap(channel.api.list(channelId));\n\n          case 3:\n            profileIds = _context3.sent;\n            channelInfoIndex = profileIds.indexOf(_constants.CHANNEL_INFO_NAME);\n\n            if (channelInfoIndex > -1) {\n              profileIds.splice(channelInfoIndex, 1);\n            }\n\n            profileIds = profileIds.slice(0, _constants.CHANNEL_CONNECTION_LIMIT);\n            knownProfileIds = (0, _pendingConnectionSlice.selectAllPendingConnectionIds)(getState());\n\n            if (__DEV__ && profileIds.length > knownProfileIds.length + 1) {\n              console.log(\"Got \" + profileIds.length + \" profileIds:\", profileIds);\n            }\n\n            stopPolling = false;\n            _context3.t0 = channel.type;\n            _context3.next = _context3.t0 === _channelSlice.channel_types.STAR ? 13 : _context3.t0 === _channelSlice.channel_types.GROUP ? 33 : _context3.t0 === _channelSlice.channel_types.SINGLE ? 43 : 53;\n            break;\n\n          case 13:\n            if (!(channel.initiatorProfileId === channel.myProfileId)) {\n              _context3.next = 25;\n              break;\n            }\n\n            _iterator2 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 15:\n            if ((_step2 = _iterator2()).done) {\n              _context3.next = 22;\n              break;\n            }\n\n            profileId = _step2.value;\n\n            if (!(profileId !== channel.myProfileId && !knownProfileIds.includes(profileId))) {\n              _context3.next = 20;\n              break;\n            }\n\n            _context3.next = 20;\n            return _regenerator.default.awrap(dispatch((0, _pendingConnectionSlice.newPendingConnection)({\n              channelId: channelId,\n              profileId: profileId,\n              api: api\n            })));\n\n          case 20:\n            _context3.next = 15;\n            break;\n\n          case 22:\n            stopPolling = profileIds.length >= _constants.CHANNEL_CONNECTION_LIMIT;\n            _context3.next = 32;\n            break;\n\n          case 25:\n            console.log(\"STAR channel - Participant waiting for initiator profile\");\n            foundInitiator = profileIds.includes(channel.initiatorProfileId);\n\n            if (!(foundInitiator && !knownProfileIds.includes(channel.initiatorProfileId))) {\n              _context3.next = 31;\n              break;\n            }\n\n            console.log(\"STAR channel - Participant found initiator profileID \" + channel.initiatorProfileId);\n            _context3.next = 31;\n            return _regenerator.default.awrap(dispatch((0, _pendingConnectionSlice.newPendingConnection)({\n              channelId: channelId,\n              profileId: channel.initiatorProfileId,\n              api: api\n            })));\n\n          case 31:\n            stopPolling = foundInitiator;\n\n          case 32:\n            return _context3.abrupt(\"break\", 53);\n\n          case 33:\n            _iterator3 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 34:\n            if ((_step3 = _iterator3()).done) {\n              _context3.next = 41;\n              break;\n            }\n\n            _profileId = _step3.value;\n\n            if (!(_profileId !== channel.myProfileId && !knownProfileIds.includes(_profileId))) {\n              _context3.next = 39;\n              break;\n            }\n\n            _context3.next = 39;\n            return _regenerator.default.awrap(dispatch((0, _pendingConnectionSlice.newPendingConnection)({\n              channelId: channelId,\n              profileId: _profileId,\n              api: api\n            })));\n\n          case 39:\n            _context3.next = 34;\n            break;\n\n          case 41:\n            stopPolling = profileIds.length >= _constants.CHANNEL_CONNECTION_LIMIT;\n            return _context3.abrupt(\"break\", 53);\n\n          case 43:\n            _iterator4 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 44:\n            if ((_step4 = _iterator4()).done) {\n              _context3.next = 51;\n              break;\n            }\n\n            _profileId2 = _step4.value;\n\n            if (!(_profileId2 !== channel.myProfileId && !knownProfileIds.includes(_profileId2))) {\n              _context3.next = 49;\n              break;\n            }\n\n            _context3.next = 49;\n            return _regenerator.default.awrap(dispatch((0, _pendingConnectionSlice.newPendingConnection)({\n              channelId: channelId,\n              profileId: _profileId2,\n              api: api\n            })));\n\n          case 49:\n            _context3.next = 44;\n            break;\n\n          case 51:\n            stopPolling = profileIds.length >= 2;\n            return _context3.abrupt(\"break\", 53);\n\n          case 53:\n            if (stopPolling) {\n              console.log(\"Got expected profiles for channel \" + channel.id + \". Unsubscribing.\");\n              dispatch(unsubscribeFromConnectionRequests(channel.id));\n            }\n\n          case 54:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nexports.fetchChannelProfiles = fetchChannelProfiles;\n\nvar encryptAndUploadProfileToChannel = function encryptAndUploadProfileToChannel(channelId) {\n  return function _callee4(dispatch, getState) {\n    var channel, _getState$user, id, filename, name, notificationToken, socialMedia, photo, profileTimestamp, dataObj, message, secretKey, encrypted;\n\n    return _regenerator.default.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            channel = (0, _channelSlice.selectChannelById)(getState(), channelId);\n            _getState$user = getState().user, id = _getState$user.id, filename = _getState$user.photo.filename, name = _getState$user.name;\n            notificationToken = getState().notifications.notificationToken;\n            socialMedia = (0, _socialMediaSlice.selectAllSocialMediaToShare)(getState());\n            _context4.next = 6;\n            return _regenerator.default.awrap((0, _filesystem.retrieveImage)(filename));\n\n          case 6:\n            photo = _context4.sent;\n            profileTimestamp = Date.now();\n            dataObj = {\n              id: id,\n              photo: photo,\n              name: name,\n              socialMedia: socialMedia,\n              profileTimestamp: profileTimestamp,\n              notificationToken: notificationToken,\n              version: _constants.PROFILE_VERSION\n            };\n\n            if (channel.initiatorProfileId === channel.myProfileId) {\n              message = id + \"|\" + profileTimestamp;\n              secretKey = getState().keypair.secretKey;\n              dataObj.requestProof = (0, _encoding.uInt8ArrayToB64)(_tweetnacl.default.sign.detached((0, _encoding.strToUint8Array)(message), secretKey));\n            }\n\n            console.log(\"Encrypting profile data with key \" + channel.aesKey);\n            encrypted = (0, _cryptoHelper.encryptData)(dataObj, channel.aesKey);\n            console.log(\"Posting profile data...\");\n            _context4.next = 15;\n            return _regenerator.default.awrap(channel.api.upload({\n              channelId: channelId,\n              data: encrypted,\n              dataId: channel.myProfileId\n            }));\n\n          case 15:\n            dispatch((0, _channelSlice.updateChannel)({\n              id: channelId,\n              changes: {\n                myProfileTimestamp: profileTimestamp\n              }\n            }));\n\n          case 16:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nexports.encryptAndUploadProfileToChannel = encryptAndUploadProfileToChannel;","map":{"version":3,"names":["createChannel","channelType","api","dispatch","getState","baseUrl","selectBaseUrl","url","URL","generateChannelData","channel","timeoutId","setTimeout","console","log","id","leaveChannel","ttl","addChannel","setMyChannel","channelId","type","channelInfo","createChannelInfo","upload","data","dataId","CHANNEL_INFO_NAME","requestedTtl","encryptAndUploadProfileToChannel","subscribeToConnectionRequests","joinChannel","href","channelIds","selectAllChannelIds","includes","ttl_remain","timestamp","Date","now","MIN_CHANNEL_JOIN_TTL","Error","list","entries","channelInfoIndex","indexOf","splice","length","CHANNEL_CONNECTION_LIMIT","selectChannelById","clearTimeout","unsubscribeFromConnectionRequests","removeChannel","leaveAllChannels","channels","selectAllChannels","pollTimerId","clearInterval","setInterval","fetchChannelProfiles","PROFILE_POLL_INTERVAL","updateChannel","changes","profileIds","slice","knownProfileIds","selectAllPendingConnectionIds","__DEV__","stopPolling","channel_types","STAR","GROUP","SINGLE","initiatorProfileId","myProfileId","profileId","newPendingConnection","foundInitiator","user","filename","photo","name","notificationToken","notifications","socialMedia","selectAllSocialMediaToShare","retrieveImage","profileTimestamp","dataObj","version","PROFILE_VERSION","message","secretKey","keypair","requestProof","uInt8ArrayToB64","nacl","sign","detached","strToUint8Array","aesKey","encrypted","encryptData","myProfileTimestamp"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/actions/channelThunks.ts"],"sourcesContent":["import nacl from 'tweetnacl';\nimport {\n  addChannel,\n  selectChannelById,\n  removeChannel,\n  setMyChannel,\n  updateChannel,\n  selectAllChannelIds,\n  channel_types,\n  selectAllChannels,\n} from '@/components/PendingConnections/channelSlice';\nimport { selectAllSocialMediaToShare } from '@/reducer/socialMediaSlice';\nimport { retrieveImage } from '@/utils/filesystem';\nimport { encryptData } from '@/utils/cryptoHelper';\nimport { generateChannelData, createChannelInfo } from '@/utils/channels';\nimport {\n  CHANNEL_CONNECTION_LIMIT,\n  MIN_CHANNEL_JOIN_TTL,\n  PROFILE_POLL_INTERVAL,\n  PROFILE_VERSION,\n  CHANNEL_INFO_NAME,\n} from '@/utils/constants';\nimport {\n  newPendingConnection,\n  selectAllPendingConnectionIds,\n} from '@/components/PendingConnections/pendingConnectionSlice';\nimport { selectBaseUrl } from '@/reducer/settingsSlice';\nimport { NodeApi } from '@/api/brightId';\nimport { strToUint8Array, uInt8ArrayToB64 } from '@/utils/encoding';\n\nexport const createChannel =\n  (channelType: ChannelType, api: NodeApi) =>\n  async (dispatch: dispatch, getState: getState) => {\n    let channel: Channel | null | undefined;\n    try {\n      const baseUrl = selectBaseUrl(getState());\n      const url = new URL(`${baseUrl}/profile`);\n      // use this for local running profile service\n      // const url = new URL(`http://10.0.2.2:3000/`);\n      channel = await generateChannelData(channelType, url);\n\n      // Set timeout to expire channel\n      channel.timeoutId = setTimeout(() => {\n        console.log(`timer expired for channel ${channel.id}`);\n        dispatch(leaveChannel(channel.id));\n      }, channel.ttl);\n      dispatch(addChannel(channel));\n      dispatch(\n        setMyChannel({ channelId: channel.id, channelType: channel.type }),\n      );\n\n      // upload channel info\n      const channelInfo: ChannelInfo = createChannelInfo(channel);\n      await channel.api.upload({\n        channelId: channel.id,\n        data: channelInfo,\n        dataId: CHANNEL_INFO_NAME,\n        requestedTtl: channel.ttl,\n      });\n\n      // upload my profile\n      await dispatch(encryptAndUploadProfileToChannel(channel.id));\n      // start polling for profiles\n      dispatch(subscribeToConnectionRequests(channel.id, api));\n    } catch (e) {\n      // Something went wrong while creating channel.\n      if (channel && channel.id) {\n        dispatch(leaveChannel(channel.id));\n      }\n      console.log(`Error while creating channel: ${e}`);\n      // need to throw to prevent app from looping\n      throw e;\n    }\n  };\n\nexport const joinChannel =\n  (channel: Channel, api: NodeApi) =>\n  async (dispatch: dispatch, getState: getState) => {\n    console.log(`Joining channel ${channel.id} at ${channel.url.href}`);\n    // check to see if channel exists\n    const channelIds = selectAllChannelIds(getState());\n    if (channelIds.includes(channel.id)) {\n      console.log(`Channel ${channel.id} already joined`);\n      return;\n    }\n\n    // calc remaining lifetime of channel\n    const ttl_remain = channel.timestamp + channel.ttl - Date.now();\n\n    try {\n      // don't join channel if it is/is about to expired\n      if (ttl_remain < MIN_CHANNEL_JOIN_TTL) {\n        console.log(\n          `Remaining ttl ${ttl_remain} of channel ${channel.id} too low. Aborting join.`,\n        );\n        throw new Error('Channel expired');\n      }\n\n      // don't join channel if it already has maximum allowed number of entries.\n      // Note that this is a client-side limitation in order to keep the UI usable.\n      const entries = await channel.api.list(channel.id);\n      // channel.api.list() will include the channelInfo.json file.\n      // Remove it from list as I don't want to download and interpret it as a profile.\n      const channelInfoIndex = entries.indexOf(CHANNEL_INFO_NAME);\n      if (channelInfoIndex > -1) {\n        entries.splice(channelInfoIndex, 1);\n      }\n      if (entries.length >= CHANNEL_CONNECTION_LIMIT) {\n        throw new Error(`Channel is full`);\n      }\n\n      // Start timer to expire channel\n      channel.timeoutId = setTimeout(() => {\n        console.log(`timer expired for channel ${channel.id}`);\n        dispatch(leaveChannel(channel.id));\n      }, ttl_remain);\n\n      // add channel to store\n      // we need channel to exist prior to uploadingProfileToChannel\n      dispatch(addChannel(channel));\n\n      // start polling for profiles\n      dispatch(subscribeToConnectionRequests(channel.id, api));\n    } catch (e) {\n      // Something went wrong while trying to join channel.\n      dispatch(leaveChannel(channel.id));\n      throw e;\n    }\n  };\n\nexport const leaveChannel =\n  (channelId: string) => (dispatch: dispatch, getState: getState) => {\n    const channel: Channel = selectChannelById(getState(), channelId);\n    if (channel) {\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channelId));\n      dispatch(removeChannel(channelId));\n    }\n  };\n\nexport const leaveAllChannels =\n  () => (dispatch: dispatch, getState: getState) => {\n    const channels = selectAllChannels(getState());\n    for (const channel of channels) {\n      console.log(`Leaving channel ${channel.id}`);\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n      dispatch(removeChannel(channel.id));\n    }\n  };\n\nexport const subscribeToConnectionRequests =\n  (channelId: string, api: NodeApi) =>\n  (dispatch: dispatch, getState: getState) => {\n    let { pollTimerId } = selectChannelById(getState(), channelId);\n\n    if (pollTimerId) {\n      console.log(\n        `Stopping previous timer ${\n          pollTimerId as any\n        } for channel ${channelId}`,\n      );\n      clearInterval(pollTimerId);\n    }\n\n    pollTimerId = setInterval(() => {\n      // fetch all profileIDs in channel\n      dispatch(fetchChannelProfiles(channelId, api));\n    }, PROFILE_POLL_INTERVAL);\n\n    console.log(\n      `Start polling channel ${channelId}, pollTImerId ${pollTimerId}`,\n    );\n\n    dispatch(\n      updateChannel({\n        id: channelId,\n        changes: {\n          pollTimerId,\n        },\n      }),\n    );\n  };\n\nexport const unsubscribeFromConnectionRequests =\n  (channelId: string) => (dispatch: dispatch, getState: getState) => {\n    const { pollTimerId } = selectChannelById(getState(), channelId);\n\n    if (pollTimerId) {\n      console.log(`Stop polling channel ${channelId} (timer ${pollTimerId})`);\n      clearInterval(pollTimerId);\n      dispatch(\n        updateChannel({\n          id: channelId,\n          changes: {\n            pollTimerId: null,\n          },\n        }),\n      );\n    }\n  };\n\nexport const fetchChannelProfiles =\n  (channelId: string, api: NodeApi) =>\n  async (dispatch: Dispatch, getState: GetState) => {\n    const channel = selectChannelById(getState(), channelId);\n    let profileIds = await channel.api.list(channelId);\n\n    // channel.api.list() will include the channelInfo.json file.\n    // Remove it from list as I don't want to download and interpret it as a profile.\n    const channelInfoIndex = profileIds.indexOf(CHANNEL_INFO_NAME);\n    if (channelInfoIndex > -1) {\n      profileIds.splice(channelInfoIndex, 1);\n    }\n\n    // Only get up to CHANNEL_CONNECTION_LIMIT profiles\n    profileIds = profileIds.slice(0, CHANNEL_CONNECTION_LIMIT);\n    const knownProfileIds = selectAllPendingConnectionIds(getState());\n    if (__DEV__ && profileIds.length > knownProfileIds.length + 1) {\n      console.log(`Got ${profileIds.length} profileIds:`, profileIds);\n    }\n\n    /*\n  Polling logic:\n  type STAR:\n   - Channel creator: Load all profiles\n   - Other participant: Only load creator profile\n  type GROUP:\n   - everybody load all profiles\n  type SINGLE:\n   - Channel creator: Load participant profile\n   - Other participant: Load creator profile\n */\n    let stopPolling = false;\n    switch (channel.type) {\n      case channel_types.STAR:\n        if (channel.initiatorProfileId === channel.myProfileId) {\n          // Channel creator: Load all profiles\n          for (const profileId of profileIds) {\n            if (\n              profileId !== channel.myProfileId &&\n              !knownProfileIds.includes(profileId)\n            ) {\n              await dispatch(\n                newPendingConnection({\n                  channelId,\n                  profileId,\n                  api,\n                }),\n              );\n            }\n          }\n          // stop polling when channel limit is reached\n          stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n        } else {\n          // other participant: Only load initiator profile\n          console.log(\n            `STAR channel - Participant waiting for initiator profile`,\n          );\n          const foundInitiator = profileIds.includes(\n            channel.initiatorProfileId,\n          );\n          if (\n            foundInitiator &&\n            !knownProfileIds.includes(channel.initiatorProfileId)\n          ) {\n            console.log(\n              `STAR channel - Participant found initiator profileID ${channel.initiatorProfileId}`,\n            );\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId: channel.initiatorProfileId,\n                api,\n              }),\n            );\n          }\n          // stop polling when initiator profile is found\n          stopPolling = foundInitiator;\n        }\n        break;\n      case channel_types.GROUP:\n        // Always load all profiles\n        for (const profileId of profileIds) {\n          if (\n            profileId !== channel.myProfileId &&\n            !knownProfileIds.includes(profileId)\n          ) {\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId,\n                api,\n              }),\n            );\n          }\n        }\n        // stop polling only when channel limit is reached\n        stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n        break;\n      case channel_types.SINGLE:\n        // there should be only 2 profiles in the channel. Just load all.\n        for (const profileId of profileIds) {\n          if (\n            profileId !== channel.myProfileId &&\n            !knownProfileIds.includes(profileId)\n          ) {\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId,\n                api,\n              }),\n            );\n          }\n        }\n        // stop polling when 2 profiles are found (own profile and peer profile)\n        stopPolling = profileIds.length >= 2;\n        break;\n    }\n\n    if (stopPolling) {\n      console.log(\n        `Got expected profiles for channel ${channel.id}. Unsubscribing.`,\n      );\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n    }\n  };\n\nexport const encryptAndUploadProfileToChannel =\n  (channelId: string) => async (dispatch: Dispatch, getState: GetState) => {\n    // get channel\n    const channel = selectChannelById(getState(), channelId);\n    // get user data\n    const {\n      id,\n      photo: { filename },\n      name,\n    } = getState().user;\n\n    const { notificationToken } = getState().notifications;\n\n    const socialMedia = selectAllSocialMediaToShare(getState());\n\n    // retrieve photo\n    const photo = await retrieveImage(filename);\n    const profileTimestamp = Date.now();\n\n    const dataObj: SharedProfile = {\n      id,\n      photo,\n      name,\n      socialMedia,\n      profileTimestamp,\n      notificationToken,\n      version: PROFILE_VERSION,\n    };\n\n    if (channel.initiatorProfileId === channel.myProfileId) {\n      // create request proof that proves the user requested\n      // the connection by creating the qr code\n      const message = `${id}|${profileTimestamp}`;\n      const { secretKey } = getState().keypair;\n      dataObj.requestProof = uInt8ArrayToB64(\n        nacl.sign.detached(strToUint8Array(message), secretKey),\n      );\n    }\n\n    console.log(`Encrypting profile data with key ${channel.aesKey}`);\n    const encrypted = encryptData(dataObj, channel.aesKey);\n    console.log(`Posting profile data...`);\n    await channel.api.upload({\n      channelId,\n      data: encrypted,\n      dataId: channel.myProfileId,\n    });\n    dispatch(\n      updateChannel({\n        id: channelId,\n        changes: {\n          myProfileTimestamp: profileTimestamp,\n        },\n      }),\n    );\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}