{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _myChannelIds;\n\nimport { createSelector, createSlice, createEntityAdapter } from '@reduxjs/toolkit';\nexport var channel_types;\n\n(function (channel_types) {\n  channel_types[\"GROUP\"] = \"GROUP\";\n  channel_types[\"SINGLE\"] = \"SINGLE\";\n  channel_types[\"STAR\"] = \"STAR\";\n})(channel_types || (channel_types = {}));\n\nexport var channel_states;\n\n(function (channel_states) {\n  channel_states[\"OPEN\"] = \"OPEN\";\n  channel_states[\"CLOSED\"] = \"CLOSED\";\n  channel_states[\"BACKGROUND\"] = \"BACKGROUND\";\n})(channel_states || (channel_states = {}));\n\nexport var channelsAdapter = createEntityAdapter();\nvar initialState = channelsAdapter.getInitialState({\n  displayChannelType: channel_types.SINGLE,\n  myChannelIds: (_myChannelIds = {}, _defineProperty(_myChannelIds, channel_types.SINGLE, ''), _defineProperty(_myChannelIds, channel_types.GROUP, ''), _defineProperty(_myChannelIds, channel_types.STAR, ''), _myChannelIds)\n});\nvar channelSlice = createSlice({\n  name: 'channels',\n  initialState: initialState,\n  reducers: {\n    addChannel: function addChannel(state, action) {\n      state = channelsAdapter.addOne(state, action);\n    },\n    updateChannel: function updateChannel(state, action) {\n      state = channelsAdapter.updateOne(state, action);\n    },\n    closeChannel: function closeChannel(state, action) {\n      var _action$payload = action.payload,\n          channelId = _action$payload.channelId,\n          background = _action$payload.background;\n      state = channelsAdapter.updateOne(state, {\n        id: channelId,\n        changes: {\n          state: background ? channel_states.BACKGROUND : channel_states.CLOSED\n        }\n      });\n      if (state.myChannelIds[channel_types.SINGLE] === channelId) state.myChannelIds[channel_types.SINGLE] = '';\n      if (state.myChannelIds[channel_types.GROUP] === channelId) state.myChannelIds[channel_types.GROUP] = '';\n      if (state.myChannelIds[channel_types.STAR] === channelId) state.myChannelIds[channel_types.STAR] = '';\n    },\n    removeChannel: function removeChannel(state, action) {\n      var channelId = action.payload;\n      state = channelsAdapter.removeOne(state, channelId);\n      if (state.myChannelIds[channel_types.SINGLE] === channelId) state.myChannelIds[channel_types.SINGLE] === '';\n      if (state.myChannelIds[channel_types.GROUP] === channelId) state.myChannelIds[channel_types.GROUP] === '';\n      if (state.myChannelIds[channel_types.STAR] === channelId) state.myChannelIds[channel_types.STAR] = '';\n    },\n    setMyChannel: function setMyChannel(state, action) {\n      var _action$payload2 = action.payload,\n          channelType = _action$payload2.channelType,\n          channelId = _action$payload2.channelId;\n      state.myChannelIds[channelType] = channelId;\n    },\n    setDisplayChannelType: function setDisplayChannelType(state, action) {\n      var channelType = action.payload;\n      state.displayChannelType = channelType;\n    }\n  }\n});\nvar _channelSlice$actions = channelSlice.actions,\n    addChannel = _channelSlice$actions.addChannel,\n    updateChannel = _channelSlice$actions.updateChannel,\n    removeChannel = _channelSlice$actions.removeChannel,\n    setMyChannel = _channelSlice$actions.setMyChannel,\n    closeChannel = _channelSlice$actions.closeChannel,\n    setDisplayChannelType = _channelSlice$actions.setDisplayChannelType;\nexport { addChannel, updateChannel, removeChannel, setMyChannel, closeChannel, setDisplayChannelType };\n\nvar _channelsAdapter$getS = channelsAdapter.getSelectors(function (state) {\n  return state.channels;\n}),\n    selectChannelById = _channelsAdapter$getS.selectById,\n    selectAllChannels = _channelsAdapter$getS.selectAll,\n    selectAllChannelIds = _channelsAdapter$getS.selectIds;\n\nexport { selectChannelById, selectAllChannels, selectAllChannelIds };\nexport var selectAllActiveChannelIds = createSelector(selectAllChannels, function (_, type) {\n  return type;\n}, function (channels, type) {\n  return channels.filter(function (pc) {\n    return pc.type === type;\n  }).map(function (pc) {\n    return pc.id;\n  });\n});\nexport var selectAllActiveChannelIdsByType = createSelector(selectAllChannels, function (_, type) {\n  return type;\n}, function (channels, type) {\n  return channels.filter(function (pc) {\n    return pc.type === type && (pc.state === channel_states.OPEN || pc.state === channel_states.BACKGROUND);\n  }).map(function (pc) {\n    return pc.id;\n  });\n});\nexport default channelSlice.reducer;","map":{"version":3,"names":["createSelector","createSlice","createEntityAdapter","channel_types","channel_states","channelsAdapter","initialState","getInitialState","displayChannelType","SINGLE","myChannelIds","GROUP","STAR","channelSlice","name","reducers","addChannel","state","action","addOne","updateChannel","updateOne","closeChannel","payload","channelId","background","id","changes","BACKGROUND","CLOSED","removeChannel","removeOne","setMyChannel","channelType","setDisplayChannelType","actions","getSelectors","channels","selectChannelById","selectById","selectAllChannels","selectAll","selectAllChannelIds","selectIds","selectAllActiveChannelIds","_","type","filter","pc","map","selectAllActiveChannelIdsByType","OPEN","reducer"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/channelSlice.ts"],"sourcesContent":["import {\n  createSelector,\n  createSlice,\n  createEntityAdapter,\n  PayloadAction,\n  Update,\n} from '@reduxjs/toolkit';\n\nimport { Draft } from 'immer';\n/*\n\n  What is a channel:\n  - 'aesKey': encryption key for data transported through channel\n  - 'api': instance of ChannelAPI for this channel\n  - 'id': unique identifier\n  - 'initiatorProfileId': profileId of channel initiator\n  - 'myProfileId': my profileId in this channel\n  - 'pollTimerId: IntervalId of timer polling for incoming connection requests from this channel\n  - 'state': state of channel - see channel_states below\n  - 'timestamp': timestamp of channel creation time\n  - 'ttl': time to live of channel (seconds)\n  - 'type': group or 1:1 connection - see channel_types below\n  - 'timeoutId: Id of timer to expire channel once ttl is reached\n  - 'url': url of channel\n\n  The app could hold multiple channels at the same time. E.g. if i scan multiple QRCodes\n  in a larger group session.\n\n */\n\nexport enum channel_types {\n  GROUP = 'GROUP',\n  SINGLE = 'SINGLE',\n  STAR = 'STAR',\n}\n\nexport enum channel_states {\n  OPEN = 'OPEN',\n  CLOSED = 'CLOSED',\n  BACKGROUND = 'BACKGROUND',\n}\n\nexport const channelsAdapter = createEntityAdapter<Channel>();\n\nconst initialState = channelsAdapter.getInitialState<DisplayChannel>({\n  displayChannelType: channel_types.SINGLE,\n  myChannelIds: {\n    [channel_types.SINGLE]: '',\n    [channel_types.GROUP]: '',\n    [channel_types.STAR]: '',\n  },\n});\n\nconst channelSlice = createSlice({\n  name: 'channels',\n  initialState,\n  reducers: {\n    addChannel(state: Draft<ChannelsState>, action: PayloadAction<Channel>) {\n      state = channelsAdapter.addOne<ChannelsState>(\n        state as ChannelsState,\n        action,\n      );\n    },\n    // addChannel: channelsAdapter.addOne,\n    updateChannel(\n      state: Draft<ChannelsState>,\n      action: PayloadAction<Update<Channel>>,\n    ) {\n      state = channelsAdapter.updateOne<ChannelsState>(\n        state as ChannelsState,\n        action,\n      );\n    },\n    closeChannel(\n      state: Draft<ChannelsState>,\n      action: PayloadAction<{ channelId: string; background: boolean }>,\n    ) {\n      const { channelId, background } = action.payload;\n      state = channelsAdapter.updateOne<ChannelsState>(state as ChannelsState, {\n        id: channelId,\n        changes: {\n          state: background ? channel_states.BACKGROUND : channel_states.CLOSED,\n        },\n      });\n      if (state.myChannelIds[channel_types.SINGLE] === channelId)\n        state.myChannelIds[channel_types.SINGLE] = '';\n\n      if (state.myChannelIds[channel_types.GROUP] === channelId)\n        state.myChannelIds[channel_types.GROUP] = '';\n\n      if (state.myChannelIds[channel_types.STAR] === channelId)\n        state.myChannelIds[channel_types.STAR] = '';\n    },\n    removeChannel(state: Draft<ChannelsState>, action: PayloadAction<string>) {\n      const channelId = action.payload;\n      state = channelsAdapter.removeOne<ChannelsState>(\n        state as ChannelsState,\n        channelId,\n      );\n      // In case my channel got removed also clear myChannelId\n      if (state.myChannelIds[channel_types.SINGLE] === channelId)\n        state.myChannelIds[channel_types.SINGLE] === '';\n\n      if (state.myChannelIds[channel_types.GROUP] === channelId)\n        state.myChannelIds[channel_types.GROUP] === '';\n\n      if (state.myChannelIds[channel_types.STAR] === channelId)\n        state.myChannelIds[channel_types.STAR] = '';\n    },\n    setMyChannel(\n      state: Draft<ChannelsState>,\n      action: PayloadAction<{ channelType: ChannelType; channelId: string }>,\n    ) {\n      const { channelType, channelId } = action.payload;\n      state.myChannelIds[channelType] = channelId;\n    },\n    setDisplayChannelType(\n      state: Draft<ChannelsState>,\n      action: PayloadAction<ChannelType>,\n    ) {\n      const channelType = action.payload;\n      state.displayChannelType = channelType;\n    },\n  },\n});\n\n// Export channel actions\nexport const {\n  addChannel,\n  updateChannel,\n  removeChannel,\n  setMyChannel,\n  closeChannel,\n  setDisplayChannelType,\n} = channelSlice.actions;\n\n// Export channel selectors\nexport const {\n  selectById: selectChannelById,\n  selectAll: selectAllChannels,\n  selectIds: selectAllChannelIds,\n} = channelsAdapter.getSelectors((state: State) => state.channels);\n\n// additional selectors\nexport const selectAllActiveChannelIds = createSelector(\n  selectAllChannels,\n  // check to see if this is state or channel state\n  (_: State, type: ChannelType) => type,\n  (channels, type) =>\n    channels.filter((pc) => pc.type === type).map((pc) => pc.id),\n);\n\nexport const selectAllActiveChannelIdsByType = createSelector(\n  selectAllChannels,\n  (_: State, type: ChannelType) => type,\n  (channels, type) =>\n    channels\n      .filter(\n        (pc) =>\n          pc.type === type &&\n          (pc.state === channel_states.OPEN ||\n            pc.state === channel_states.BACKGROUND),\n      )\n      .map((pc) => pc.id),\n);\n\n// Export reducer\nexport default channelSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}