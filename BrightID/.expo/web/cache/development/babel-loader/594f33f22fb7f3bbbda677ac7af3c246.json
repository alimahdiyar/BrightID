{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { b64ToUrlSafeB64 } from \"../../../../utils/encoding\";\nimport { saveImage } from \"../../../../utils/filesystem\";\nimport { addLinkedContext, upsertSig } from \"../../../../reducer/appsSlice\";\nimport { decryptData } from \"../../../../utils/cryptoHelper\";\nimport { setUploadCompletedBy, setRecoveryId } from \"../../RecoveryFlow/recoveryDataSlice\";\nimport { setPhoto, setName, setIsSponsored, setBackupCompleted, setPassword, setIsSponsoredv6 } from \"../../../../reducer/userSlice\";\nimport { IMPORT_PREFIX } from \"../../../../utils/constants\";\nexport var downloadContextInfo = function downloadContextInfo(_ref) {\n  var channelApi = _ref.channelApi,\n      dataIds = _ref.dataIds;\n  return function _callee(dispatch, getState) {\n    var _getState, _getState$recoveryDat, aesKey, channelId, isContextInfo, contextInfoDataIds, _iterator, _step, dataId, encrypted, contextInfo;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _getState = getState(), _getState$recoveryDat = _getState.recoveryData, aesKey = _getState$recoveryDat.aesKey, channelId = _getState$recoveryDat.channel.channelId;\n\n            isContextInfo = function isContextInfo(id) {\n              return id.startsWith(IMPORT_PREFIX + \"contextInfo_\");\n            };\n\n            contextInfoDataIds = dataIds.filter(function (dataId) {\n              return isContextInfo(dataId);\n            });\n            _iterator = _createForOfIteratorHelperLoose(contextInfoDataIds);\n\n          case 5:\n            if ((_step = _iterator()).done) {\n              _context.next = 16;\n              break;\n            }\n\n            dataId = _step.value;\n            _context.next = 9;\n            return _regeneratorRuntime.awrap(channelApi.download({\n              channelId: channelId,\n              dataId: dataId,\n              deleteAfterDownload: true\n            }));\n\n          case 9:\n            encrypted = _context.sent;\n            contextInfo = decryptData(encrypted, aesKey);\n            console.log(\"ContextInfo:\");\n            console.log(contextInfo);\n            dispatch(addLinkedContext(contextInfo));\n\n          case 14:\n            _context.next = 5;\n            break;\n\n          case 16:\n            return _context.abrupt(\"return\", contextInfoDataIds.length);\n\n          case 19:\n            _context.prev = 19;\n            _context.t0 = _context[\"catch\"](0);\n            console.error(\"downloadContextInfo error: \" + _context.t0.message);\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 19]], Promise);\n  };\n};\nexport var downloadBlindSigs = function downloadBlindSigs(_ref2) {\n  var channelApi = _ref2.channelApi,\n      dataIds = _ref2.dataIds;\n  return function _callee2(dispatch, getState) {\n    var _getState2, _getState2$recoveryDa, aesKey, channelId, isBlindSig, blindSigDataIds, _iterator2, _step2, dataId, encrypted, blindSigData;\n\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _getState2 = getState(), _getState2$recoveryDa = _getState2.recoveryData, aesKey = _getState2$recoveryDa.aesKey, channelId = _getState2$recoveryDa.channel.channelId;\n\n            isBlindSig = function isBlindSig(id) {\n              return id.startsWith(IMPORT_PREFIX + \"blindsig_\");\n            };\n\n            blindSigDataIds = dataIds.filter(function (dataId) {\n              return isBlindSig(dataId);\n            });\n            _iterator2 = _createForOfIteratorHelperLoose(blindSigDataIds);\n\n          case 5:\n            if ((_step2 = _iterator2()).done) {\n              _context2.next = 14;\n              break;\n            }\n\n            dataId = _step2.value;\n            _context2.next = 9;\n            return _regeneratorRuntime.awrap(channelApi.download({\n              channelId: channelId,\n              dataId: dataId,\n              deleteAfterDownload: true\n            }));\n\n          case 9:\n            encrypted = _context2.sent;\n            blindSigData = decryptData(encrypted, aesKey);\n            dispatch(upsertSig(blindSigData));\n\n          case 12:\n            _context2.next = 5;\n            break;\n\n          case 14:\n            return _context2.abrupt(\"return\", blindSigDataIds.length);\n\n          case 17:\n            _context2.prev = 17;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.error(\"downloadingBlindSigs: \" + _context2.t0.message);\n\n          case 20:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 17]], Promise);\n  };\n};\nexport var downloadUserInfo = function downloadUserInfo(_ref3) {\n  var channelApi = _ref3.channelApi,\n      dataIds = _ref3.dataIds;\n  return function _callee3(dispatch, getState) {\n    var _getState3, signingKey, _getState3$recoveryDa, aesKey, channelId, updateTimestamps, prefix, isUserInfo, uploader, userInfoDataId, encrypted, info, filename;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _getState3 = getState(), signingKey = _getState3.keypair.publicKey, _getState3$recoveryDa = _getState3.recoveryData, aesKey = _getState3$recoveryDa.aesKey, channelId = _getState3$recoveryDa.channel.channelId, updateTimestamps = _getState3.user.updateTimestamps;\n            prefix = IMPORT_PREFIX + \"userinfo_\";\n\n            isUserInfo = function isUserInfo(id) {\n              return id.startsWith(prefix);\n            };\n\n            uploader = function uploader(id) {\n              return id.replace(prefix, '').split(':')[1];\n            };\n\n            userInfoDataId = dataIds.find(function (dataId) {\n              return isUserInfo(dataId) && uploader(dataId) !== b64ToUrlSafeB64(signingKey);\n            });\n\n            if (userInfoDataId) {\n              _context3.next = 8;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", false);\n\n          case 8:\n            _context3.next = 10;\n            return _regeneratorRuntime.awrap(channelApi.download({\n              channelId: channelId,\n              dataId: userInfoDataId,\n              deleteAfterDownload: true\n            }));\n\n          case 10:\n            encrypted = _context3.sent;\n            info = decryptData(encrypted, aesKey);\n            dispatch(setRecoveryId(info.id));\n\n            if (!updateTimestamps.name || info.updateTimestamps.name > updateTimestamps.name) {\n              dispatch(setName(info.name));\n            }\n\n            if (!(!updateTimestamps.photo || info.updateTimestamps.photo > updateTimestamps.photo)) {\n              _context3.next = 20;\n              break;\n            }\n\n            _context3.next = 17;\n            return _regeneratorRuntime.awrap(saveImage({\n              imageName: info.id,\n              base64Image: info.photo\n            }));\n\n          case 17:\n            filename = _context3.sent;\n            info.photo = {\n              filename: filename\n            };\n            dispatch(setPhoto(info.photo));\n\n          case 20:\n            if (!updateTimestamps.isSponsored || info.updateTimestamps.isSponsored > updateTimestamps.isSponsored) {\n              dispatch(setIsSponsored(info.isSponsored));\n            }\n\n            if (!updateTimestamps.isSponsoredv6 || info.updateTimestamps.isSponsoredv6 > updateTimestamps.isSponsoredv6) {\n              dispatch(setIsSponsoredv6(info.isSponsoredv6));\n            }\n\n            if (!updateTimestamps.password || info.updateTimestamps.password > updateTimestamps.password) {\n              dispatch(setPassword(info.password));\n            }\n\n            if (!updateTimestamps.backupCompleted || info.updateTimestamps.backupCompleted > updateTimestamps.backupCompleted) {\n              dispatch(setBackupCompleted(info.backupCompleted));\n            }\n\n            return _context3.abrupt(\"return\", true);\n\n          case 27:\n            _context3.prev = 27;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.error(\"downloadingUserInfo: \" + _context3.t0.message);\n\n          case 30:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, [[0, 27]], Promise);\n  };\n};\nexport var checkCompletedFlags = function checkCompletedFlags(_ref4) {\n  var channelApi = _ref4.channelApi,\n      dataIds = _ref4.dataIds;\n  return function _callee4(dispatch, getState) {\n    var _getState4, signingKey, _getState4$recoveryDa, channelId, uploadCompletedBy, _prefix, isCompleted, completedBy, uploader, completedDataIds, _iterator3, _step3, dataId, _uploader;\n\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _getState4 = getState(), signingKey = _getState4.keypair.publicKey, _getState4$recoveryDa = _getState4.recoveryData, channelId = _getState4$recoveryDa.channel.channelId, uploadCompletedBy = _getState4$recoveryDa.uploadCompletedBy;\n            _prefix = IMPORT_PREFIX + \"completed_\";\n\n            isCompleted = function isCompleted(id) {\n              return id.startsWith(_prefix);\n            };\n\n            completedBy = function completedBy(id) {\n              return id.replace(_prefix, '');\n            };\n\n            uploader = function uploader(id) {\n              return id.replace(_prefix, '').split(':')[1];\n            };\n\n            completedDataIds = dataIds.filter(function (dataId) {\n              return isCompleted(dataId) && uploader(dataId) !== b64ToUrlSafeB64(signingKey) && !uploadCompletedBy[completedBy(dataId)];\n            });\n            _iterator3 = _createForOfIteratorHelperLoose(completedDataIds);\n\n          case 8:\n            if ((_step3 = _iterator3()).done) {\n              _context4.next = 16;\n              break;\n            }\n\n            dataId = _step3.value;\n            _context4.next = 12;\n            return _regeneratorRuntime.awrap(channelApi.download({\n              channelId: channelId,\n              dataId: dataId,\n              deleteAfterDownload: true\n            }));\n\n          case 12:\n            _uploader = completedBy(dataId);\n            dispatch(setUploadCompletedBy(_uploader));\n\n          case 14:\n            _context4.next = 8;\n            break;\n\n          case 16:\n            _context4.next = 21;\n            break;\n\n          case 18:\n            _context4.prev = 18;\n            _context4.t0 = _context4[\"catch\"](0);\n            console.error(\"checkingCompletedFlags: \" + _context4.t0.message);\n\n          case 21:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, [[0, 18]], Promise);\n  };\n};","map":{"version":3,"names":["b64ToUrlSafeB64","saveImage","addLinkedContext","upsertSig","decryptData","setUploadCompletedBy","setRecoveryId","setPhoto","setName","setIsSponsored","setBackupCompleted","setPassword","setIsSponsoredv6","IMPORT_PREFIX","downloadContextInfo","channelApi","dataIds","dispatch","getState","recoveryData","aesKey","channelId","channel","isContextInfo","id","startsWith","contextInfoDataIds","filter","dataId","download","deleteAfterDownload","encrypted","contextInfo","console","log","length","error","message","downloadBlindSigs","isBlindSig","blindSigDataIds","blindSigData","downloadUserInfo","signingKey","keypair","publicKey","updateTimestamps","user","prefix","isUserInfo","uploader","replace","split","userInfoDataId","find","info","name","photo","imageName","base64Image","filename","isSponsored","isSponsoredv6","password","backupCompleted","checkCompletedFlags","uploadCompletedBy","isCompleted","completedBy","completedDataIds"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/ImportFlow/thunks/channelDownloadThunks.ts"],"sourcesContent":["import { b64ToUrlSafeB64 } from '@/utils/encoding';\nimport { saveImage } from '@/utils/filesystem';\nimport { addLinkedContext, upsertSig } from '@/reducer/appsSlice';\nimport { decryptData } from '@/utils/cryptoHelper';\nimport {\n  setUploadCompletedBy,\n  setRecoveryId,\n} from '../../RecoveryFlow/recoveryDataSlice';\nimport {\n  setPhoto,\n  setName,\n  setIsSponsored,\n  setBackupCompleted,\n  setPassword,\n  setIsSponsoredv6,\n} from '@/reducer/userSlice';\nimport ChannelAPI from '@/api/channelService';\nimport { IMPORT_PREFIX } from '@/utils/constants';\n\nexport const downloadContextInfo =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        recoveryData: {\n          aesKey,\n          channel: { channelId },\n        },\n      } = getState();\n\n      const isContextInfo = (id: string) =>\n        id.startsWith(`${IMPORT_PREFIX}contextInfo_`);\n\n      const contextInfoDataIds = dataIds.filter((dataId) =>\n        isContextInfo(dataId),\n      );\n\n      for (const dataId of contextInfoDataIds) {\n        const encrypted = await channelApi.download({\n          channelId,\n          dataId,\n          deleteAfterDownload: true,\n        });\n        const contextInfo = decryptData(encrypted, aesKey) as ContextInfo;\n        console.log(`ContextInfo:`);\n        console.log(contextInfo);\n        dispatch(addLinkedContext(contextInfo));\n      }\n      return contextInfoDataIds.length;\n    } catch (err) {\n      console.error(`downloadContextInfo error: ${err.message}`);\n    }\n  };\n\nexport const downloadBlindSigs =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        recoveryData: {\n          aesKey,\n          channel: { channelId },\n        },\n      } = getState();\n\n      const isBlindSig = (id: string) =>\n        id.startsWith(`${IMPORT_PREFIX}blindsig_`);\n      const blindSigDataIds = dataIds.filter((dataId) => isBlindSig(dataId));\n\n      for (const dataId of blindSigDataIds) {\n        const encrypted = await channelApi.download({\n          channelId,\n          dataId,\n          deleteAfterDownload: true,\n        });\n        const blindSigData = decryptData(encrypted, aesKey) as SigInfo;\n        dispatch(upsertSig(blindSigData));\n      }\n      return blindSigDataIds.length;\n    } catch (err) {\n      console.error(`downloadingBlindSigs: ${err.message}`);\n    }\n  };\n\nexport const downloadUserInfo =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        keypair: { publicKey: signingKey },\n        recoveryData: {\n          aesKey,\n          channel: { channelId },\n        },\n        user: { updateTimestamps },\n      } = getState();\n\n      const prefix = `${IMPORT_PREFIX}userinfo_`;\n      const isUserInfo = (id: string) => id.startsWith(prefix);\n      const uploader = (id) => id.replace(prefix, '').split(':')[1];\n      const userInfoDataId = dataIds.find(\n        (dataId) =>\n          isUserInfo(dataId) &&\n          uploader(dataId) !== b64ToUrlSafeB64(signingKey),\n      );\n      if (!userInfoDataId) {\n        return false;\n      }\n\n      const encrypted = await channelApi.download({\n        channelId,\n        dataId: userInfoDataId,\n        deleteAfterDownload: true,\n      });\n      const info = decryptData(encrypted, aesKey);\n      dispatch(setRecoveryId(info.id));\n      if (\n        !updateTimestamps.name ||\n        info.updateTimestamps.name > updateTimestamps.name\n      ) {\n        dispatch(setName(info.name));\n      }\n      if (\n        !updateTimestamps.photo ||\n        info.updateTimestamps.photo > updateTimestamps.photo\n      ) {\n        const filename = await saveImage({\n          imageName: info.id,\n          base64Image: info.photo,\n        });\n        info.photo = { filename };\n        dispatch(setPhoto(info.photo));\n      }\n      if (\n        !updateTimestamps.isSponsored ||\n        info.updateTimestamps.isSponsored > updateTimestamps.isSponsored\n      ) {\n        dispatch(setIsSponsored(info.isSponsored));\n      }\n      if (\n        !updateTimestamps.isSponsoredv6 ||\n        info.updateTimestamps.isSponsoredv6 > updateTimestamps.isSponsoredv6\n      ) {\n        dispatch(setIsSponsoredv6(info.isSponsoredv6));\n      }\n      if (\n        !updateTimestamps.password ||\n        info.updateTimestamps.password > updateTimestamps.password\n      ) {\n        dispatch(setPassword(info.password));\n      }\n      if (\n        !updateTimestamps.backupCompleted ||\n        info.updateTimestamps.backupCompleted > updateTimestamps.backupCompleted\n      ) {\n        dispatch(setBackupCompleted(info.backupCompleted));\n      }\n      return true;\n    } catch (err) {\n      console.error(`downloadingUserInfo: ${err.message}`);\n    }\n  };\n\nexport const checkCompletedFlags =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        keypair: { publicKey: signingKey },\n        recoveryData: {\n          channel: { channelId },\n          uploadCompletedBy,\n        },\n      } = getState();\n\n      const prefix = `${IMPORT_PREFIX}completed_`;\n      const isCompleted = (id: string) => id.startsWith(prefix);\n      const completedBy = (id: string) => id.replace(prefix, '');\n      const uploader = (id) => id.replace(prefix, '').split(':')[1];\n\n      const completedDataIds = dataIds.filter(\n        (dataId) =>\n          isCompleted(dataId) &&\n          uploader(dataId) !== b64ToUrlSafeB64(signingKey) &&\n          !uploadCompletedBy[completedBy(dataId)],\n      );\n\n      for (const dataId of completedDataIds) {\n        await channelApi.download({\n          channelId,\n          dataId,\n          deleteAfterDownload: true,\n        });\n        const uploader = completedBy(dataId);\n        dispatch(setUploadCompletedBy(uploader));\n      }\n    } catch (err) {\n      console.error(`checkingCompletedFlags: ${err.message}`);\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}