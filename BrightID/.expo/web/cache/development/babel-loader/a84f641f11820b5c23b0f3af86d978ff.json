{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport nacl from 'tweetnacl';\nimport { createImageDirectory, saveImage } from \"../../../../utils/filesystem\";\nimport { hash, urlSafeRandomKey } from \"../../../../utils/encoding\";\nimport { setUserData, setConnections, setGroups, setKeypair, addOperation, upsertSig } from \"../../../../actions\";\nimport BrightidError, { OPERATION_APPLIED_BEFORE } from \"../../../../api/brightidError\";\nimport fetchUserInfo from \"../../../../actions/fetchUserInfo\";\nimport { fetchBackupData } from \"./backupThunks\";\nimport { init, resetRecoveryData, resetRecoverySigs, updateNamePhoto } from \"../recoveryDataSlice\";\nvar THREE_DAYS = 259200000;\n\nvar pastLimit = function pastLimit(timestamp) {\n  return timestamp + THREE_DAYS < Date.now();\n};\n\nexport var setupRecovery = function setupRecovery() {\n  return function _callee(dispatch, getState) {\n    var _getState, recoveryData, _await$nacl$sign$keyP, publicKey, secretKey, aesKey;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.log(\"Setting up recovery...\");\n            _getState = getState(), recoveryData = _getState.recoveryData;\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(createImageDirectory());\n\n          case 4:\n            if (!(!recoveryData.timestamp || pastLimit(recoveryData.timestamp))) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.next = 7;\n            return _regeneratorRuntime.awrap(nacl.sign.keyPair());\n\n          case 7:\n            _await$nacl$sign$keyP = _context.sent;\n            publicKey = _await$nacl$sign$keyP.publicKey;\n            secretKey = _await$nacl$sign$keyP.secretKey;\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(urlSafeRandomKey(16));\n\n          case 12:\n            aesKey = _context.sent;\n            dispatch(init({\n              publicKey: publicKey,\n              secretKey: secretKey,\n              aesKey: aesKey\n            }));\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var socialRecovery = function socialRecovery(api) {\n  return function _callee2(dispatch, getState) {\n    var _getState2, recoveryData, sigs, op, errorString;\n\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _getState2 = getState(), recoveryData = _getState2.recoveryData;\n            sigs = Object.values(recoveryData.sigs);\n            console.log('setting signing key');\n            _context2.prev = 3;\n            _context2.next = 6;\n            return _regeneratorRuntime.awrap(api.socialRecovery({\n              id: recoveryData.id,\n              signingKey: recoveryData.publicKey,\n              timestamp: recoveryData.timestamp,\n              id1: sigs[0].signer,\n              id2: sigs[1].signer,\n              sig1: sigs[0].sig,\n              sig2: sigs[1].sig\n            }));\n\n          case 6:\n            op = _context2.sent;\n            dispatch(addOperation(op));\n            return _context2.abrupt(\"return\", op);\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](3);\n            errorString = '';\n\n            if (!(_context2.t0 instanceof BrightidError)) {\n              _context2.next = 21;\n              break;\n            }\n\n            if (!(_context2.t0.errorNum === OPERATION_APPLIED_BEFORE)) {\n              _context2.next = 18;\n              break;\n            }\n\n            console.log(\"Social Recovery operation already applied. Ignoring this error.\");\n            return _context2.abrupt(\"return\", 'ALREADY APPLIED');\n\n          case 18:\n            errorString = _context2.t0.errorNum + \" - \" + _context2.t0.message;\n            _context2.next = 22;\n            break;\n\n          case 21:\n            if (_context2.t0 instanceof Error) {\n              errorString = _context2.t0.name + \" - \" + _context2.t0.message;\n            } else {\n              errorString = \"\" + _context2.t0;\n            }\n\n          case 22:\n            console.log(\"Error in socialRecovery: \" + errorString);\n            dispatch(resetRecoverySigs());\n            throw new Error(errorString);\n\n          case 25:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[3, 11]], Promise);\n  };\n};\nexport var restoreUserData = function _callee3(id, pass) {\n  var decrypted, _JSON$parse, userData, connections, _JSON$parse$groups, groups, userPhoto, filename;\n\n  return _regeneratorRuntime.async(function _callee3$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regeneratorRuntime.awrap(fetchBackupData('data', id, pass));\n\n        case 2:\n          decrypted = _context3.sent;\n          _JSON$parse = JSON.parse(decrypted), userData = _JSON$parse.userData, connections = _JSON$parse.connections, _JSON$parse$groups = _JSON$parse.groups, groups = _JSON$parse$groups === void 0 ? [] : _JSON$parse$groups;\n\n          if (!(!userData || !connections)) {\n            _context3.next = 6;\n            break;\n          }\n\n          throw new Error('bad password');\n\n        case 6:\n          _context3.prev = 6;\n          _context3.next = 9;\n          return _regeneratorRuntime.awrap(fetchBackupData(id, id, pass));\n\n        case 9:\n          userPhoto = _context3.sent;\n          _context3.next = 15;\n          break;\n\n        case 12:\n          _context3.prev = 12;\n          _context3.t0 = _context3[\"catch\"](6);\n          console.log(\"Failed to recover user photo\");\n\n        case 15:\n          if (!userPhoto) {\n            _context3.next = 20;\n            break;\n          }\n\n          _context3.next = 18;\n          return _regeneratorRuntime.awrap(saveImage({\n            imageName: id,\n            base64Image: userPhoto\n          }));\n\n        case 18:\n          filename = _context3.sent;\n          userData.photo = {\n            filename: filename\n          };\n\n        case 20:\n          return _context3.abrupt(\"return\", {\n            userData: userData,\n            connections: connections,\n            groups: groups\n          });\n\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[6, 12]], Promise);\n};\nexport var setRecoveryKeys = function setRecoveryKeys() {\n  return function (dispatch, getState) {\n    var _getState$recoveryDat = getState().recoveryData,\n        publicKey = _getState$recoveryDat.publicKey,\n        secretKey = _getState$recoveryDat.secretKey;\n    dispatch(setKeypair({\n      publicKey: publicKey,\n      secretKey: secretKey\n    }));\n  };\n};\nexport var recoverData = function recoverData(pass, api, setTotalItems, setCurrentItem) {\n  return function _callee4(dispatch, getState) {\n    var id, restoredData, userData, connections, groups, apps, blindSigApps, currentItem, _iterator, _step, conn, decrypted, filename, errorString, _iterator2, _step2, _group$photo, group, _decrypted, _errorString, _iterator3, _step3, app, _iterator4, _step4, verification, vel, roundedTimestamp, key, _decrypted2;\n\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            id = getState().recoveryData.id;\n            console.log(\"Starting recoverData for \" + id);\n            _context4.next = 4;\n            return _regeneratorRuntime.awrap(restoreUserData(id, pass));\n\n          case 4:\n            restoredData = _context4.sent;\n            console.log(\"Got recovery data for \" + id);\n            userData = restoredData.userData;\n            connections = restoredData.connections;\n            groups = restoredData.groups;\n            _context4.next = 11;\n            return _regeneratorRuntime.awrap(api.getApps());\n\n          case 11:\n            apps = _context4.sent;\n            blindSigApps = apps.filter(function (app) {\n              return app.usingBlindSig;\n            });\n            setTotalItems(connections.length + groups.length + blindSigApps.length);\n            dispatch(setConnections(connections));\n            dispatch(setGroups(groups));\n            dispatch(updateNamePhoto({\n              name: userData.name,\n              photo: userData.photo\n            }));\n            currentItem = 1;\n            _iterator = _createForOfIteratorHelperLoose(connections);\n\n          case 19:\n            if ((_step = _iterator()).done) {\n              _context4.next = 40;\n              break;\n            }\n\n            conn = _step.value;\n            _context4.prev = 21;\n            setCurrentItem(currentItem++);\n            _context4.next = 25;\n            return _regeneratorRuntime.awrap(fetchBackupData(conn.id, id, pass));\n\n          case 25:\n            decrypted = _context4.sent;\n            _context4.next = 28;\n            return _regeneratorRuntime.awrap(saveImage({\n              imageName: conn.id,\n              base64Image: decrypted\n            }));\n\n          case 28:\n            filename = _context4.sent;\n            conn.photo = {\n              filename: filename\n            };\n            _context4.next = 38;\n            break;\n\n          case 32:\n            _context4.prev = 32;\n            _context4.t0 = _context4[\"catch\"](21);\n            errorString = '';\n\n            if (_context4.t0 instanceof Error) {\n              errorString = _context4.t0.name + \" - \" + _context4.t0.message;\n            } else {\n              errorString = \"\" + _context4.t0;\n            }\n\n            console.log('Connection image not found', errorString);\n            conn.photo = {\n              filename: ''\n            };\n\n          case 38:\n            _context4.next = 19;\n            break;\n\n          case 40:\n            _iterator2 = _createForOfIteratorHelperLoose(groups);\n\n          case 41:\n            if ((_step2 = _iterator2()).done) {\n              _context4.next = 60;\n              break;\n            }\n\n            group = _step2.value;\n            setCurrentItem(currentItem++);\n\n            if (!((_group$photo = group.photo) != null && _group$photo.filename)) {\n              _context4.next = 58;\n              break;\n            }\n\n            _context4.prev = 45;\n            _context4.next = 48;\n            return _regeneratorRuntime.awrap(fetchBackupData(group.id, id, pass));\n\n          case 48:\n            _decrypted = _context4.sent;\n            _context4.next = 51;\n            return _regeneratorRuntime.awrap(saveImage({\n              imageName: group.id,\n              base64Image: _decrypted\n            }));\n\n          case 51:\n            _context4.next = 58;\n            break;\n\n          case 53:\n            _context4.prev = 53;\n            _context4.t1 = _context4[\"catch\"](45);\n            _errorString = '';\n\n            if (_context4.t1 instanceof Error) {\n              _errorString = _context4.t1.name + \" - \" + _context4.t1.message;\n            } else {\n              _errorString = \"\" + _context4.t1;\n            }\n\n            console.log('Group image not found', _errorString);\n\n          case 58:\n            _context4.next = 41;\n            break;\n\n          case 60:\n            _iterator3 = _createForOfIteratorHelperLoose(blindSigApps);\n\n          case 61:\n            if ((_step3 = _iterator3()).done) {\n              _context4.next = 85;\n              break;\n            }\n\n            app = _step3.value;\n            setCurrentItem(currentItem++);\n            _iterator4 = _createForOfIteratorHelperLoose(app.verifications);\n\n          case 65:\n            if ((_step4 = _iterator4()).done) {\n              _context4.next = 83;\n              break;\n            }\n\n            verification = _step4.value;\n            vel = app.verificationExpirationLength;\n            roundedTimestamp = vel ? Math.floor(Date.now() / vel) * vel : 0;\n            key = hash(app.id + \" \" + verification + \" \" + roundedTimestamp);\n            _context4.prev = 70;\n            _context4.next = 73;\n            return _regeneratorRuntime.awrap(fetchBackupData(key, id, pass));\n\n          case 73:\n            _decrypted2 = _context4.sent;\n            _context4.next = 76;\n            return _regeneratorRuntime.awrap(dispatch(upsertSig(JSON.parse(_decrypted2))));\n\n          case 76:\n            _context4.next = 81;\n            break;\n\n          case 78:\n            _context4.prev = 78;\n            _context4.t2 = _context4[\"catch\"](70);\n            console.log(\"blind sig not found for \" + key, _context4.t2.message);\n\n          case 81:\n            _context4.next = 65;\n            break;\n\n          case 83:\n            _context4.next = 61;\n            break;\n\n          case 85:\n            dispatch(fetchUserInfo(api));\n\n          case 86:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, [[21, 32], [45, 53], [70, 78]], Promise);\n  };\n};\nexport var finishRecovery = function finishRecovery() {\n  return function _callee5(dispatch, getState) {\n    var _getState$recoveryDat2, id, name, photo;\n\n    return _regeneratorRuntime.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _getState$recoveryDat2 = getState().recoveryData, id = _getState$recoveryDat2.id, name = _getState$recoveryDat2.name, photo = _getState$recoveryDat2.photo;\n            dispatch(resetRecoveryData());\n            dispatch(setUserData({\n              id: id,\n              name: name,\n              photo: photo\n            }));\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"names":["nacl","createImageDirectory","saveImage","hash","urlSafeRandomKey","setUserData","setConnections","setGroups","setKeypair","addOperation","upsertSig","BrightidError","OPERATION_APPLIED_BEFORE","fetchUserInfo","fetchBackupData","init","resetRecoveryData","resetRecoverySigs","updateNamePhoto","THREE_DAYS","pastLimit","timestamp","Date","now","setupRecovery","dispatch","getState","console","log","recoveryData","sign","keyPair","publicKey","secretKey","aesKey","socialRecovery","api","sigs","Object","values","id","signingKey","id1","signer","id2","sig1","sig","sig2","op","errorString","errorNum","message","Error","name","restoreUserData","pass","decrypted","JSON","parse","userData","connections","groups","userPhoto","imageName","base64Image","filename","photo","setRecoveryKeys","recoverData","setTotalItems","setCurrentItem","restoredData","getApps","apps","blindSigApps","filter","app","usingBlindSig","length","currentItem","conn","group","verifications","verification","vel","verificationExpirationLength","roundedTimestamp","Math","floor","key","finishRecovery"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/recoveryThunks.ts"],"sourcesContent":["import nacl from 'tweetnacl';\nimport { createImageDirectory, saveImage } from '@/utils/filesystem';\nimport { hash, urlSafeRandomKey } from '@/utils/encoding';\nimport {\n  setUserData,\n  setConnections,\n  setGroups,\n  setKeypair,\n  addOperation,\n  upsertSig,\n} from '@/actions';\nimport BrightidError, { OPERATION_APPLIED_BEFORE } from '@/api/brightidError';\nimport { NodeApi } from '@/api/brightId';\nimport fetchUserInfo from '@/actions/fetchUserInfo';\nimport { fetchBackupData } from './backupThunks';\nimport {\n  init,\n  resetRecoveryData,\n  resetRecoverySigs,\n  updateNamePhoto,\n} from '../recoveryDataSlice';\n\n// HELPERS\n\nconst THREE_DAYS = 259200000;\n\nconst pastLimit = (timestamp) => timestamp + THREE_DAYS < Date.now();\n\n// THUNKS\n\nexport const setupRecovery =\n  () => async (dispatch: dispatch, getState: getState) => {\n    console.log(`Setting up recovery...`);\n    const { recoveryData } = getState();\n    await createImageDirectory();\n    // setup recovery data\n    if (!recoveryData.timestamp || pastLimit(recoveryData.timestamp)) {\n      const { publicKey, secretKey } = await nacl.sign.keyPair();\n      const aesKey = await urlSafeRandomKey(16);\n      // setup recovery data slice with new keypair\n      dispatch(init({ publicKey, secretKey, aesKey }));\n    }\n  };\n\nexport const socialRecovery =\n  (api: NodeApi) => async (dispatch: dispatch, getState: getState) => {\n    const { recoveryData } = getState();\n    const sigs = Object.values(recoveryData.sigs);\n    console.log('setting signing key');\n    try {\n      const op = await api.socialRecovery({\n        id: recoveryData.id,\n        signingKey: recoveryData.publicKey,\n        timestamp: recoveryData.timestamp,\n        id1: sigs[0].signer,\n        id2: sigs[1].signer,\n        sig1: sigs[0].sig,\n        sig2: sigs[1].sig,\n      });\n      dispatch(addOperation(op));\n      return op;\n    } catch (err) {\n      let errorString = '';\n      if (err instanceof BrightidError) {\n        if (err.errorNum === OPERATION_APPLIED_BEFORE) {\n          console.log(\n            `Social Recovery operation already applied. Ignoring this error.`,\n          );\n          return 'ALREADY APPLIED';\n        }\n        errorString = `${err.errorNum} - ${err.message}`;\n      } else if (err instanceof Error) {\n        errorString = `${err.name} - ${err.message}`;\n      } else {\n        errorString = `${err}`;\n      }\n      console.log(`Error in socialRecovery: ${errorString}`);\n      dispatch(resetRecoverySigs());\n      throw new Error(errorString);\n    }\n  };\n\nexport const restoreUserData = async (id: string, pass: string) => {\n  const decrypted = await fetchBackupData('data', id, pass);\n  const { userData, connections, groups = [] } = JSON.parse(decrypted);\n  if (!userData || !connections) {\n    // TODO Better error handling\n    throw new Error('bad password');\n  }\n\n  let userPhoto;\n  try {\n    userPhoto = await fetchBackupData(id, id, pass);\n  } catch (e) {\n    console.log(`Failed to recover user photo`);\n    // ignore this error and try to continue recovery process\n  }\n\n  if (userPhoto) {\n    const filename = await saveImage({\n      imageName: id,\n      base64Image: userPhoto,\n    });\n    userData.photo = { filename };\n  }\n\n  return { userData, connections, groups };\n};\n\nexport const setRecoveryKeys =\n  () => (dispatch: dispatch, getState: getState) => {\n    const { publicKey, secretKey } = getState().recoveryData;\n    dispatch(setKeypair({ publicKey, secretKey }));\n  };\n\nexport const recoverData =\n  (\n    pass: string,\n    api: NodeApi,\n    setTotalItems: (totalItems: number) => void,\n    setCurrentItem: (currentItem: number) => void,\n  ) =>\n  async (dispatch: dispatch, getState: getState) => {\n    const { id } = getState().recoveryData;\n    console.log(`Starting recoverData for ${id}`);\n    // throws if data is bad\n    const restoredData = await restoreUserData(id, pass);\n    console.log(`Got recovery data for ${id}`);\n    const { userData } = restoredData;\n    const { connections } = restoredData;\n    const { groups } = restoredData;\n    const apps = await api.getApps();\n    const blindSigApps = apps.filter((app) => app.usingBlindSig);\n    setTotalItems(connections.length + groups.length + blindSigApps.length);\n    dispatch(setConnections(connections));\n    dispatch(setGroups(groups));\n    dispatch(updateNamePhoto({ name: userData.name, photo: userData.photo }));\n\n    let currentItem = 1;\n\n    // fetch connection images\n    for (const conn of connections) {\n      try {\n        setCurrentItem(currentItem++);\n        const decrypted = await fetchBackupData(conn.id, id, pass);\n        const filename = await saveImage({\n          imageName: conn.id,\n          base64Image: decrypted,\n        });\n        conn.photo = { filename };\n      } catch (err) {\n        let errorString = '';\n        if (err instanceof Error) {\n          errorString = `${err.name} - ${err.message}`;\n        } else {\n          errorString = `${err}`;\n        }\n        console.log('Connection image not found', errorString);\n        conn.photo = { filename: '' };\n      }\n    }\n\n    // fetch group images\n    for (const group of groups) {\n      setCurrentItem(currentItem++);\n      if (group.photo?.filename) {\n        try {\n          const decrypted = await fetchBackupData(group.id, id, pass);\n          await saveImage({\n            imageName: group.id,\n            base64Image: decrypted,\n          });\n        } catch (err) {\n          let errorString = '';\n          if (err instanceof Error) {\n            errorString = `${err.name} - ${err.message}`;\n          } else {\n            errorString = `${err}`;\n          }\n          console.log('Group image not found', errorString);\n        }\n      }\n    }\n\n    // fetch blind sigs\n    for (const app of blindSigApps) {\n      setCurrentItem(currentItem++);\n      for (const verification of app.verifications) {\n        const vel = app.verificationExpirationLength;\n        const roundedTimestamp = vel ? Math.floor(Date.now() / vel) * vel : 0;\n        const key = hash(`${app.id} ${verification} ${roundedTimestamp}`);\n        try {\n          const decrypted = await fetchBackupData(key, id, pass);\n          await dispatch(upsertSig(JSON.parse(decrypted)));\n        } catch (err) {\n          console.log(`blind sig not found for ${key}`, err.message);\n        }\n      }\n    }\n\n    dispatch(fetchUserInfo(api));\n  };\n\nexport const finishRecovery =\n  () => async (dispatch: dispatch, getState: getState) => {\n    // collect user data that was populated either by uploads from recovery connections or by restoring backup\n    const { id, name, photo } = getState().recoveryData;\n    // clear recovery data from state\n    dispatch(resetRecoveryData());\n    // finally set the user data\n    dispatch(setUserData({ id, name, photo }));\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}