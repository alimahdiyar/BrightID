{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { SET_BACKUP_PENDING, SET_RECOVERY_CONNECTIONS_PENDING, SET_DEVICE_TOKEN, SET_ACTIVE_NOTIFICATION, SET_NOTIFICATION_TOKEN, REMOVE_ACTIVE_NOTIFICATION, RESET_STORE } from \"../actions\";\nimport { CONNECTIONS_TYPE, GROUPS_TYPE, MISC_TYPE } from \"../utils/constants\";\nvar initialState = {\n  activeNotification: null,\n  backupPending: false,\n  recoveryConnectionsPending: false,\n  deviceToken: null,\n  notificationToken: null,\n  sessionNotifications: []\n};\nexport var reducer = function reducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case SET_BACKUP_PENDING:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          backupPending: action.backupPending\n        });\n      }\n\n    case SET_RECOVERY_CONNECTIONS_PENDING:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          recoveryConnectionsPending: action.recoveryConnectionsPending\n        });\n      }\n\n    case SET_DEVICE_TOKEN:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          deviceToken: action.deviceToken\n        });\n      }\n\n    case SET_NOTIFICATION_TOKEN:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          notificationToken: action.notificationToken\n        });\n      }\n\n    case SET_ACTIVE_NOTIFICATION:\n      {\n        var _state$activeNotifica, _state$activeNotifica2;\n\n        var notification = action.notification;\n\n        if (!notification) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            activeNotification: null\n          });\n        }\n\n        if (notification.oncePerSession) {\n          if (state.sessionNotifications.includes(notification.title)) {\n            return state;\n          }\n        }\n\n        if (((_state$activeNotifica = state.activeNotification) == null ? void 0 : _state$activeNotifica.type) === CONNECTIONS_TYPE && (notification == null ? void 0 : notification.type) !== CONNECTIONS_TYPE) return state;\n        if (((_state$activeNotifica2 = state.activeNotification) == null ? void 0 : _state$activeNotifica2.type) === GROUPS_TYPE && (notification == null ? void 0 : notification.type) === MISC_TYPE) return state;\n\n        var sessionNotifications = _toConsumableArray(state.sessionNotifications);\n\n        if (notification != null && notification.oncePerSession) {\n          sessionNotifications.push(notification.title);\n        }\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          activeNotification: notification,\n          sessionNotifications: sessionNotifications\n        });\n      }\n\n    case REMOVE_ACTIVE_NOTIFICATION:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          activeNotification: {}\n        });\n      }\n\n    case RESET_STORE:\n      {\n        return _objectSpread({}, initialState);\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n};\nexport default reducer;","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/reducer/notifications.ts"],"names":["initialState","activeNotification","backupPending","recoveryConnectionsPending","deviceToken","notificationToken","sessionNotifications","reducer","state","action","notification"],"mappings":"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","sourcesContent":["import {\n  SET_BACKUP_PENDING,\n  SET_RECOVERY_CONNECTIONS_PENDING,\n  SET_DEVICE_TOKEN,\n  SET_ACTIVE_NOTIFICATION,\n  SET_NOTIFICATION_TOKEN,\n  REMOVE_ACTIVE_NOTIFICATION,\n  RESET_STORE,\n} from '@/actions';\nimport { CONNECTIONS_TYPE, GROUPS_TYPE, MISC_TYPE } from '@/utils/constants';\n\nconst initialState = {\n  activeNotification: null,\n  backupPending: false,\n  recoveryConnectionsPending: false,\n  deviceToken: null,\n  notificationToken: null,\n  sessionNotifications: [],\n};\n\n// not sure if this is the best way...\n\nexport const reducer = (\n  state: NotificationsState = initialState,\n  action: action,\n) => {\n  switch (action.type) {\n    case SET_BACKUP_PENDING: {\n      return { ...state, backupPending: action.backupPending };\n    }\n    case SET_RECOVERY_CONNECTIONS_PENDING: {\n      return {\n        ...state,\n        recoveryConnectionsPending: action.recoveryConnectionsPending,\n      };\n    }\n    case SET_DEVICE_TOKEN: {\n      return { ...state, deviceToken: action.deviceToken };\n    }\n    case SET_NOTIFICATION_TOKEN: {\n      return { ...state, notificationToken: action.notificationToken };\n    }\n    case SET_ACTIVE_NOTIFICATION: {\n      const { notification } = action;\n      // set null activeNotifications\n      if (!notification) {\n        return { ...state, activeNotification: null };\n      }\n\n      // handle once-per-session notifications\n      if (notification.oncePerSession) {\n        if (state.sessionNotifications.includes(notification.title)) {\n          // Ignore if already notified before\n          return state;\n        }\n      }\n\n      // do not update the notification banner if the active is set as a new connection\n      if (\n        state.activeNotification?.type === CONNECTIONS_TYPE &&\n        notification?.type !== CONNECTIONS_TYPE\n      )\n        return state;\n\n      // do not update the notification banner if the alert is for backups,\n      // and a notification is already displayed\n      if (\n        state.activeNotification?.type === GROUPS_TYPE &&\n        notification?.type === MISC_TYPE\n      )\n        return state;\n\n      const sessionNotifications = [...state.sessionNotifications];\n      if (notification?.oncePerSession) {\n        sessionNotifications.push(notification.title);\n      }\n\n      return {\n        ...state,\n        activeNotification: notification,\n        sessionNotifications,\n      };\n    }\n    case REMOVE_ACTIVE_NOTIFICATION: {\n      return { ...state, activeNotification: {} };\n    }\n    case RESET_STORE: {\n      return { ...initialState };\n    }\n    default: {\n      return state;\n    }\n  }\n};\n\nexport default reducer;\n"]},"metadata":{},"sourceType":"module"}