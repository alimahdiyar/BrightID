{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _logging = _interopRequireDefault(require(\"./logging\"));\n\nmodule.exports = function (NativeCodePush) {\n  var remote = function remote(reportStatusDownload) {\n    return {\n      download: function download(downloadProgressCallback) {\n        var _this = this;\n\n        return function _callee() {\n          var downloadProgressSubscription, codePushEventEmitter, updatePackageCopy, downloadedPackage;\n          return _regenerator.default.async(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (_this.downloadUrl) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  throw new Error(\"Cannot download an update without a download url\");\n\n                case 2:\n                  if (downloadProgressCallback) {\n                    codePushEventEmitter = new _reactNative.NativeEventEmitter(NativeCodePush);\n                    downloadProgressSubscription = codePushEventEmitter.addListener(\"CodePushDownloadProgress\", downloadProgressCallback);\n                  }\n\n                  _context.prev = 3;\n                  updatePackageCopy = (0, _extends2.default)({}, _this);\n                  Object.keys(updatePackageCopy).forEach(function (key) {\n                    return typeof updatePackageCopy[key] === 'function' && delete updatePackageCopy[key];\n                  });\n                  _context.next = 8;\n                  return _regenerator.default.awrap(NativeCodePush.downloadUpdate(updatePackageCopy, !!downloadProgressCallback));\n\n                case 8:\n                  downloadedPackage = _context.sent;\n\n                  if (reportStatusDownload) {\n                    reportStatusDownload(_this).catch(function (err) {\n                      (0, _logging.default)(\"Report download status failed: \" + err);\n                    });\n                  }\n\n                  return _context.abrupt(\"return\", (0, _extends2.default)({}, downloadedPackage, local));\n\n                case 11:\n                  _context.prev = 11;\n                  downloadProgressSubscription && downloadProgressSubscription.remove();\n                  return _context.finish(11);\n\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, null, null, [[3,, 11, 14]], Promise);\n        }();\n      },\n      isPending: false\n    };\n  };\n\n  var local = {\n    install: function install() {\n      var _this2 = this;\n\n      var installMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NativeCodePush.codePushInstallModeOnNextRestart;\n      var minimumBackgroundDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var updateInstalledCallback = arguments.length > 2 ? arguments[2] : undefined;\n      return function _callee2() {\n        var localPackage, localPackageCopy;\n        return _regenerator.default.async(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                localPackage = _this2;\n                localPackageCopy = (0, _extends2.default)({}, localPackage);\n                _context2.next = 4;\n                return _regenerator.default.awrap(NativeCodePush.installUpdate(localPackageCopy, installMode, minimumBackgroundDuration));\n\n              case 4:\n                updateInstalledCallback && updateInstalledCallback();\n\n                if (installMode == NativeCodePush.codePushInstallModeImmediate) {\n                  NativeCodePush.restartApp(false);\n                } else {\n                  NativeCodePush.clearPendingRestart();\n                  localPackage.isPending = true;\n                }\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      }();\n    },\n    isPending: false\n  };\n  return {\n    local: local,\n    remote: remote\n  };\n};","map":{"version":3,"names":["module","exports","NativeCodePush","remote","reportStatusDownload","download","downloadProgressCallback","downloadUrl","Error","codePushEventEmitter","NativeEventEmitter","downloadProgressSubscription","addListener","updatePackageCopy","Object","keys","forEach","key","downloadUpdate","downloadedPackage","catch","err","log","local","remove","isPending","install","installMode","codePushInstallModeOnNextRestart","minimumBackgroundDuration","updateInstalledCallback","localPackage","localPackageCopy","installUpdate","codePushInstallModeImmediate","restartApp","clearPendingRestart"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/node_modules/react-native-code-push/package-mixins.js"],"sourcesContent":["import { NativeEventEmitter } from \"react-native\";\nimport log from \"./logging\";\n\n// This function is used to augment remote and local\n// package objects with additional functionality/properties\n// beyond what is included in the metadata sent by the server.\nmodule.exports = (NativeCodePush) => {\n  const remote = (reportStatusDownload) => {\n    return {\n      async download(downloadProgressCallback) {\n        if (!this.downloadUrl) {\n          throw new Error(\"Cannot download an update without a download url\");\n        }\n\n        let downloadProgressSubscription;\n        if (downloadProgressCallback) {\n          const codePushEventEmitter = new NativeEventEmitter(NativeCodePush);\n          // Use event subscription to obtain download progress.\n          downloadProgressSubscription = codePushEventEmitter.addListener(\n            \"CodePushDownloadProgress\",\n            downloadProgressCallback\n          );\n        }\n\n        // Use the downloaded package info. Native code will save the package info\n        // so that the client knows what the current package version is.\n        try {\n          const updatePackageCopy = Object.assign({}, this);\n          Object.keys(updatePackageCopy).forEach((key) => (typeof updatePackageCopy[key] === 'function') && delete updatePackageCopy[key]);\n\n          const downloadedPackage = await NativeCodePush.downloadUpdate(updatePackageCopy, !!downloadProgressCallback);\n\n          if (reportStatusDownload) {\n            reportStatusDownload(this)\n            .catch((err) => {\n              log(`Report download status failed: ${err}`);\n            });\n          }\n\n          return { ...downloadedPackage, ...local };\n        } finally {\n          downloadProgressSubscription && downloadProgressSubscription.remove();\n        }\n      },\n\n      isPending: false // A remote package could never be in a pending state\n    };\n  };\n\n  const local = {\n    async install(installMode = NativeCodePush.codePushInstallModeOnNextRestart, minimumBackgroundDuration = 0, updateInstalledCallback) {\n      const localPackage = this;\n      const localPackageCopy = Object.assign({}, localPackage); // In dev mode, React Native deep freezes any object queued over the bridge\n      await NativeCodePush.installUpdate(localPackageCopy, installMode, minimumBackgroundDuration);\n      updateInstalledCallback && updateInstalledCallback();\n      if (installMode == NativeCodePush.codePushInstallModeImmediate) {\n        NativeCodePush.restartApp(false);\n      } else {\n        NativeCodePush.clearPendingRestart();\n        localPackage.isPending = true; // Mark the package as pending since it hasn't been applied yet\n      }\n    },\n\n    isPending: false // A local package wouldn't be pending until it was installed\n  };\n\n  return { local, remote };\n};"],"mappings":";;;;;;AAAA;;AACA;;AAKAA,MAAM,CAACC,OAAP,GAAiB,UAACC,cAAD,EAAoB;EACnC,IAAMC,MAAM,GAAG,SAATA,MAAS,CAACC,oBAAD,EAA0B;IACvC,OAAO;MACCC,QADD,oBACUC,wBADV,EACoC;QAAA;;QAAA;UAAA;UAAA;YAAA;cAAA;gBAAA;kBAAA,IAClC,KAAI,CAACC,WAD6B;oBAAA;oBAAA;kBAAA;;kBAAA,MAE/B,IAAIC,KAAJ,CAAU,kDAAV,CAF+B;;gBAAA;kBAMvC,IAAIF,wBAAJ,EAA8B;oBACtBG,oBADsB,GACC,IAAIC,+BAAJ,CAAuBR,cAAvB,CADD;oBAG5BS,4BAA4B,GAAGF,oBAAoB,CAACG,WAArB,CAC7B,0BAD6B,EAE7BN,wBAF6B,CAA/B;kBAID;;kBAbsC;kBAkB/BO,iBAlB+B,GAkBX,uBAAc,EAAd,EAAkB,KAAlB,CAlBW;kBAmBrCC,MAAM,CAACC,IAAP,CAAYF,iBAAZ,EAA+BG,OAA/B,CAAuC,UAACC,GAAD;oBAAA,OAAU,OAAOJ,iBAAiB,CAACI,GAAD,CAAxB,KAAkC,UAAnC,IAAkD,OAAOJ,iBAAiB,CAACI,GAAD,CAAnF;kBAAA,CAAvC;kBAnBqC;kBAAA,kCAqBLf,cAAc,CAACgB,cAAf,CAA8BL,iBAA9B,EAAiD,CAAC,CAACP,wBAAnD,CArBK;;gBAAA;kBAqB/Ba,iBArB+B;;kBAuBrC,IAAIf,oBAAJ,EAA0B;oBACxBA,oBAAoB,CAAC,KAAD,CAApB,CACCgB,KADD,CACO,UAACC,GAAD,EAAS;sBACd,IAAAC,gBAAA,sCAAsCD,GAAtC;oBACD,CAHD;kBAID;;kBA5BoC,4DA8BzBF,iBA9ByB,EA8BHI,KA9BG;;gBAAA;kBAAA;kBAgCrCZ,4BAA4B,IAAIA,4BAA4B,CAACa,MAA7B,EAAhC;kBAhCqC;;gBAAA;gBAAA;kBAAA;cAAA;YAAA;UAAA;QAAA;MAkCxC,CAnCI;MAqCLC,SAAS,EAAE;IArCN,CAAP;EAuCD,CAxCD;;EA0CA,IAAMF,KAAK,GAAG;IACNG,OADM,qBACyH;MAAA;;MAAA,IAAvHC,WAAuH,uEAAzGzB,cAAc,CAAC0B,gCAA0F;MAAA,IAAxDC,yBAAwD,uEAA5B,CAA4B;MAAA,IAAzBC,uBAAyB;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAC7HC,YAD6H,GAC9G,MAD8G;gBAE7HC,gBAF6H,GAE1G,uBAAc,EAAd,EAAkBD,YAAlB,CAF0G;gBAAA;gBAAA,kCAG7H7B,cAAc,CAAC+B,aAAf,CAA6BD,gBAA7B,EAA+CL,WAA/C,EAA4DE,yBAA5D,CAH6H;;cAAA;gBAInIC,uBAAuB,IAAIA,uBAAuB,EAAlD;;gBACA,IAAIH,WAAW,IAAIzB,cAAc,CAACgC,4BAAlC,EAAgE;kBAC9DhC,cAAc,CAACiC,UAAf,CAA0B,KAA1B;gBACD,CAFD,MAEO;kBACLjC,cAAc,CAACkC,mBAAf;kBACAL,YAAY,CAACN,SAAb,GAAyB,IAAzB;gBACD;;cAVkI;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IAWpI,CAZW;IAcZA,SAAS,EAAE;EAdC,CAAd;EAiBA,OAAO;IAAEF,KAAK,EAALA,KAAF;IAASpB,MAAM,EAANA;EAAT,CAAP;AACD,CA7DD"},"metadata":{},"sourceType":"script"}