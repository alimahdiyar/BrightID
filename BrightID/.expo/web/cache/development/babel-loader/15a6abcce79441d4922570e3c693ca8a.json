{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { hash } from \"../../../../utils/encoding\";\nimport ChannelAPI from \"../../../../api/channelService\";\nimport { selectBaseUrl } from \"../../../../reducer/settingsSlice\";\nimport { downloadConnections, downloadGroups, downloadSigs, downloadNamePhoto } from \"./channelDownloadThunks\";\nimport { setRecoveryChannel } from \"../recoveryDataSlice\";\nimport { uploadRecoveryData } from \"../../../../utils/recovery\";\nexport var CHANNEL_POLL_INTERVAL = 3000;\nexport var createChannel = function createChannel() {\n  return function _callee(dispatch, getState) {\n    var _getState, recoveryData, baseUrl, url, channelApi, channelId, msg;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _getState = getState(), recoveryData = _getState.recoveryData;\n            baseUrl = selectBaseUrl(getState());\n            url = new URL(baseUrl + \"/profile\");\n            channelApi = new ChannelAPI(url.href);\n            channelId = hash(recoveryData.aesKey);\n            console.log(\"created channel \" + channelId + \" for recovery data\");\n            dispatch(setRecoveryChannel({\n              channelId: channelId,\n              url: url\n            }));\n            _context.next = 10;\n            return _regeneratorRuntime.awrap(uploadRecoveryData(recoveryData, channelApi));\n\n          case 10:\n            console.log(\"Finished uploading recovery data to channel \" + channelId);\n            _context.next = 18;\n            break;\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](0);\n            msg = 'Profile data already exists in channel';\n\n            if (_context.t0.message.startsWith(msg)) {\n              _context.next = 18;\n              break;\n            }\n\n            throw _context.t0;\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 13]], Promise);\n  };\n};\nvar channelIntervalId;\nvar checkInProgress = false;\nexport var pollChannel = function pollChannel() {\n  return function _callee2(dispatch) {\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            clearInterval(channelIntervalId);\n            channelIntervalId = setInterval(function () {\n              if (!checkInProgress) {\n                checkInProgress = true;\n                dispatch(checkChannel()).then(function () {\n                  checkInProgress = false;\n                }).catch(function (err) {\n                  checkInProgress = false;\n                  console.error(\"Error polling recovery channel: \" + err.message);\n                });\n              }\n            }, CHANNEL_POLL_INTERVAL);\n            console.log(\"start polling recovery channel (\" + channelIntervalId);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var clearChannel = function clearChannel() {\n  console.log(\"stop polling recovery channel (\" + channelIntervalId + \")\");\n  clearInterval(channelIntervalId);\n};\nexport var checkChannel = function checkChannel() {\n  return function _callee3(dispatch, getState) {\n    var _getState2, _getState2$recoveryDa, recoveryId, name, _getState2$recoveryDa2, channelId, url, channelApi, dataIds;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _getState2 = getState(), _getState2$recoveryDa = _getState2.recoveryData, recoveryId = _getState2$recoveryDa.id, name = _getState2$recoveryDa.name, _getState2$recoveryDa2 = _getState2$recoveryDa.channel, channelId = _getState2$recoveryDa2.channelId, url = _getState2$recoveryDa2.url;\n            channelApi = new ChannelAPI(url.href);\n            _context3.next = 4;\n            return _regeneratorRuntime.awrap(channelApi.list(channelId));\n\n          case 4:\n            dataIds = _context3.sent;\n\n            if (!recoveryId) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 8;\n            return _regeneratorRuntime.awrap(dispatch(downloadConnections({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 8:\n            _context3.next = 10;\n            return _regeneratorRuntime.awrap(dispatch(downloadGroups({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 10:\n            if (name) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 13;\n            return _regeneratorRuntime.awrap(dispatch(downloadNamePhoto({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 13:\n            _context3.next = 15;\n            return _regeneratorRuntime.awrap(dispatch(downloadSigs({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"names":["hash","ChannelAPI","selectBaseUrl","downloadConnections","downloadGroups","downloadSigs","downloadNamePhoto","setRecoveryChannel","uploadRecoveryData","CHANNEL_POLL_INTERVAL","createChannel","dispatch","getState","recoveryData","baseUrl","url","URL","channelApi","href","channelId","aesKey","console","log","msg","message","startsWith","channelIntervalId","checkInProgress","pollChannel","clearInterval","setInterval","checkChannel","then","catch","err","error","clearChannel","recoveryId","id","name","channel","list","dataIds"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/channelThunks.ts"],"sourcesContent":["import { hash } from '@/utils/encoding';\nimport ChannelAPI from '@/api/channelService';\nimport { selectBaseUrl } from '@/reducer/settingsSlice';\nimport {\n  downloadConnections,\n  downloadGroups,\n  downloadSigs,\n  downloadNamePhoto,\n} from './channelDownloadThunks';\nimport { setRecoveryChannel } from '../recoveryDataSlice';\nimport { uploadRecoveryData } from '@/utils/recovery';\n\n// CONSTANTS\n\nexport const CHANNEL_POLL_INTERVAL = 3000;\n\n// THUNKS\n\nexport const createChannel =\n  () => async (dispatch: dispatch, getState: getState) => {\n    try {\n      const { recoveryData } = getState();\n      const baseUrl = selectBaseUrl(getState());\n      const url = new URL(`${baseUrl}/profile`);\n      // use this for local running profile service\n      // const url = new URL(`http://10.0.2.2:3000/`);\n      const channelApi = new ChannelAPI(url.href);\n      const channelId = hash(recoveryData.aesKey);\n      console.log(`created channel ${channelId} for recovery data`);\n      dispatch(setRecoveryChannel({ channelId, url }));\n      await uploadRecoveryData(recoveryData, channelApi);\n      console.log(`Finished uploading recovery data to channel ${channelId}`);\n    } catch (e) {\n      const msg = 'Profile data already exists in channel';\n      if (!e.message.startsWith(msg)) {\n        throw e;\n      }\n    }\n  };\n\nlet channelIntervalId: IntervalId;\nlet checkInProgress = false;\n\nexport const pollChannel = () => async (dispatch: dispatch) => {\n  clearInterval(channelIntervalId);\n\n  channelIntervalId = setInterval(() => {\n    if (!checkInProgress) {\n      checkInProgress = true;\n      dispatch(checkChannel())\n        .then(() => {\n          checkInProgress = false;\n        })\n        .catch((err) => {\n          checkInProgress = false;\n          console.error(`Error polling recovery channel: ${err.message}`);\n        });\n    }\n  }, CHANNEL_POLL_INTERVAL);\n\n  console.log(`start polling recovery channel (${channelIntervalId}`);\n};\n\nexport const clearChannel = () => {\n  console.log(`stop polling recovery channel (${channelIntervalId})`);\n  clearInterval(channelIntervalId);\n};\n\nexport const checkChannel =\n  () => async (dispatch: dispatch, getState: getState) => {\n    const {\n      recoveryData: {\n        id: recoveryId,\n        name,\n        channel: { channelId, url },\n      },\n    } = getState();\n    const channelApi = new ChannelAPI(url.href);\n    const dataIds = await channelApi.list(channelId);\n\n    if (recoveryId) {\n      // process connections uploaded to the channel\n      // returns true if downloading connecion data this cycle\n      await dispatch(downloadConnections({ channelApi, dataIds }));\n\n      // process groups uploaded to the channel\n      // returns true if downloading group data this cycle\n      await dispatch(downloadGroups({ channelApi, dataIds }));\n\n      if (!name) {\n        await dispatch(downloadNamePhoto({ channelApi, dataIds }));\n      }\n    }\n\n    // process signatures uploaded to the channel\n    // returns true if downloading sigs this cycle\n    await dispatch(downloadSigs({ channelApi, dataIds }));\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}