{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport nacl from 'tweetnacl';\nimport RNFetchBlob from 'rn-fetch-blob';\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport { createSelector } from '@reduxjs/toolkit';\nimport { uInt8ArrayToB64, b64ToUrlSafeB64, urlSafeRandomKey } from \"../utils/encoding\";\nimport { encryptData } from \"../utils/cryptoHelper\";\nimport { selectChannelById } from \"../components/PendingConnections/channelSlice\";\nimport { selectConnectionById, selectAllConnections } from \"../reducer/connectionsSlice\";\nimport { names } from \"../utils/fakeNames\";\nimport { connectFakeUsers } from \"../utils/fakeHelper\";\nimport { retrieveImage } from \"../utils/filesystem\";\nimport { PROFILE_VERSION } from \"../utils/constants\";\nimport { addOperation } from \"../reducer/operationsSlice\";\nimport { connectionLevelStrings } from \"../utils/connectionLevelStrings\";\nexport var selectOtherFakeConnections = createSelector(selectAllConnections, function (_, id) {\n  return id;\n}, function (connections, id) {\n  return connections.filter(function (c) {\n    return c.secretKey && c.id !== id;\n  });\n});\nexport var addFakeConnection = function addFakeConnection() {\n  return function _callee(dispatch, getState) {\n    var _await$nacl$sign$keyP, publicKey, secretKey, b64PubKey, connectId, _names$Math$floor, firstName, lastName, name, photo, photoResponse, channel, dataObj, encrypted, fakeChannel;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            console.log('creating fake user');\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(nacl.sign.keyPair());\n\n          case 4:\n            _await$nacl$sign$keyP = _context.sent;\n            publicKey = _await$nacl$sign$keyP.publicKey;\n            secretKey = _await$nacl$sign$keyP.secretKey;\n            b64PubKey = uInt8ArrayToB64(publicKey);\n            connectId = b64ToUrlSafeB64(b64PubKey);\n            _names$Math$floor = names[Math.floor(Math.random() * (names.length - 1))], firstName = _names$Math$floor.firstName, lastName = _names$Math$floor.lastName;\n            name = firstName + \" \" + lastName;\n            _context.next = 13;\n            return _regeneratorRuntime.awrap(RNFetchBlob.fetch('GET', 'https://loremflickr.com/180/180', {}));\n\n          case 13:\n            photoResponse = _context.sent;\n\n            if (!(photoResponse.info().status === 200)) {\n              _context.next = 18;\n              break;\n            }\n\n            photo = \"data:image/jpeg;base64,\" + String(photoResponse.base64());\n            _context.next = 20;\n            break;\n\n          case 18:\n            Alert.alert('Error', 'Unable to fetch image');\n            return _context.abrupt(\"return\");\n\n          case 20:\n            channel = selectChannelById(getState(), getState().channels.myChannelIds[getState().channels.displayChannelType]);\n            dataObj = {\n              id: connectId,\n              photo: photo,\n              name: name,\n              profileTimestamp: Date.now(),\n              secretKey: uInt8ArrayToB64(secretKey),\n              notificationToken: null,\n              version: PROFILE_VERSION\n            };\n            encrypted = encryptData(dataObj, channel.aesKey);\n            _context.t0 = _objectSpread;\n            _context.t1 = _objectSpread({}, channel);\n            _context.t2 = {};\n            _context.next = 28;\n            return _regeneratorRuntime.awrap(urlSafeRandomKey(9));\n\n          case 28:\n            _context.t3 = _context.sent;\n            _context.t4 = {\n              myProfileId: _context.t3\n            };\n            fakeChannel = (0, _context.t0)(_context.t1, _context.t2, _context.t4);\n            _context.next = 33;\n            return _regeneratorRuntime.awrap(fakeChannel.api.upload({\n              channelId: fakeChannel.id,\n              data: encrypted,\n              dataId: fakeChannel.myProfileId\n            }));\n\n          case 33:\n            _context.next = 38;\n            break;\n\n          case 35:\n            _context.prev = 35;\n            _context.t5 = _context[\"catch\"](0);\n            _context.t5 instanceof Error ? console.log(_context.t5.message) : console.log(_context.t5);\n\n          case 38:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 35]], Promise);\n  };\n};\nexport var connectWithOtherFakeConnections = function connectWithOtherFakeConnections(id, api, level) {\n  return function _callee2(dispatch, getState) {\n    var fakeUser1, otherFakeUsers, _iterator, _step, otherUser, ops, _iterator2, _step2, op;\n\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            fakeUser1 = selectConnectionById(getState(), id);\n\n            if (fakeUser1) {\n              _context2.next = 4;\n              break;\n            }\n\n            console.log(\"Failed to get fake connection id \" + id);\n            return _context2.abrupt(\"return\");\n\n          case 4:\n            if (fakeUser1.secretKey) {\n              _context2.next = 7;\n              break;\n            }\n\n            console.log(\"Fake connection \" + id + \" does not have a secretKey!\");\n            return _context2.abrupt(\"return\");\n\n          case 7:\n            otherFakeUsers = selectOtherFakeConnections(getState(), id);\n            console.log(\"Connecting \" + id + \" with \" + otherFakeUsers.length + \" fake connections as \" + connectionLevelStrings[level]);\n            _iterator = _createForOfIteratorHelperLoose(otherFakeUsers);\n\n          case 10:\n            if ((_step = _iterator()).done) {\n              _context2.next = 18;\n              break;\n            }\n\n            otherUser = _step.value;\n            _context2.next = 14;\n            return _regeneratorRuntime.awrap(connectFakeUsers({\n              id: fakeUser1.id,\n              secretKey: fakeUser1.secretKey\n            }, {\n              id: otherUser.id,\n              secretKey: otherUser.secretKey\n            }, api, level));\n\n          case 14:\n            ops = _context2.sent;\n\n            for (_iterator2 = _createForOfIteratorHelperLoose(ops); !(_step2 = _iterator2()).done;) {\n              op = _step2.value;\n              dispatch(addOperation(op));\n            }\n\n          case 16:\n            _context2.next = 10;\n            break;\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var joinAllGroups = function joinAllGroups(id, api) {\n  return function _callee3(dispatch, getState) {\n    var fakeUser, groups, _iterator3, _step3, group, op;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            fakeUser = selectConnectionById(getState(), id);\n\n            if (fakeUser) {\n              _context3.next = 4;\n              break;\n            }\n\n            console.log(\"Failed to get fake connection id \" + id);\n            return _context3.abrupt(\"return\");\n\n          case 4:\n            if (fakeUser.secretKey) {\n              _context3.next = 7;\n              break;\n            }\n\n            console.log(\"Fake connection \" + id + \" does not have a secretKey!\");\n            return _context3.abrupt(\"return\");\n\n          case 7:\n            groups = getState().groups.groups;\n            _iterator3 = _createForOfIteratorHelperLoose(groups);\n\n          case 9:\n            if ((_step3 = _iterator3()).done) {\n              _context3.next = 17;\n              break;\n            }\n\n            group = _step3.value;\n            _context3.next = 13;\n            return _regeneratorRuntime.awrap(api.joinGroup(group.id, {\n              id: id,\n              secretKey: fakeUser.secretKey\n            }));\n\n          case 13:\n            op = _context3.sent;\n            dispatch(addOperation(op));\n\n          case 15:\n            _context3.next = 9;\n            break;\n\n          case 17:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var reconnectFakeConnection = function reconnectFakeConnection(id, changeProfile) {\n  return function _callee4(dispatch, getState) {\n    var fakeUser1, channel, photo, name, photoResponse, _names$Math$floor2, firstName, lastName, dataObj, encrypted, fakeChannel;\n\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            fakeUser1 = selectConnectionById(getState(), id);\n\n            if (fakeUser1) {\n              _context4.next = 4;\n              break;\n            }\n\n            console.log(\"Failed to get fake connection id \" + id);\n            return _context4.abrupt(\"return\");\n\n          case 4:\n            if (fakeUser1.secretKey) {\n              _context4.next = 7;\n              break;\n            }\n\n            console.log(\"Fake connection \" + id + \" does not have a secretKey!\");\n            return _context4.abrupt(\"return\");\n\n          case 7:\n            channel = selectChannelById(getState(), getState().channels.myChannelIds[getState().channels.displayChannelType]);\n\n            if (channel) {\n              _context4.next = 11;\n              break;\n            }\n\n            Alert.alert('Error', 'No open channel. Go to MyCodeScreen before attempting fake reconnect to have an open channel.');\n            return _context4.abrupt(\"return\");\n\n          case 11:\n            if (!changeProfile) {\n              _context4.next = 25;\n              break;\n            }\n\n            _context4.next = 14;\n            return _regeneratorRuntime.awrap(RNFetchBlob.fetch('GET', 'https://loremflickr.com/180/180', {}));\n\n          case 14:\n            photoResponse = _context4.sent;\n\n            if (!(photoResponse.info().status === 200)) {\n              _context4.next = 19;\n              break;\n            }\n\n            photo = \"data:image/jpeg;base64,\" + String(photoResponse.base64());\n            _context4.next = 21;\n            break;\n\n          case 19:\n            Alert.alert('Error', 'Unable to fetch image');\n            return _context4.abrupt(\"return\");\n\n          case 21:\n            _names$Math$floor2 = names[Math.floor(Math.random() * (names.length - 1))], firstName = _names$Math$floor2.firstName, lastName = _names$Math$floor2.lastName;\n            name = firstName + \" \" + lastName;\n            _context4.next = 29;\n            break;\n\n          case 25:\n            name = fakeUser1.name;\n            _context4.next = 28;\n            return _regeneratorRuntime.awrap(retrieveImage(fakeUser1.photo.filename));\n\n          case 28:\n            photo = _context4.sent;\n\n          case 29:\n            dataObj = {\n              id: id,\n              photo: photo,\n              name: name,\n              profileTimestamp: Date.now(),\n              secretKey: fakeUser1.secretKey,\n              notificationToken: null,\n              version: PROFILE_VERSION\n            };\n            encrypted = encryptData(dataObj, channel.aesKey);\n            _context4.t0 = _objectSpread;\n            _context4.t1 = _objectSpread({}, channel);\n            _context4.t2 = {};\n            _context4.next = 36;\n            return _regeneratorRuntime.awrap(urlSafeRandomKey(9));\n\n          case 36:\n            _context4.t3 = _context4.sent;\n            _context4.t4 = {\n              myProfileId: _context4.t3\n            };\n            fakeChannel = (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t4);\n            _context4.next = 41;\n            return _regeneratorRuntime.awrap(fakeChannel.api.upload({\n              channelId: fakeChannel.id,\n              data: encrypted,\n              dataId: fakeChannel.myProfileId\n            }));\n\n          case 41:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"names":["nacl","RNFetchBlob","createSelector","uInt8ArrayToB64","b64ToUrlSafeB64","urlSafeRandomKey","encryptData","selectChannelById","selectConnectionById","selectAllConnections","names","connectFakeUsers","retrieveImage","PROFILE_VERSION","addOperation","connectionLevelStrings","selectOtherFakeConnections","_","id","connections","filter","c","secretKey","addFakeConnection","dispatch","getState","console","log","sign","keyPair","publicKey","b64PubKey","connectId","Math","floor","random","length","firstName","lastName","name","fetch","photoResponse","info","status","photo","String","base64","Alert","alert","channel","channels","myChannelIds","displayChannelType","dataObj","profileTimestamp","Date","now","notificationToken","version","encrypted","aesKey","myProfileId","fakeChannel","api","upload","channelId","data","dataId","Error","message","connectWithOtherFakeConnections","level","fakeUser1","otherFakeUsers","otherUser","ops","op","joinAllGroups","fakeUser","groups","group","joinGroup","reconnectFakeConnection","changeProfile","filename"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/actions/fakeContact.ts"],"sourcesContent":["import nacl from 'tweetnacl';\nimport RNFetchBlob from 'rn-fetch-blob';\nimport { Alert } from 'react-native';\nimport { createSelector } from '@reduxjs/toolkit';\nimport {\n  uInt8ArrayToB64,\n  b64ToUrlSafeB64,\n  urlSafeRandomKey,\n} from '@/utils/encoding';\nimport { encryptData } from '@/utils/cryptoHelper';\nimport { selectChannelById } from '@/components/PendingConnections/channelSlice';\nimport {\n  selectConnectionById,\n  selectAllConnections,\n} from '@/reducer/connectionsSlice';\nimport { names } from '@/utils/fakeNames';\nimport { connectFakeUsers } from '@/utils/fakeHelper';\nimport { retrieveImage } from '@/utils/filesystem';\nimport { PROFILE_VERSION } from '@/utils/constants';\nimport { addOperation } from '@/reducer/operationsSlice';\nimport { NodeApi } from '@/api/brightId';\nimport { connectionLevelStrings } from '@/utils/connectionLevelStrings';\n\n/** SELECTORS */\n\nexport const selectOtherFakeConnections = createSelector(\n  selectAllConnections,\n  (_: State, id: string) => id,\n  (connections, id) => connections.filter((c) => c.secretKey && c.id !== id),\n);\n\nexport const addFakeConnection =\n  () => async (dispatch: dispatch, getState: getState) => {\n    try {\n      // create a fake user\n      console.log('creating fake user');\n      const { publicKey, secretKey } = await nacl.sign.keyPair();\n      const b64PubKey = uInt8ArrayToB64(publicKey);\n      const connectId = b64ToUrlSafeB64(b64PubKey);\n      const { firstName, lastName } =\n        names[Math.floor(Math.random() * (names.length - 1))];\n      const name = `${firstName} ${lastName}`;\n\n      // load random photo\n      let photo;\n      const photoResponse = await RNFetchBlob.fetch(\n        'GET',\n        'https://loremflickr.com/180/180',\n        {},\n      );\n      if (photoResponse.info().status === 200) {\n        photo = `data:image/jpeg;base64,${String(photoResponse.base64())}`;\n      } else {\n        Alert.alert('Error', 'Unable to fetch image');\n        return;\n      }\n\n      const channel = selectChannelById(\n        getState(),\n        getState().channels.myChannelIds[\n          getState().channels.displayChannelType\n        ],\n      );\n\n      const dataObj: SharedProfile = {\n        id: connectId,\n        photo,\n        name,\n        profileTimestamp: Date.now(),\n        secretKey: uInt8ArrayToB64(secretKey),\n        notificationToken: null,\n        version: PROFILE_VERSION,\n      };\n\n      const encrypted = encryptData(dataObj, channel.aesKey);\n      const fakeChannel = {\n        ...channel,\n        myProfileId: await urlSafeRandomKey(9),\n      };\n\n      await fakeChannel.api.upload({\n        channelId: fakeChannel.id,\n        data: encrypted,\n        dataId: fakeChannel.myProfileId,\n      });\n    } catch (err) {\n      err instanceof Error ? console.log(err.message) : console.log(err);\n    }\n  };\n\nexport const connectWithOtherFakeConnections =\n  (id: string, api: NodeApi, level: ConnectionLevel) =>\n  async (dispatch: dispatch, getState: getState) => {\n    // get fakeUser by ID\n    const fakeUser1 = selectConnectionById(getState(), id);\n\n    if (!fakeUser1) {\n      console.log(`Failed to get fake connection id ${id}`);\n      return;\n    }\n    if (!fakeUser1.secretKey) {\n      console.log(`Fake connection ${id} does not have a secretKey!`);\n      return;\n    }\n\n    // get all other fakeUser that we should connect to\n    const otherFakeUsers = selectOtherFakeConnections(getState(), id);\n\n    console.log(\n      `Connecting ${id} with ${otherFakeUsers.length} fake connections as ${connectionLevelStrings[level]}`,\n    );\n    for (const otherUser of otherFakeUsers) {\n      const ops = await connectFakeUsers(\n        { id: fakeUser1.id, secretKey: fakeUser1.secretKey },\n        { id: otherUser.id, secretKey: otherUser.secretKey },\n        api,\n        level,\n      );\n      for (const op of ops) {\n        dispatch(addOperation(op));\n      }\n    }\n  };\n\nexport const joinAllGroups =\n  (id: string, api: NodeApi) =>\n  async (dispatch: dispatch, getState: getState) => {\n    // get fakeUser by ID\n    const fakeUser = selectConnectionById(getState(), id);\n\n    if (!fakeUser) {\n      console.log(`Failed to get fake connection id ${id}`);\n      return;\n    }\n    if (!fakeUser.secretKey) {\n      console.log(`Fake connection ${id} does not have a secretKey!`);\n      return;\n    }\n\n    // join all groups\n    const { groups } = getState().groups;\n    for (const group of groups) {\n      const op = await api.joinGroup(group.id, {\n        id,\n        secretKey: fakeUser.secretKey,\n      });\n      dispatch(addOperation(op));\n    }\n  };\n\nexport const reconnectFakeConnection =\n  (id: string, changeProfile: boolean) =>\n  async (dispatch: dispatch, getState: getState) => {\n    // get fakeUser by ID\n    const fakeUser1 = selectConnectionById(getState(), id);\n\n    if (!fakeUser1) {\n      console.log(`Failed to get fake connection id ${id}`);\n      return;\n    }\n    if (!fakeUser1.secretKey) {\n      console.log(`Fake connection ${id} does not have a secretKey!`);\n      return;\n    }\n    const channel = selectChannelById(\n      getState(),\n      getState().channels.myChannelIds[getState().channels.displayChannelType],\n    );\n    if (!channel) {\n      Alert.alert(\n        'Error',\n        'No open channel. Go to MyCodeScreen before attempting fake reconnect to have an open channel.',\n      );\n      return;\n    }\n\n    let photo, name;\n    if (changeProfile) {\n      // load a new random photo\n      const photoResponse = await RNFetchBlob.fetch(\n        'GET',\n        'https://loremflickr.com/180/180',\n        {},\n      );\n      if (photoResponse.info().status === 200) {\n        photo = `data:image/jpeg;base64,${String(photoResponse.base64())}`;\n      } else {\n        Alert.alert('Error', 'Unable to fetch image');\n        return;\n      }\n      // create new name\n      const { firstName, lastName } =\n        names[Math.floor(Math.random() * (names.length - 1))];\n      name = `${firstName} ${lastName}`;\n    } else {\n      // use existing photo and name\n      name = fakeUser1.name;\n      // retrieve photo\n      photo = await retrieveImage(fakeUser1.photo.filename);\n    }\n\n    const dataObj = {\n      id,\n      photo,\n      name,\n      profileTimestamp: Date.now(),\n      secretKey: fakeUser1.secretKey,\n      notificationToken: null,\n      version: PROFILE_VERSION,\n    };\n\n    const encrypted = encryptData(dataObj, channel.aesKey);\n    const fakeChannel = { ...channel, myProfileId: await urlSafeRandomKey(9) };\n\n    await fakeChannel.api.upload({\n      channelId: fakeChannel.id,\n      data: encrypted,\n      dataId: fakeChannel.myProfileId,\n    });\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}