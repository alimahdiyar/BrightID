{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { createSlice, createEntityAdapter, createAsyncThunk, createSelector } from '@reduxjs/toolkit';\nimport i18next from 'i18next';\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport { removeChannel, selectChannelById } from \"./channelSlice\";\nimport { selectConnectionById } from \"../../reducer/connectionsSlice\";\nimport { decryptData } from \"../../utils/cryptoHelper\";\nimport { PROFILE_VERSION } from \"../../utils/constants\";\nimport { createDeepEqualStringArraySelector } from \"../../utils/createDeepEqualStringArraySelector\";\nimport BrightidError, { USER_NOT_FOUND } from \"../../api/brightidError\";\nvar pendingConnectionsAdapter = createEntityAdapter({\n  selectId: function selectId(pendingConnection) {\n    return pendingConnection.profileId;\n  }\n});\nexport var pendingConnection_states;\n\n(function (pendingConnection_states) {\n  pendingConnection_states[\"INITIAL\"] = \"INITIAL\";\n  pendingConnection_states[\"DOWNLOADING\"] = \"DOWNLOADING\";\n  pendingConnection_states[\"UNCONFIRMED\"] = \"UNCONFIRMED\";\n  pendingConnection_states[\"CONFIRMING\"] = \"CONFIRMING\";\n  pendingConnection_states[\"CONFIRMED\"] = \"CONFIRMED\";\n  pendingConnection_states[\"ERROR\"] = \"ERROR\";\n  pendingConnection_states[\"MYSELF\"] = \"MYSELF\";\n  pendingConnection_states[\"EXPIRED\"] = \"EXPIRED\";\n})(pendingConnection_states || (pendingConnection_states = {}));\n\nexport var newPendingConnection = createAsyncThunk('pendingConnections/newPendingConnection', function _callee(_ref, _ref2) {\n  var channelId, profileId, api, getState, channel, profileData, sharedProfile, msg, _msg, alreadyPending, existingConnection, profileInfo, pendingConnectionData;\n\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          channelId = _ref.channelId, profileId = _ref.profileId, api = _ref.api;\n          getState = _ref2.getState;\n          console.log(\"new pending connection \" + profileId + \" in channel \" + channelId);\n          channel = selectChannelById(getState(), channelId);\n\n          if (channel) {\n            _context.next = 6;\n            break;\n          }\n\n          throw new Error('Channel does not exist');\n\n        case 6:\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(channel.api.download({\n            channelId: channelId,\n            dataId: profileId\n          }));\n\n        case 8:\n          profileData = _context.sent;\n          sharedProfile = decryptData(profileData, channel.aesKey);\n\n          if (!(sharedProfile.version === undefined || sharedProfile.version < PROFILE_VERSION)) {\n            _context.next = 16;\n            break;\n          }\n\n          msg = i18next.t('pendingConnection.alert.text.otherOutdated', {\n            name: \"\" + sharedProfile.name\n          });\n          Alert.alert(i18next.t('pendingConnection.alert.title.connectionImpossible'), msg);\n          throw new Error(msg);\n\n        case 16:\n          if (!(sharedProfile.version > PROFILE_VERSION)) {\n            _context.next = 20;\n            break;\n          }\n\n          _msg = i18next.t('pendingConnection.alert.text.localOutdated', {\n            name: \"\" + sharedProfile.name\n          });\n          Alert.alert(i18next.t('pendingConnection.alert.title.connectionImpossible'), _msg);\n          throw new Error(_msg);\n\n        case 20:\n          alreadyPending = selectAllUnconfirmedConnections(getState()).find(function (pc) {\n            return sharedProfile.id === pc.pendingConnectionData.sharedProfile.id;\n          });\n\n          if (!alreadyPending) {\n            _context.next = 23;\n            break;\n          }\n\n          throw new Error(\"PendingConnection \" + profileId + \": BrightId \" + sharedProfile.id + \" is already existing.\");\n\n        case 23:\n          existingConnection = selectConnectionById(getState(), sharedProfile.id);\n\n          if (existingConnection) {\n            console.log(sharedProfile.id + \" exists.\");\n          }\n\n          _context.prev = 25;\n          _context.next = 28;\n          return _regeneratorRuntime.awrap(api.getProfile(sharedProfile.id));\n\n        case 28:\n          profileInfo = _context.sent;\n          _context.next = 39;\n          break;\n\n        case 31:\n          _context.prev = 31;\n          _context.t0 = _context[\"catch\"](25);\n\n          if (!(_context.t0 instanceof BrightidError && _context.t0.errorNum === USER_NOT_FOUND)) {\n            _context.next = 38;\n            break;\n          }\n\n          if (!existingConnection) {\n            _context.next = 36;\n            break;\n          }\n\n          throw new Error(\"PendingConnection \" + profileId + \": User already connected, but unknown in node api.\");\n\n        case 36:\n          _context.next = 39;\n          break;\n\n        case 38:\n          throw _context.t0;\n\n        case 39:\n          pendingConnectionData = {\n            sharedProfile: sharedProfile,\n            profileInfo: profileInfo,\n            existingConnection: existingConnection,\n            myself: sharedProfile.id === getState().user.id\n          };\n          return _context.abrupt(\"return\", pendingConnectionData);\n\n        case 41:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[25, 31]], Promise);\n});\nvar initialState = pendingConnectionsAdapter.getInitialState();\nvar pendingConnectionsSlice = createSlice({\n  name: 'pendingConnections',\n  initialState: initialState,\n  reducers: {\n    addFakePendingConnection: pendingConnectionsAdapter.addOne,\n    removePendingConnection: pendingConnectionsAdapter.removeOne,\n    updatePendingConnection: pendingConnectionsAdapter.updateOne,\n    removeAllPendingConnections: pendingConnectionsAdapter.removeAll,\n    confirmPendingConnection: function confirmPendingConnection(state, action) {\n      var id = action.payload;\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: id,\n        changes: {\n          state: pendingConnection_states.CONFIRMED\n        }\n      });\n    }\n  },\n  extraReducers: function extraReducers(builder) {\n    builder.addCase(newPendingConnection.pending, function (state, action) {\n      state = pendingConnectionsAdapter.addOne(state, {\n        profileId: action.meta.arg.profileId,\n        channelId: action.meta.arg.channelId,\n        state: pendingConnection_states.DOWNLOADING\n      });\n    }).addCase(newPendingConnection.rejected, function (state, action) {\n      console.log(\"Error adding pending connection:\");\n      console.log(action.error.message);\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: action.meta.arg.profileId,\n        changes: {\n          state: pendingConnection_states.ERROR\n        }\n      });\n    }).addCase(newPendingConnection.fulfilled, function (state, _ref3) {\n      var meta = _ref3.meta,\n          payload = _ref3.payload;\n      var profileId = meta.arg.profileId;\n      var changes = {\n        state: payload.myself ? pendingConnection_states.MYSELF : pendingConnection_states.UNCONFIRMED,\n        pendingConnectionData: payload\n      };\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: profileId,\n        changes: changes\n      });\n    }).addCase(removeChannel, function (state, action) {\n      var channelId = action.payload;\n      var deleteIds = state.ids.filter(function (id) {\n        return state.entities[id].channelId === channelId;\n      });\n      console.log(\"Channel \" + channelId + \" deleted - removing \" + deleteIds.length + \" pending connections associated to channel\");\n      state = pendingConnectionsAdapter.removeMany(state, deleteIds);\n    });\n  }\n});\n\nvar _pendingConnectionsAd = pendingConnectionsAdapter.getSelectors(function (state) {\n  return state.pendingConnections;\n}),\n    selectAllPendingConnections = _pendingConnectionsAd.selectAll,\n    selectPendingConnectionById = _pendingConnectionsAd.selectById,\n    selectAllPendingConnectionIds = _pendingConnectionsAd.selectIds;\n\nexport { selectAllPendingConnections, selectPendingConnectionById, selectAllPendingConnectionIds };\nexport var selectAllUnconfirmedConnections = createSelector(selectAllPendingConnections, function (pendingConnections) {\n  return pendingConnections.filter(function (pc) {\n    return pc.state === pendingConnection_states.UNCONFIRMED;\n  });\n});\nexport var selectPendingConnectionByBrightId = createSelector(selectAllPendingConnections, function (_, brightId) {\n  return brightId;\n}, function (pendingConnections, brightId) {\n  return pendingConnections.find(function (pc) {\n    return brightId === pc.brightId;\n  });\n});\nexport var selectAllPendingConnectionsByChannelIds = createDeepEqualStringArraySelector(selectAllPendingConnections, function (_, channelIds) {\n  return channelIds;\n}, function (pendingConnections, channelIds) {\n  console.log(\"selectAllPendingConnectionsByChannelIds \" + channelIds + \"...\");\n  return pendingConnections.filter(function (pc) {\n    return channelIds.includes(pc.channelId);\n  });\n});\nexport var selectAllUnconfirmedConnectionsByChannelIds = createDeepEqualStringArraySelector(selectAllUnconfirmedConnections, function (_, channelIds) {\n  return channelIds;\n}, function (pendingConnections, channelIds) {\n  console.log(\"selectAllUnconfirmedConnectionsByChannelIds \" + channelIds + \"...\");\n  return pendingConnections.filter(function (pc) {\n    return channelIds.includes(pc.channelId);\n  });\n});\nvar _pendingConnectionsSl = pendingConnectionsSlice.actions,\n    updatePendingConnection = _pendingConnectionsSl.updatePendingConnection,\n    removePendingConnection = _pendingConnectionsSl.removePendingConnection,\n    removeAllPendingConnections = _pendingConnectionsSl.removeAllPendingConnections,\n    confirmPendingConnection = _pendingConnectionsSl.confirmPendingConnection,\n    addFakePendingConnection = _pendingConnectionsSl.addFakePendingConnection;\nexport { updatePendingConnection, removePendingConnection, removeAllPendingConnections, confirmPendingConnection, addFakePendingConnection };\nexport default pendingConnectionsSlice.reducer;","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/pendingConnectionSlice.ts"],"names":["pendingConnectionsAdapter","createEntityAdapter","selectId","pendingConnection","pendingConnection_states","newPendingConnection","createAsyncThunk","channelId","profileId","api","getState","console","channel","selectChannelById","profileData","dataId","sharedProfile","decryptData","msg","i18next","name","Alert","alreadyPending","selectAllUnconfirmedConnections","pc","existingConnection","selectConnectionById","profileInfo","pendingConnectionData","myself","initialState","pendingConnectionsSlice","createSlice","reducers","addFakePendingConnection","removePendingConnection","updatePendingConnection","removeAllPendingConnections","confirmPendingConnection","id","action","state","changes","extraReducers","builder","meta","payload","deleteIds","selectAllPendingConnections","selectPendingConnectionById","selectAllPendingConnectionIds","createSelector","pendingConnections","selectPendingConnectionByBrightId","brightId","selectAllPendingConnectionsByChannelIds","createDeepEqualStringArraySelector","channelIds","selectAllUnconfirmedConnectionsByChannelIds"],"mappings":"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","sourcesContent":["import {\n  createSlice,\n  createEntityAdapter,\n  createAsyncThunk,\n  createSelector,\n  PayloadAction,\n} from '@reduxjs/toolkit';\nimport i18next from 'i18next';\nimport { Alert } from 'react-native';\nimport {\n  removeChannel,\n  selectChannelById,\n} from '@/components/PendingConnections/channelSlice';\nimport { selectConnectionById } from '@/reducer/connectionsSlice';\nimport { decryptData } from '@/utils/cryptoHelper';\nimport { PROFILE_VERSION } from '@/utils/constants';\nimport { createDeepEqualStringArraySelector } from '@/utils/createDeepEqualStringArraySelector';\nimport BrightidError, { USER_NOT_FOUND } from '@/api/brightidError';\nimport { NodeApi } from '@/api/brightId';\n\nconst pendingConnectionsAdapter = createEntityAdapter<PendingConnection>({\n  selectId: (pendingConnection) => pendingConnection.profileId,\n});\n\n/*\n  PendingConnection slice contains all pending connections and their profile info\n\n  What is a pendingConnection:\n   - 'id': unique id of this pending connection. Is also profileId on the profile server.\n   - 'channelId': channel this pendingConnection is associated with\n   - 'state': state of this pending connection (valid states TBD)\n   - 'brightId': the brightId if the connection\n   - 'name'\n   - 'photo' (base64-encoded)\n */\nexport enum pendingConnection_states {\n  INITIAL = 'INITIAL',\n  DOWNLOADING = 'DOWNLOADING',\n  UNCONFIRMED = 'UNCONFIRMED',\n  CONFIRMING = 'CONFIRMING',\n  CONFIRMED = 'CONFIRMED',\n  ERROR = 'ERROR',\n  MYSELF = 'MYSELF',\n  EXPIRED = 'EXPIRED',\n}\n\nexport const newPendingConnection = createAsyncThunk<\n  PendingConnectionData,\n  { channelId: string; profileId: string; api: NodeApi },\n  { state: State }\n>(\n  'pendingConnections/newPendingConnection',\n  async ({ channelId, profileId, api }, { getState }) => {\n    console.log(`new pending connection ${profileId} in channel ${channelId}`);\n\n    const channel = selectChannelById(getState(), channelId);\n\n    if (!channel) {\n      throw new Error('Channel does not exist');\n    }\n\n    // download profile\n    const profileData: string = await channel.api.download({\n      channelId,\n      dataId: profileId,\n    });\n\n    const sharedProfile = decryptData(\n      profileData,\n      channel.aesKey,\n    ) as SharedProfile;\n\n    // compare profile version\n    if (\n      sharedProfile.version === undefined || // very old client version\n      sharedProfile.version < PROFILE_VERSION // old client version\n    ) {\n      // other user needs to update his client\n      const msg = i18next.t('pendingConnection.alert.text.otherOutdated', {\n        name: `${sharedProfile.name}`,\n      });\n      Alert.alert(\n        i18next.t('pendingConnection.alert.title.connectionImpossible'),\n        msg,\n      );\n      throw new Error(msg);\n    } else if (sharedProfile.version > PROFILE_VERSION) {\n      // I need to update my client\n      const msg = i18next.t('pendingConnection.alert.text.localOutdated', {\n        name: `${sharedProfile.name}`,\n      });\n      Alert.alert(\n        i18next.t('pendingConnection.alert.title.connectionImpossible'),\n        msg,\n      );\n      throw new Error(msg);\n    }\n    // Is this brightID already in the list of unconfirmed pending connections? Can happen if the same user joins a\n    // channel multiple times (e.g. if users app crashed)\n    const alreadyPending = selectAllUnconfirmedConnections(getState()).find(\n      (pc) => sharedProfile.id === pc.pendingConnectionData.sharedProfile.id,\n    );\n    if (alreadyPending) {\n      throw new Error(\n        `PendingConnection ${profileId}: BrightId ${sharedProfile.id} is already existing.`,\n      );\n    }\n\n    // Is this a known connection reconnecting?\n    const existingConnection = selectConnectionById(\n      getState(),\n      sharedProfile.id,\n    );\n    if (existingConnection) {\n      console.log(`${sharedProfile.id} exists.`);\n    }\n\n    let profileInfo: ProfileInfo;\n    try {\n      profileInfo = await api.getProfile(sharedProfile.id);\n    } catch (err) {\n      if (err instanceof BrightidError && err.errorNum === USER_NOT_FOUND) {\n        // this must be a new user not yet existing on backend.\n        if (existingConnection) {\n          // handle edge case:\n          // The other user is not known in the backend, but already connected with us. This should never happen :/\n          // Since profileInfo is required for reconnecting we can not start the reconnect flow.\n          throw new Error(\n            `PendingConnection ${profileId}: User already connected, but unknown in node api.`,\n          );\n        }\n      } else {\n        throw err;\n      }\n    }\n\n    const pendingConnectionData: PendingConnectionData = {\n      sharedProfile,\n      profileInfo,\n      existingConnection,\n      myself: sharedProfile.id === getState().user.id,\n    };\n    return pendingConnectionData;\n  },\n);\n\n// By default, `createEntityAdapter` gives you `{ ids: [], entities: {} }`.\n// If you want to track 'loading' or other keys, you would initialize them here:\n// `getInitialState({ loading: false, activeRequestId: null })`\nconst initialState = pendingConnectionsAdapter.getInitialState();\n\nconst pendingConnectionsSlice = createSlice({\n  name: 'pendingConnections',\n  initialState,\n  reducers: {\n    addFakePendingConnection: pendingConnectionsAdapter.addOne,\n    removePendingConnection: pendingConnectionsAdapter.removeOne,\n    updatePendingConnection: pendingConnectionsAdapter.updateOne,\n    removeAllPendingConnections: pendingConnectionsAdapter.removeAll,\n    confirmPendingConnection(state, action: PayloadAction<string>) {\n      const id = action.payload;\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id,\n        changes: {\n          state: pendingConnection_states.CONFIRMED,\n        },\n      });\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(newPendingConnection.pending, (state, action) => {\n        // This is called before actual thunk code is executed. Thunk argument is available via\n        // action.meta.arg.\n\n        // Add pending connection in DOWNLOADING state.\n        state = pendingConnectionsAdapter.addOne(state, {\n          profileId: action.meta.arg.profileId,\n          channelId: action.meta.arg.channelId,\n          state: pendingConnection_states.DOWNLOADING,\n        });\n      })\n      .addCase(newPendingConnection.rejected, (state, action) => {\n        // This is called if anything goes wrong\n        console.log(`Error adding pending connection:`);\n        console.log(action.error.message);\n\n        state = pendingConnectionsAdapter.updateOne(state, {\n          id: action.meta.arg.profileId,\n          changes: {\n            state: pendingConnection_states.ERROR,\n          },\n        });\n      })\n      .addCase(newPendingConnection.fulfilled, (state, { meta, payload }) => {\n        // thunk arguments are available via action.meta.arg:\n        const { profileId } = meta.arg;\n\n        // data returned by thunk is available via action.payload:\n        const changes: Partial<PendingConnection> = {\n          state: payload.myself\n            ? pendingConnection_states.MYSELF\n            : pendingConnection_states.UNCONFIRMED,\n          pendingConnectionData: payload,\n        };\n\n        // Perform the update in redux\n        state = pendingConnectionsAdapter.updateOne(state, {\n          id: profileId,\n          changes,\n        });\n      })\n      .addCase(removeChannel, (state, action) => {\n        const channelId = action.payload;\n        const deleteIds = state.ids.filter(\n          (id) => state.entities[id].channelId === channelId,\n        );\n        console.log(\n          `Channel ${channelId} deleted - removing ${deleteIds.length} pending connections associated to channel`,\n        );\n        state = pendingConnectionsAdapter.removeMany(state, deleteIds);\n      });\n  },\n});\n\n// export selectors\n\nexport const {\n  selectAll: selectAllPendingConnections,\n  selectById: selectPendingConnectionById,\n  selectIds: selectAllPendingConnectionIds,\n} = pendingConnectionsAdapter.getSelectors(\n  (state: State) => state.pendingConnections,\n);\n\nexport const selectAllUnconfirmedConnections = createSelector(\n  selectAllPendingConnections,\n  (pendingConnections) =>\n    pendingConnections.filter(\n      (pc) => pc.state === pendingConnection_states.UNCONFIRMED,\n    ),\n);\n\nexport const selectPendingConnectionByBrightId = createSelector(\n  selectAllPendingConnections,\n  (_, brightId: string) => brightId,\n  (pendingConnections, brightId) => {\n    return pendingConnections.find((pc) => brightId === pc.brightId);\n  },\n);\n\n/*\n  Using DeepEqualStringArraySelector here because there are different inputs:\n  - selectAllPendingConnections/selectAllUnconfirmedConnections:\n    Returns an array of objects directly from state. This is immutable, so we can use\n    referential equality check.\n  - channelIds:\n    This array is created dynamically and will be a new object with each invocation. Therefore\n    we have to use deep equality check\n */\nexport const selectAllPendingConnectionsByChannelIds =\n  createDeepEqualStringArraySelector(\n    selectAllPendingConnections,\n    (_, channelIds: string[]) => channelIds,\n    (pendingConnections, channelIds) => {\n      console.log(`selectAllPendingConnectionsByChannelIds ${channelIds}...`);\n      return pendingConnections.filter((pc) =>\n        channelIds.includes(pc.channelId),\n      );\n    },\n  );\nexport const selectAllUnconfirmedConnectionsByChannelIds =\n  createDeepEqualStringArraySelector(\n    selectAllUnconfirmedConnections,\n    (_, channelIds: string[]) => channelIds,\n    (pendingConnections, channelIds) => {\n      console.log(\n        `selectAllUnconfirmedConnectionsByChannelIds ${channelIds}...`,\n      );\n      return pendingConnections.filter((pc) =>\n        channelIds.includes(pc.channelId),\n      );\n    },\n  );\n\n// export actions\n\nexport const {\n  updatePendingConnection,\n  removePendingConnection,\n  removeAllPendingConnections,\n  confirmPendingConnection,\n  addFakePendingConnection,\n} = pendingConnectionsSlice.actions;\n\nexport default pendingConnectionsSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}