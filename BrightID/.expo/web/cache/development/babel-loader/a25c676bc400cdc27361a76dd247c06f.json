{"ast":null,"code":"import { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nimport createResponderEvent from \"./createResponderEvent\";\nimport { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from \"./ResponderEventTypes\";\nimport { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from \"./utils\";\nimport ResponderTouchHistoryStore from \"./ResponderTouchHistoryStore\";\nvar emptyObject = {};\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n\n  if (eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  var isMoveEvent = isMoveish(eventType);\n  var isEndEvent = isEndish(eventType);\n  var isScrollEvent = isScroll(eventType);\n  var isSelectionChangeEvent = isSelectionChange(eventType);\n  var responderEvent = createResponderEvent(domEvent);\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n\n  var eventPaths = getResponderPaths(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = isCancelish(eventType) || eventType === 'contextmenu' || eventType === 'blur' && eventTarget === window || eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || isScrollEvent && trackedTouchCount === 0 || isScrollEvent && eventTarget.contains(node) && eventTarget !== node || isSelectionChangeEvent && hasValidSelection(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n\n        changeCurrentResponder(emptyResponder);\n      }\n\n      if (isTerminateEvent) {\n        var shouldTerminate = true;\n\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n\n        if (shouldSetCallback(responderEvent) === true) {\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id: id,\n            node: node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    };\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n        onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n    var allowTransfer = true;\n\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n\n    if (allowTransfer) {\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n\n      changeCurrentResponder(wantsResponder);\n    } else {\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = ['mousedown', 'mousemove', 'mouseup', 'dragstart', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'contextmenu', 'select', 'selectionchange'];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\nexport function addNode(id, node, config) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\nexport function removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\nexport function terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = createResponderEvent({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\nexport function getResponderNode() {\n  return currentResponder.node;\n}","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/node_modules/react-native-web/src/modules/useResponderEvents/ResponderSystem.js"],"names":["emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","isEmulatingMouseEvents","trackedTouchCount","currentResponder","config","eventType","domEvent","eventTarget","isStartEvent","isStartish","isPrimaryPointerDown","isMoveEvent","isMoveish","isEndEvent","isEndish","isScrollEvent","isScroll","isSelectionChangeEvent","isSelectionChange","responderEvent","createResponderEvent","ResponderTouchHistoryStore","eventPaths","getResponderPaths","wasNegotiated","currentResponderIdPath","eventIdPath","lowestCommonAncestor","getLowestCommonAncestor","indexOfLowestCommonAncestor","index","nodePath","wantsResponder","findWantsResponder","attemptTransfer","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","getResponderConfig","isTerminateEvent","isCancelish","hasValidSelection","isReleaseEvent","hasTargetTouches","changeCurrentResponder","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","shouldSetCallback","prunedIdPath","i","result","target","currentId","currentNode","onResponderGrant","onResponderReject","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","canUseDOM","window","document","setResponderId","terminateResponder","event"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\nimport type { ResponderEvent } from './createResponderEvent';\n\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nimport createResponderEvent from './createResponderEvent';\nimport {\n  isCancelish,\n  isEndish,\n  isMoveish,\n  isScroll,\n  isSelectionChange,\n  isStartish\n} from './ResponderEventTypes';\nimport {\n  getLowestCommonAncestor,\n  getResponderPaths,\n  hasTargetTouches,\n  hasValidSelection,\n  isPrimaryPointerDown,\n  setResponderId\n} from './utils';\nimport ResponderTouchHistoryStore from './ResponderTouchHistoryStore';\n\n/* ------------ TYPES ------------ */\n\ntype ResponderId = number;\n\ntype ActiveResponderInstance = {\n  id: ResponderId,\n  idPath: Array<number>,\n  node: any\n};\n\ntype EmptyResponderInstance = {\n  id: null,\n  idPath: null,\n  node: null\n};\n\ntype ResponderInstance = ActiveResponderInstance | EmptyResponderInstance;\n\nexport type ResponderConfig = {\n  // Direct responder events dispatched directly to responder. Do not bubble.\n  onResponderEnd?: ?(e: ResponderEvent) => void,\n  onResponderGrant?: ?(e: ResponderEvent) => void | boolean,\n  onResponderMove?: ?(e: ResponderEvent) => void,\n  onResponderRelease?: ?(e: ResponderEvent) => void,\n  onResponderReject?: ?(e: ResponderEvent) => void,\n  onResponderStart?: ?(e: ResponderEvent) => void,\n  onResponderTerminate?: ?(e: ResponderEvent) => void,\n  onResponderTerminationRequest?: ?(e: ResponderEvent) => boolean,\n  // On pointer down, should this element become the responder?\n  onStartShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onStartShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On pointer move, should this element become the responder?\n  onMoveShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onMoveShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On scroll, should this element become the responder? Do no bubble\n  onScrollShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onScrollShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On text selection change, should this element become the responder?\n  onSelectionChangeShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onSelectionChangeShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean\n};\n\nconst emptyObject = {};\n\n/* ------------ IMPLEMENTATION ------------ */\n\nconst startRegistration = [\n  'onStartShouldSetResponderCapture',\n  'onStartShouldSetResponder',\n  { bubbles: true }\n];\nconst moveRegistration = [\n  'onMoveShouldSetResponderCapture',\n  'onMoveShouldSetResponder',\n  { bubbles: true }\n];\nconst scrollRegistration = [\n  'onScrollShouldSetResponderCapture',\n  'onScrollShouldSetResponder',\n  { bubbles: false }\n];\nconst shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\n\nconst emptyResponder = { id: null, idPath: null, node: null };\nconst responderListenersMap = new Map();\n\nlet isEmulatingMouseEvents = false;\nlet trackedTouchCount = 0;\nlet currentResponder: ResponderInstance = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder: ResponderInstance) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id: ResponderId): ResponderConfig | Object {\n  const config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\nfunction eventListener(domEvent: any) {\n  const eventType = domEvent.type;\n  const eventTarget = domEvent.target;\n\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n\n  // Flag when browser may produce emulated events\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n  // Remove flag when browser will not produce emulated events\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  // Ignore various events in particular circumstances\n  if (\n    // Ignore browser emulated mouse events\n    (eventType === 'mousedown' && isEmulatingMouseEvents) ||\n    (eventType === 'mousemove' && isEmulatingMouseEvents) ||\n    // Ignore mousemove if a mousedown didn't occur first\n    (eventType === 'mousemove' && trackedTouchCount < 1)\n  ) {\n    return;\n  }\n  // Remove flag after emulated events are finished\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n\n  const isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  const isMoveEvent = isMoveish(eventType);\n  const isEndEvent = isEndish(eventType);\n  const isScrollEvent = isScroll(eventType);\n  const isSelectionChangeEvent = isSelectionChange(eventType);\n  const responderEvent = createResponderEvent(domEvent);\n\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    ResponderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n\n  /**\n   * Responder System logic\n   */\n\n  let eventPaths = getResponderPaths(domEvent);\n  let wasNegotiated = false;\n  let wantsResponder;\n\n  // If an event occured that might change the current responder...\n  if (isStartEvent || isMoveEvent || (isScrollEvent && trackedTouchCount > 0)) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    const currentResponderIdPath = currentResponder.idPath;\n    const eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      const lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        const indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n        const index =\n          indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n  // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n  if (currentResponder.id != null && currentResponder.node != null) {\n    const { id, node } = currentResponder;\n    const {\n      onResponderStart,\n      onResponderMove,\n      onResponderEnd,\n      onResponderRelease,\n      onResponderTerminate,\n      onResponderTerminationRequest\n    } = getResponderConfig(id);\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    // Start\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    }\n    // Move\n    else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n        onResponderMove(responderEvent);\n      }\n    } else {\n      const isTerminateEvent =\n        isCancelish(eventType) ||\n        // native context menu\n        eventType === 'contextmenu' ||\n        // window blur\n        (eventType === 'blur' && eventTarget === window) ||\n        // responder (or ancestors) blur\n        (eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node) ||\n        // native scroll without using a pointer\n        (isScrollEvent && trackedTouchCount === 0) ||\n        // native scroll on node that is parent of the responder (allow siblings to scroll)\n        (isScrollEvent && eventTarget.contains(node) && eventTarget !== node) ||\n        // native select/selectionchange on node\n        (isSelectionChangeEvent && hasValidSelection(domEvent));\n\n      const isReleaseEvent =\n        isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n\n      // End\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n          onResponderEnd(responderEvent);\n        }\n      }\n      // Release\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      // Terminate\n      if (isTerminateEvent) {\n        let shouldTerminate = true;\n\n        // Responders can still avoid termination but only for these events.\n        if (\n          eventType === 'contextmenu' ||\n          eventType === 'scroll' ||\n          eventType === 'selectionchange'\n        ) {\n          // Only call this function is it wasn't already called during negotiation.\n          if (wasNegotiated) {\n            shouldTerminate = false;\n          } else if (onResponderTerminationRequest != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n            if (onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  const shouldSetCallbacks = shouldSetResponderEvents[(domEvent.type: any)]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    const { idPath, nodePath } = eventPaths;\n\n    const shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    const shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    const { bubbles } = shouldSetCallbacks[2];\n\n    const check = function (id, node, callbackName) {\n      const config = getResponderConfig(id);\n      const shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n        if (shouldSetCallback(responderEvent) === true) {\n          // Start the path from the potential responder\n          const prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return { id, node, idPath: prunedIdPath };\n        }\n      }\n    };\n\n    // capture\n    for (let i = idPath.length - 1; i >= 0; i--) {\n      const id = idPath[i];\n      const node = nodePath[i];\n      const result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n    // bubble\n    if (bubbles) {\n      for (let i = 0; i < idPath.length; i++) {\n        const id = idPath[i];\n        const node = nodePath[i];\n        const result = check(id, node, shouldSetCallbackBubbleName);\n        if (result != null) {\n          return result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      const id = idPath[0];\n      const node = nodePath[0];\n      const target = domEvent.target;\n      if (target === node) {\n        return check(id, node, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\n/**\n * Attempt to transfer the responder.\n */\nfunction attemptTransfer(responderEvent: ResponderEvent, wantsResponder: ActiveResponderInstance) {\n  const { id: currentId, node: currentNode } = currentResponder;\n  const { id, node } = wantsResponder;\n\n  const { onResponderGrant, onResponderReject } = getResponderConfig(id);\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n\n  // Set responder\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  }\n  // Negotiate with current responder\n  else {\n    const { onResponderTerminate, onResponderTerminationRequest } = getResponderConfig(currentId);\n\n    let allowTransfer = true;\n    if (onResponderTerminationRequest != null) {\n      responderEvent.currentTarget = currentNode;\n      responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n      if (onResponderTerminationRequest(responderEvent) === false) {\n        allowTransfer = false;\n      }\n    }\n\n    if (allowTransfer) {\n      // Terminate existing responder\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n        onResponderTerminate(responderEvent);\n      }\n      // Grant next responder\n      if (onResponderGrant != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      // Reject responder request\n      if (onResponderReject != null) {\n        responderEvent.currentTarget = node;\n        responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\nconst documentEventsCapturePhase = ['blur', 'scroll'];\nconst documentEventsBubblePhase = [\n  // mouse\n  'mousedown',\n  'mousemove',\n  'mouseup',\n  'dragstart',\n  // touch\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n  // other\n  'contextmenu',\n  'select',\n  'selectionchange'\n];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach((eventType) => {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach((eventType) => {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n\n/**\n * Register a node with the ResponderSystem.\n */\nexport function addNode(id: ResponderId, node: any, config: ResponderConfig) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\n\n/**\n * Unregister a node with the ResponderSystem.\n */\nexport function removeNode(id: ResponderId) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\nexport function terminateResponder() {\n  const { id, node } = currentResponder;\n  if (id != null && node != null) {\n    const { onResponderTerminate } = getResponderConfig(id);\n    if (onResponderTerminate != null) {\n      const event = createResponderEvent({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\nexport function getResponderNode(): any {\n  return currentResponder.node;\n}\n"]},"metadata":{},"sourceType":"module"}