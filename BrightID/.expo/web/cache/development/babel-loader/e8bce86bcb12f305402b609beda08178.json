{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport * as queryString from 'query-string';\nimport checkLegacyPathConfig from \"./checkLegacyPathConfig\";\n\nvar getActiveRoute = function getActiveRoute(state) {\n  var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\nexport default function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  var _checkLegacyPathConfi = checkLegacyPathConfig(options),\n      _checkLegacyPathConfi2 = _slicedToArray(_checkLegacyPathConfi, 2),\n      legacy = _checkLegacyPathConfi2[0],\n      compatOptions = _checkLegacyPathConfi2[1];\n\n  var configs = compatOptions ? createNormalizedConfigs(legacy, compatOptions.screens) : {};\n  var path = '/';\n  var current = state;\n  var allParams = {};\n\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var pattern = void 0;\n    var focusedParams = void 0;\n    var focusedRoute = getActiveRoute(state);\n    var currentOptions = configs;\n    var nestedRouteNames = [];\n    var hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        (function () {\n          var stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n          var currentParams = fromEntries(Object.entries(route.params).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                key = _ref2[0],\n                value = _ref2[1];\n\n            return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];\n          }));\n\n          if (pattern) {\n            _extends(allParams, currentParams);\n          }\n\n          if (focusedRoute === route) {\n            focusedParams = _objectSpread({}, currentParams);\n            (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(function (p) {\n              return p.startsWith(':');\n            }).forEach(function (p) {\n              var name = getParamName(p);\n\n              if (focusedParams) {\n                delete focusedParams[name];\n              }\n            });\n          }\n        })();\n      }\n\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(function (p) {\n        var name = getParamName(p);\n\n        if (p === '*') {\n          if (legacy) {\n            throw new Error(\"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/5.x/configuring-links/#updating-config\");\n          }\n\n          return route.name;\n        }\n\n        if (p.startsWith(':')) {\n          var value = allParams[name];\n\n          if (value === undefined && p.endsWith('?')) {\n            return '';\n          }\n\n          return encodeURIComponent(value);\n        }\n\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (var param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          delete focusedParams[param];\n        }\n      }\n\n      var query = queryString.stringify(focusedParams);\n\n      if (query) {\n        path += \"?\".concat(query);\n      }\n    }\n\n    current = route.state;\n  };\n\n  while (current) {\n    var _currentOptions$route;\n\n    var _pattern;\n\n    _loop();\n  }\n\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\n\nvar fromEntries = function fromEntries(entries) {\n  return entries.reduce(function (acc, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        k = _ref4[0],\n        v = _ref4[1];\n\n    if (acc.hasOwnProperty(k)) {\n      throw new Error(\"A value for key '\".concat(k, \"' already exists in the object.\"));\n    }\n\n    acc[k] = v;\n    return acc;\n  }, {});\n};\n\nvar getParamName = function getParamName(pattern) {\n  return pattern.replace(/^:/, '').replace(/\\?$/, '');\n};\n\nvar joinPaths = function joinPaths() {\n  var _ref5;\n\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n\n  return (_ref5 = []).concat.apply(_ref5, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\n\nvar createConfigItem = function createConfigItem(legacy, config, parentPattern) {\n  var _pattern2;\n\n  if (typeof config === 'string') {\n    var _pattern3 = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return {\n      pattern: _pattern3\n    };\n  }\n\n  var pattern;\n\n  if (legacy) {\n    pattern = config.exact !== true && parentPattern && config.path ? joinPaths(parentPattern, config.path) : config.path;\n  } else {\n    if (config.exact && config.path === undefined) {\n      throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n    }\n\n    pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  }\n\n  var screens = config.screens ? createNormalizedConfigs(legacy, config.screens, pattern) : undefined;\n  return {\n    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens: screens\n  };\n};\n\nvar createNormalizedConfigs = function createNormalizedConfigs(legacy, options, pattern) {\n  return fromEntries(Object.entries(options).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n        name = _ref7[0],\n        c = _ref7[1];\n\n    var result = createConfigItem(legacy, c, pattern);\n    return [name, result];\n  }));\n};","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["getActiveRoute","route","state","Error","legacy","compatOptions","checkLegacyPathConfig","configs","createNormalizedConfigs","path","current","allParams","index","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","stringify","currentParams","fromEntries","Object","key","value","String","p","name","getParamName","nextRoute","nestedConfig","encodeURIComponent","query","queryString","entries","k","v","acc","joinPaths","paths","createConfigItem","parentPattern","config","screens","c","result"],"mappings":"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","sourcesContent":["import * as queryString from 'query-string';\nimport type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport checkLegacyPathConfig from './checkLegacyPathConfig';\nimport type { PathConfig, PathConfigMap } from './types';\n\ntype Options = { initialRouteName?: string; screens: PathConfigMap };\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state: State,\n  options?: Options\n): string {\n  if (state == null) {\n    throw Error(\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\n    );\n  }\n\n  const [legacy, compatOptions] = checkLegacyPathConfig(options);\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = compatOptions\n    ? createNormalizedConfigs(legacy, compatOptions.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            if (legacy) {\n              throw new Error(\n                \"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/5.x/configuring-links/#updating-config\"\n              );\n            }\n\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams);\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\n// Object.fromEntries is not available in older iOS versions\nconst fromEntries = <K extends string, V>(entries: (readonly [K, V])[]) =>\n  entries.reduce((acc, [k, v]) => {\n    if (acc.hasOwnProperty(k)) {\n      throw new Error(`A value for key '${k}' already exists in the object.`);\n    }\n\n    acc[k] = v;\n    return acc;\n  }, {} as Record<K, V>);\n\nconst getParamName = (pattern: string) =>\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  legacy: boolean,\n  config: PathConfig | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern: string | undefined;\n\n  if (legacy) {\n    pattern =\n      config.exact !== true && parentPattern && config.path\n        ? joinPaths(parentPattern, config.path)\n        : config.path;\n  } else {\n    if (config.exact && config.path === undefined) {\n      throw new Error(\n        \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n      );\n    }\n\n    pattern =\n      config.exact !== true\n        ? joinPaths(parentPattern || '', config.path || '')\n        : config.path || '';\n  }\n\n  const screens = config.screens\n    ? createNormalizedConfigs(legacy, config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  legacy: boolean,\n  options: PathConfigMap,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(legacy, c, pattern);\n\n      return [name, result];\n    })\n  );\n"]},"metadata":{},"sourceType":"module"}