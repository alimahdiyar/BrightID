{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _acquisitionSdk = require(\"code-push/script/acquisition-sdk\");\n\nvar _AlertAdapter = require(\"./AlertAdapter\");\n\nvar _requestFetchAdapter = _interopRequireDefault(require(\"./request-fetch-adapter\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _logging = _interopRequireDefault(require(\"./logging\"));\n\nvar _hoistNonReactStatics = _interopRequireDefault(require(\"hoist-non-react-statics\"));\n\nvar _jsxFileName = \"/home/ali/Desktop/brightid/BrightID/BrightID/node_modules/react-native-code-push/CodePush.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar NativeCodePush = require(\"react-native\").NativeModules.CodePush;\n\nvar PackageMixins = require(\"./package-mixins\")(NativeCodePush);\n\nfunction checkForUpdate() {\n  var deploymentKey,\n      handleBinaryVersionMismatchCallback,\n      nativeConfig,\n      config,\n      sdk,\n      localPackage,\n      queryPackage,\n      update,\n      remotePackage,\n      _args = arguments;\n  return _regenerator.default.async(function checkForUpdate$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          deploymentKey = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;\n          handleBinaryVersionMismatchCallback = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n          _context.next = 4;\n          return _regenerator.default.awrap(getConfiguration());\n\n        case 4:\n          nativeConfig = _context.sent;\n          config = deploymentKey ? (0, _extends2.default)({}, nativeConfig, {\n            deploymentKey: deploymentKey\n          }) : nativeConfig;\n          sdk = getPromisifiedSdk(_requestFetchAdapter.default, config);\n          _context.next = 9;\n          return _regenerator.default.awrap(module.exports.getCurrentPackage());\n\n        case 9:\n          localPackage = _context.sent;\n\n          if (localPackage) {\n            queryPackage = localPackage;\n          } else {\n            queryPackage = {\n              appVersion: config.appVersion\n            };\n\n            if (_reactNative.Platform.OS === \"ios\" && config.packageHash) {\n              queryPackage.packageHash = config.packageHash;\n            }\n          }\n\n          _context.next = 13;\n          return _regenerator.default.awrap(sdk.queryUpdateWithCurrentPackage(queryPackage));\n\n        case 13:\n          update = _context.sent;\n\n          if (!(!update || update.updateAppVersion || localPackage && update.packageHash === localPackage.packageHash || (!localPackage || localPackage._isDebugOnly) && config.packageHash === update.packageHash)) {\n            _context.next = 19;\n            break;\n          }\n\n          if (update && update.updateAppVersion) {\n            (0, _logging.default)(\"An update is available but it is not targeting the binary version of your app.\");\n\n            if (handleBinaryVersionMismatchCallback && typeof handleBinaryVersionMismatchCallback === \"function\") {\n              handleBinaryVersionMismatchCallback(update);\n            }\n          }\n\n          return _context.abrupt(\"return\", null);\n\n        case 19:\n          remotePackage = (0, _extends2.default)({}, update, PackageMixins.remote(sdk.reportStatusDownload));\n          _context.next = 22;\n          return _regenerator.default.awrap(NativeCodePush.isFailedUpdate(remotePackage.packageHash));\n\n        case 22:\n          remotePackage.failedInstall = _context.sent;\n          remotePackage.deploymentKey = deploymentKey || nativeConfig.deploymentKey;\n          return _context.abrupt(\"return\", remotePackage);\n\n        case 25:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nvar getConfiguration = function () {\n  var config;\n  return function getConfiguration() {\n    return _regenerator.default.async(function getConfiguration$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!config) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", config);\n\n          case 4:\n            if (!testConfig) {\n              _context2.next = 8;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", testConfig);\n\n          case 8:\n            _context2.next = 10;\n            return _regenerator.default.awrap(NativeCodePush.getConfiguration());\n\n          case 10:\n            config = _context2.sent;\n            return _context2.abrupt(\"return\", config);\n\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n}();\n\nfunction getCurrentPackage() {\n  return _regenerator.default.async(function getCurrentPackage$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regenerator.default.awrap(getUpdateMetadata(CodePush.UpdateState.LATEST));\n\n        case 2:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 3:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction getUpdateMetadata(updateState) {\n  var updateMetadata;\n  return _regenerator.default.async(function getUpdateMetadata$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return _regenerator.default.awrap(NativeCodePush.getUpdateMetadata(updateState || CodePush.UpdateState.RUNNING));\n\n        case 2:\n          updateMetadata = _context4.sent;\n\n          if (!updateMetadata) {\n            _context4.next = 11;\n            break;\n          }\n\n          updateMetadata = (0, _extends2.default)({}, PackageMixins.local, updateMetadata);\n          _context4.next = 7;\n          return _regenerator.default.awrap(NativeCodePush.isFailedUpdate(updateMetadata.packageHash));\n\n        case 7:\n          updateMetadata.failedInstall = _context4.sent;\n          _context4.next = 10;\n          return _regenerator.default.awrap(NativeCodePush.isFirstRun(updateMetadata.packageHash));\n\n        case 10:\n          updateMetadata.isFirstRun = _context4.sent;\n\n        case 11:\n          return _context4.abrupt(\"return\", updateMetadata);\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction getPromisifiedSdk(requestFetchAdapter, config) {\n  var sdk = new module.exports.AcquisitionSdk(requestFetchAdapter, config);\n\n  sdk.queryUpdateWithCurrentPackage = function (queryPackage) {\n    return new Promise(function (resolve, reject) {\n      module.exports.AcquisitionSdk.prototype.queryUpdateWithCurrentPackage.call(sdk, queryPackage, function (err, update) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(update);\n        }\n      });\n    });\n  };\n\n  sdk.reportStatusDeploy = function (deployedPackage, status, previousLabelOrAppVersion, previousDeploymentKey) {\n    return new Promise(function (resolve, reject) {\n      module.exports.AcquisitionSdk.prototype.reportStatusDeploy.call(sdk, deployedPackage, status, previousLabelOrAppVersion, previousDeploymentKey, function (err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n\n  sdk.reportStatusDownload = function (downloadedPackage) {\n    return new Promise(function (resolve, reject) {\n      module.exports.AcquisitionSdk.prototype.reportStatusDownload.call(sdk, downloadedPackage, function (err) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n\n  return sdk;\n}\n\nvar notifyApplicationReady = function () {\n  var notifyApplicationReadyPromise;\n  return function () {\n    if (!notifyApplicationReadyPromise) {\n      notifyApplicationReadyPromise = notifyApplicationReadyInternal();\n    }\n\n    return notifyApplicationReadyPromise;\n  };\n}();\n\nfunction notifyApplicationReadyInternal() {\n  var statusReport;\n  return _regenerator.default.async(function notifyApplicationReadyInternal$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return _regenerator.default.awrap(NativeCodePush.notifyApplicationReady());\n\n        case 2:\n          _context5.next = 4;\n          return _regenerator.default.awrap(NativeCodePush.getNewStatusReport());\n\n        case 4:\n          statusReport = _context5.sent;\n          statusReport && tryReportStatus(statusReport);\n          return _context5.abrupt(\"return\", statusReport);\n\n        case 7:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction tryReportStatus(statusReport, resumeListener) {\n  var config, previousLabelOrAppVersion, previousDeploymentKey, sdk, label, _sdk;\n\n  return _regenerator.default.async(function tryReportStatus$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          _context7.next = 2;\n          return _regenerator.default.awrap(getConfiguration());\n\n        case 2:\n          config = _context7.sent;\n          previousLabelOrAppVersion = statusReport.previousLabelOrAppVersion;\n          previousDeploymentKey = statusReport.previousDeploymentKey || config.deploymentKey;\n          _context7.prev = 5;\n\n          if (!statusReport.appVersion) {\n            _context7.next = 15;\n            break;\n          }\n\n          (0, _logging.default)(\"Reporting binary update (\" + statusReport.appVersion + \")\");\n\n          if (config.deploymentKey) {\n            _context7.next = 10;\n            break;\n          }\n\n          throw new Error(\"Deployment key is missed\");\n\n        case 10:\n          sdk = getPromisifiedSdk(_requestFetchAdapter.default, config);\n          _context7.next = 13;\n          return _regenerator.default.awrap(sdk.reportStatusDeploy(null, null, previousLabelOrAppVersion, previousDeploymentKey));\n\n        case 13:\n          _context7.next = 27;\n          break;\n\n        case 15:\n          label = statusReport.package.label;\n\n          if (!(statusReport.status === \"DeploymentSucceeded\")) {\n            _context7.next = 20;\n            break;\n          }\n\n          (0, _logging.default)(\"Reporting CodePush update success (\" + label + \")\");\n          _context7.next = 23;\n          break;\n\n        case 20:\n          (0, _logging.default)(\"Reporting CodePush update rollback (\" + label + \")\");\n          _context7.next = 23;\n          return _regenerator.default.awrap(NativeCodePush.setLatestRollbackInfo(statusReport.package.packageHash));\n\n        case 23:\n          config.deploymentKey = statusReport.package.deploymentKey;\n          _sdk = getPromisifiedSdk(_requestFetchAdapter.default, config);\n          _context7.next = 27;\n          return _regenerator.default.awrap(_sdk.reportStatusDeploy(statusReport.package, statusReport.status, previousLabelOrAppVersion, previousDeploymentKey));\n\n        case 27:\n          NativeCodePush.recordStatusReported(statusReport);\n          resumeListener && _reactNative.AppState.removeEventListener(\"change\", resumeListener);\n          _context7.next = 36;\n          break;\n\n        case 31:\n          _context7.prev = 31;\n          _context7.t0 = _context7[\"catch\"](5);\n          (0, _logging.default)(\"Report status failed: \" + JSON.stringify(statusReport));\n          NativeCodePush.saveStatusReportForRetry(statusReport);\n\n          if (!resumeListener) {\n            resumeListener = function _callee(newState) {\n              var refreshedStatusReport;\n              return _regenerator.default.async(function _callee$(_context6) {\n                while (1) {\n                  switch (_context6.prev = _context6.next) {\n                    case 0:\n                      if (!(newState !== \"active\")) {\n                        _context6.next = 2;\n                        break;\n                      }\n\n                      return _context6.abrupt(\"return\");\n\n                    case 2:\n                      _context6.next = 4;\n                      return _regenerator.default.awrap(NativeCodePush.getNewStatusReport());\n\n                    case 4:\n                      refreshedStatusReport = _context6.sent;\n\n                      if (refreshedStatusReport) {\n                        tryReportStatus(refreshedStatusReport, resumeListener);\n                      } else {\n                        _reactNative.AppState.removeEventListener(\"change\", resumeListener);\n                      }\n\n                    case 6:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }\n              }, null, null, null, Promise);\n            };\n\n            _reactNative.AppState.addEventListener(\"change\", resumeListener);\n          }\n\n        case 36:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, [[5, 31]], Promise);\n}\n\nfunction shouldUpdateBeIgnored(remotePackage, syncOptions) {\n  var rollbackRetryOptions, isFailedPackage, latestRollbackInfo, _rollbackRetryOptions, delayInHours, maxRetryAttempts, hoursSinceLatestRollback;\n\n  return _regenerator.default.async(function shouldUpdateBeIgnored$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          rollbackRetryOptions = syncOptions.rollbackRetryOptions;\n          isFailedPackage = remotePackage && remotePackage.failedInstall;\n\n          if (!(!isFailedPackage || !syncOptions.ignoreFailedUpdates)) {\n            _context8.next = 4;\n            break;\n          }\n\n          return _context8.abrupt(\"return\", false);\n\n        case 4:\n          if (rollbackRetryOptions) {\n            _context8.next = 6;\n            break;\n          }\n\n          return _context8.abrupt(\"return\", true);\n\n        case 6:\n          if (typeof rollbackRetryOptions !== \"object\") {\n            rollbackRetryOptions = CodePush.DEFAULT_ROLLBACK_RETRY_OPTIONS;\n          } else {\n            rollbackRetryOptions = (0, _extends2.default)({}, CodePush.DEFAULT_ROLLBACK_RETRY_OPTIONS, rollbackRetryOptions);\n          }\n\n          if (validateRollbackRetryOptions(rollbackRetryOptions)) {\n            _context8.next = 9;\n            break;\n          }\n\n          return _context8.abrupt(\"return\", true);\n\n        case 9:\n          _context8.next = 11;\n          return _regenerator.default.awrap(NativeCodePush.getLatestRollbackInfo());\n\n        case 11:\n          latestRollbackInfo = _context8.sent;\n\n          if (validateLatestRollbackInfo(latestRollbackInfo, remotePackage.packageHash)) {\n            _context8.next = 15;\n            break;\n          }\n\n          (0, _logging.default)(\"The latest rollback info is not valid.\");\n          return _context8.abrupt(\"return\", true);\n\n        case 15:\n          _rollbackRetryOptions = rollbackRetryOptions, delayInHours = _rollbackRetryOptions.delayInHours, maxRetryAttempts = _rollbackRetryOptions.maxRetryAttempts;\n          hoursSinceLatestRollback = (Date.now() - latestRollbackInfo.time) / (1000 * 60 * 60);\n\n          if (!(hoursSinceLatestRollback >= delayInHours && maxRetryAttempts >= latestRollbackInfo.count)) {\n            _context8.next = 20;\n            break;\n          }\n\n          (0, _logging.default)(\"Previous rollback should be ignored due to rollback retry options.\");\n          return _context8.abrupt(\"return\", false);\n\n        case 20:\n          return _context8.abrupt(\"return\", true);\n\n        case 21:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction validateLatestRollbackInfo(latestRollbackInfo, packageHash) {\n  return latestRollbackInfo && latestRollbackInfo.time && latestRollbackInfo.count && latestRollbackInfo.packageHash && latestRollbackInfo.packageHash === packageHash;\n}\n\nfunction validateRollbackRetryOptions(rollbackRetryOptions) {\n  if (typeof rollbackRetryOptions.delayInHours !== \"number\") {\n    (0, _logging.default)(\"The 'delayInHours' rollback retry parameter must be a number.\");\n    return false;\n  }\n\n  if (typeof rollbackRetryOptions.maxRetryAttempts !== \"number\") {\n    (0, _logging.default)(\"The 'maxRetryAttempts' rollback retry parameter must be a number.\");\n    return false;\n  }\n\n  if (rollbackRetryOptions.maxRetryAttempts < 1) {\n    (0, _logging.default)(\"The 'maxRetryAttempts' rollback retry parameter cannot be less then 1.\");\n    return false;\n  }\n\n  return true;\n}\n\nvar testConfig;\n\nfunction setUpTestDependencies(testSdk, providedTestConfig, testNativeBridge) {\n  if (testSdk) module.exports.AcquisitionSdk = testSdk;\n  if (providedTestConfig) testConfig = providedTestConfig;\n  if (testNativeBridge) NativeCodePush = testNativeBridge;\n}\n\nfunction restartApp() {\n  var onlyIfUpdateIsPending,\n      _args9 = arguments;\n  return _regenerator.default.async(function restartApp$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          onlyIfUpdateIsPending = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : false;\n          NativeCodePush.restartApp(onlyIfUpdateIsPending);\n\n        case 2:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nvar sync = function () {\n  var syncInProgress = false;\n\n  var setSyncCompleted = function setSyncCompleted() {\n    syncInProgress = false;\n  };\n\n  return function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var syncStatusChangeCallback = arguments.length > 1 ? arguments[1] : undefined;\n    var downloadProgressCallback = arguments.length > 2 ? arguments[2] : undefined;\n    var handleBinaryVersionMismatchCallback = arguments.length > 3 ? arguments[3] : undefined;\n    var syncStatusCallbackWithTryCatch, downloadProgressCallbackWithTryCatch;\n\n    if (typeof syncStatusChangeCallback === \"function\") {\n      syncStatusCallbackWithTryCatch = function syncStatusCallbackWithTryCatch() {\n        try {\n          syncStatusChangeCallback.apply(void 0, arguments);\n        } catch (error) {\n          (0, _logging.default)(\"An error has occurred : \" + error.stack);\n        }\n      };\n    }\n\n    if (typeof downloadProgressCallback === \"function\") {\n      downloadProgressCallbackWithTryCatch = function downloadProgressCallbackWithTryCatch() {\n        try {\n          downloadProgressCallback.apply(void 0, arguments);\n        } catch (error) {\n          (0, _logging.default)(\"An error has occurred: \" + error.stack);\n        }\n      };\n    }\n\n    if (syncInProgress) {\n      typeof syncStatusCallbackWithTryCatch === \"function\" ? syncStatusCallbackWithTryCatch(CodePush.SyncStatus.SYNC_IN_PROGRESS) : (0, _logging.default)(\"Sync already in progress.\");\n      return Promise.resolve(CodePush.SyncStatus.SYNC_IN_PROGRESS);\n    }\n\n    syncInProgress = true;\n    var syncPromise = syncInternal(options, syncStatusCallbackWithTryCatch, downloadProgressCallbackWithTryCatch, handleBinaryVersionMismatchCallback);\n    syncPromise.then(setSyncCompleted).catch(setSyncCompleted);\n    return syncPromise;\n  };\n}();\n\nfunction syncInternal() {\n  var options,\n      syncStatusChangeCallback,\n      downloadProgressCallback,\n      handleBinaryVersionMismatchCallback,\n      resolvedInstallMode,\n      syncOptions,\n      remotePackage,\n      doDownloadAndInstall,\n      updateShouldBeIgnored,\n      currentPackage,\n      _args11 = arguments;\n  return _regenerator.default.async(function syncInternal$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          options = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};\n          syncStatusChangeCallback = _args11.length > 1 ? _args11[1] : undefined;\n          downloadProgressCallback = _args11.length > 2 ? _args11[2] : undefined;\n          handleBinaryVersionMismatchCallback = _args11.length > 3 ? _args11[3] : undefined;\n          syncOptions = (0, _extends2.default)({\n            deploymentKey: null,\n            ignoreFailedUpdates: true,\n            rollbackRetryOptions: null,\n            installMode: CodePush.InstallMode.ON_NEXT_RESTART,\n            mandatoryInstallMode: CodePush.InstallMode.IMMEDIATE,\n            minimumBackgroundDuration: 0,\n            updateDialog: null\n          }, options);\n          syncStatusChangeCallback = typeof syncStatusChangeCallback === \"function\" ? syncStatusChangeCallback : function (syncStatus) {\n            switch (syncStatus) {\n              case CodePush.SyncStatus.CHECKING_FOR_UPDATE:\n                (0, _logging.default)(\"Checking for update.\");\n                break;\n\n              case CodePush.SyncStatus.AWAITING_USER_ACTION:\n                (0, _logging.default)(\"Awaiting user action.\");\n                break;\n\n              case CodePush.SyncStatus.DOWNLOADING_PACKAGE:\n                (0, _logging.default)(\"Downloading package.\");\n                break;\n\n              case CodePush.SyncStatus.INSTALLING_UPDATE:\n                (0, _logging.default)(\"Installing update.\");\n                break;\n\n              case CodePush.SyncStatus.UP_TO_DATE:\n                (0, _logging.default)(\"App is up to date.\");\n                break;\n\n              case CodePush.SyncStatus.UPDATE_IGNORED:\n                (0, _logging.default)(\"User cancelled the update.\");\n                break;\n\n              case CodePush.SyncStatus.UPDATE_INSTALLED:\n                if (resolvedInstallMode == CodePush.InstallMode.ON_NEXT_RESTART) {\n                  (0, _logging.default)(\"Update is installed and will be run on the next app restart.\");\n                } else if (resolvedInstallMode == CodePush.InstallMode.ON_NEXT_RESUME) {\n                  if (syncOptions.minimumBackgroundDuration > 0) {\n                    (0, _logging.default)(\"Update is installed and will be run after the app has been in the background for at least \" + syncOptions.minimumBackgroundDuration + \" seconds.\");\n                  } else {\n                    (0, _logging.default)(\"Update is installed and will be run when the app next resumes.\");\n                  }\n                }\n\n                break;\n\n              case CodePush.SyncStatus.UNKNOWN_ERROR:\n                (0, _logging.default)(\"An unknown error occurred.\");\n                break;\n            }\n          };\n          _context11.prev = 6;\n          _context11.next = 9;\n          return _regenerator.default.awrap(CodePush.notifyApplicationReady());\n\n        case 9:\n          syncStatusChangeCallback(CodePush.SyncStatus.CHECKING_FOR_UPDATE);\n          _context11.next = 12;\n          return _regenerator.default.awrap(checkForUpdate(syncOptions.deploymentKey, handleBinaryVersionMismatchCallback));\n\n        case 12:\n          remotePackage = _context11.sent;\n\n          doDownloadAndInstall = function _callee2() {\n            var localPackage;\n            return _regenerator.default.async(function _callee2$(_context10) {\n              while (1) {\n                switch (_context10.prev = _context10.next) {\n                  case 0:\n                    syncStatusChangeCallback(CodePush.SyncStatus.DOWNLOADING_PACKAGE);\n                    _context10.next = 3;\n                    return _regenerator.default.awrap(remotePackage.download(downloadProgressCallback));\n\n                  case 3:\n                    localPackage = _context10.sent;\n                    resolvedInstallMode = localPackage.isMandatory ? syncOptions.mandatoryInstallMode : syncOptions.installMode;\n                    syncStatusChangeCallback(CodePush.SyncStatus.INSTALLING_UPDATE);\n                    _context10.next = 8;\n                    return _regenerator.default.awrap(localPackage.install(resolvedInstallMode, syncOptions.minimumBackgroundDuration, function () {\n                      syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_INSTALLED);\n                    }));\n\n                  case 8:\n                    return _context10.abrupt(\"return\", CodePush.SyncStatus.UPDATE_INSTALLED);\n\n                  case 9:\n                  case \"end\":\n                    return _context10.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          };\n\n          _context11.next = 16;\n          return _regenerator.default.awrap(shouldUpdateBeIgnored(remotePackage, syncOptions));\n\n        case 16:\n          updateShouldBeIgnored = _context11.sent;\n\n          if (!(!remotePackage || updateShouldBeIgnored)) {\n            _context11.next = 31;\n            break;\n          }\n\n          if (updateShouldBeIgnored) {\n            (0, _logging.default)(\"An update is available, but it is being ignored due to having been previously rolled back.\");\n          }\n\n          _context11.next = 21;\n          return _regenerator.default.awrap(CodePush.getCurrentPackage());\n\n        case 21:\n          currentPackage = _context11.sent;\n\n          if (!(currentPackage && currentPackage.isPending)) {\n            _context11.next = 27;\n            break;\n          }\n\n          syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_INSTALLED);\n          return _context11.abrupt(\"return\", CodePush.SyncStatus.UPDATE_INSTALLED);\n\n        case 27:\n          syncStatusChangeCallback(CodePush.SyncStatus.UP_TO_DATE);\n          return _context11.abrupt(\"return\", CodePush.SyncStatus.UP_TO_DATE);\n\n        case 29:\n          _context11.next = 41;\n          break;\n\n        case 31:\n          if (!syncOptions.updateDialog) {\n            _context11.next = 38;\n            break;\n          }\n\n          if (typeof syncOptions.updateDialog !== \"object\") {\n            syncOptions.updateDialog = CodePush.DEFAULT_UPDATE_DIALOG;\n          } else {\n            syncOptions.updateDialog = (0, _extends2.default)({}, CodePush.DEFAULT_UPDATE_DIALOG, syncOptions.updateDialog);\n          }\n\n          _context11.next = 35;\n          return _regenerator.default.awrap(new Promise(function (resolve, reject) {\n            var message = null;\n            var installButtonText = null;\n            var dialogButtons = [];\n\n            if (remotePackage.isMandatory) {\n              message = syncOptions.updateDialog.mandatoryUpdateMessage;\n              installButtonText = syncOptions.updateDialog.mandatoryContinueButtonLabel;\n            } else {\n              message = syncOptions.updateDialog.optionalUpdateMessage;\n              installButtonText = syncOptions.updateDialog.optionalInstallButtonLabel;\n              dialogButtons.push({\n                text: syncOptions.updateDialog.optionalIgnoreButtonLabel,\n                onPress: function onPress() {\n                  syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_IGNORED);\n                  resolve(CodePush.SyncStatus.UPDATE_IGNORED);\n                }\n              });\n            }\n\n            dialogButtons.push({\n              text: installButtonText,\n              onPress: function onPress() {\n                doDownloadAndInstall().then(resolve, reject);\n              }\n            });\n\n            if (syncOptions.updateDialog.appendReleaseDescription && remotePackage.description) {\n              message += syncOptions.updateDialog.descriptionPrefix + \" \" + remotePackage.description;\n            }\n\n            syncStatusChangeCallback(CodePush.SyncStatus.AWAITING_USER_ACTION);\n\n            _AlertAdapter.Alert.alert(syncOptions.updateDialog.title, message, dialogButtons);\n          }));\n\n        case 35:\n          return _context11.abrupt(\"return\", _context11.sent);\n\n        case 38:\n          _context11.next = 40;\n          return _regenerator.default.awrap(doDownloadAndInstall());\n\n        case 40:\n          return _context11.abrupt(\"return\", _context11.sent);\n\n        case 41:\n          _context11.next = 48;\n          break;\n\n        case 43:\n          _context11.prev = 43;\n          _context11.t0 = _context11[\"catch\"](6);\n          syncStatusChangeCallback(CodePush.SyncStatus.UNKNOWN_ERROR);\n          (0, _logging.default)(_context11.t0.message);\n          throw _context11.t0;\n\n        case 48:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, null, null, [[6, 43]], Promise);\n}\n\n;\nvar CodePush;\n\nfunction codePushify() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var React;\n\n  var ReactNative = require(\"react-native\");\n\n  try {\n    React = require(\"react\");\n  } catch (e) {}\n\n  if (!React) {\n    try {\n      React = ReactNative.React;\n    } catch (e) {}\n\n    if (!React) {\n      throw new Error(\"Unable to find the 'React' module.\");\n    }\n  }\n\n  if (!React.Component) {\n    throw new Error(\"Unable to find the \\\"Component\\\" class, please either:\\n1. Upgrade to a newer version of React Native that supports it, or\\n2. Call the codePush.sync API in your component instead of using the @codePush decorator\");\n  }\n\n  var decorator = function decorator(RootComponent) {\n    var extended = function (_React$Component) {\n      (0, _inherits2.default)(CodePushComponent, _React$Component);\n\n      var _super = _createSuper(CodePushComponent);\n\n      function CodePushComponent() {\n        (0, _classCallCheck2.default)(this, CodePushComponent);\n        return _super.apply(this, arguments);\n      }\n\n      (0, _createClass2.default)(CodePushComponent, [{\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          if (options.checkFrequency === CodePush.CheckFrequency.MANUAL) {\n            CodePush.notifyAppReady();\n          } else {\n            var rootComponentInstance = this.refs.rootComponent;\n            var syncStatusCallback;\n\n            if (rootComponentInstance && rootComponentInstance.codePushStatusDidChange) {\n              syncStatusCallback = rootComponentInstance.codePushStatusDidChange;\n\n              if (rootComponentInstance instanceof React.Component) {\n                syncStatusCallback = syncStatusCallback.bind(rootComponentInstance);\n              }\n            }\n\n            var _downloadProgressCallback;\n\n            if (rootComponentInstance && rootComponentInstance.codePushDownloadDidProgress) {\n              _downloadProgressCallback = rootComponentInstance.codePushDownloadDidProgress;\n\n              if (rootComponentInstance instanceof React.Component) {\n                _downloadProgressCallback = _downloadProgressCallback.bind(rootComponentInstance);\n              }\n            }\n\n            var handleBinaryVersionMismatchCallback;\n\n            if (rootComponentInstance && rootComponentInstance.codePushOnBinaryVersionMismatch) {\n              handleBinaryVersionMismatchCallback = rootComponentInstance.codePushOnBinaryVersionMismatch;\n\n              if (rootComponentInstance instanceof React.Component) {\n                handleBinaryVersionMismatchCallback = handleBinaryVersionMismatchCallback.bind(rootComponentInstance);\n              }\n            }\n\n            CodePush.sync(options, syncStatusCallback, _downloadProgressCallback, handleBinaryVersionMismatchCallback);\n\n            if (options.checkFrequency === CodePush.CheckFrequency.ON_APP_RESUME) {\n              ReactNative.AppState.addEventListener(\"change\", function (newState) {\n                newState === \"active\" && CodePush.sync(options, syncStatusCallback, _downloadProgressCallback);\n              });\n            }\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var props = (0, _extends2.default)({}, this.props);\n\n          if (RootComponent.prototype.render) {\n            props.ref = \"rootComponent\";\n          }\n\n          return React.createElement(RootComponent, (0, _extends2.default)({}, props, {\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 585,\n              columnNumber: 16\n            }\n          }));\n        }\n      }]);\n      return CodePushComponent;\n    }(React.Component);\n\n    return (0, _hoistNonReactStatics.default)(extended, RootComponent);\n  };\n\n  if (typeof options === \"function\") {\n    return decorator(options);\n  } else {\n    return decorator;\n  }\n}\n\nif (NativeCodePush) {\n  CodePush = codePushify;\n  (0, _extends2.default)(CodePush, {\n    AcquisitionSdk: _acquisitionSdk.AcquisitionManager,\n    checkForUpdate: checkForUpdate,\n    getConfiguration: getConfiguration,\n    getCurrentPackage: getCurrentPackage,\n    getUpdateMetadata: getUpdateMetadata,\n    log: _logging.default,\n    notifyAppReady: notifyApplicationReady,\n    notifyApplicationReady: notifyApplicationReady,\n    restartApp: restartApp,\n    setUpTestDependencies: setUpTestDependencies,\n    sync: sync,\n    disallowRestart: NativeCodePush.disallow,\n    allowRestart: NativeCodePush.allow,\n    clearUpdates: NativeCodePush.clearUpdates,\n    InstallMode: {\n      IMMEDIATE: NativeCodePush.codePushInstallModeImmediate,\n      ON_NEXT_RESTART: NativeCodePush.codePushInstallModeOnNextRestart,\n      ON_NEXT_RESUME: NativeCodePush.codePushInstallModeOnNextResume,\n      ON_NEXT_SUSPEND: NativeCodePush.codePushInstallModeOnNextSuspend\n    },\n    SyncStatus: {\n      UP_TO_DATE: 0,\n      UPDATE_INSTALLED: 1,\n      UPDATE_IGNORED: 2,\n      UNKNOWN_ERROR: 3,\n      SYNC_IN_PROGRESS: 4,\n      CHECKING_FOR_UPDATE: 5,\n      AWAITING_USER_ACTION: 6,\n      DOWNLOADING_PACKAGE: 7,\n      INSTALLING_UPDATE: 8\n    },\n    CheckFrequency: {\n      ON_APP_START: 0,\n      ON_APP_RESUME: 1,\n      MANUAL: 2\n    },\n    UpdateState: {\n      RUNNING: NativeCodePush.codePushUpdateStateRunning,\n      PENDING: NativeCodePush.codePushUpdateStatePending,\n      LATEST: NativeCodePush.codePushUpdateStateLatest\n    },\n    DeploymentStatus: {\n      FAILED: \"DeploymentFailed\",\n      SUCCEEDED: \"DeploymentSucceeded\"\n    },\n    DEFAULT_UPDATE_DIALOG: {\n      appendReleaseDescription: false,\n      descriptionPrefix: \" Description: \",\n      mandatoryContinueButtonLabel: \"Continue\",\n      mandatoryUpdateMessage: \"An update is available that must be installed.\",\n      optionalIgnoreButtonLabel: \"Ignore\",\n      optionalInstallButtonLabel: \"Install\",\n      optionalUpdateMessage: \"An update is available. Would you like to install it?\",\n      title: \"Update available\"\n    },\n    DEFAULT_ROLLBACK_RETRY_OPTIONS: {\n      delayInHours: 24,\n      maxRetryAttempts: 1\n    }\n  });\n} else {\n  (0, _logging.default)(\"The CodePush module doesn't appear to be properly installed. Please double-check that everything is setup correctly.\");\n}\n\nmodule.exports = CodePush;","map":{"version":3,"names":["NativeCodePush","require","NativeModules","CodePush","PackageMixins","checkForUpdate","deploymentKey","handleBinaryVersionMismatchCallback","getConfiguration","nativeConfig","config","sdk","getPromisifiedSdk","requestFetchAdapter","module","exports","getCurrentPackage","localPackage","queryPackage","appVersion","Platform","OS","packageHash","queryUpdateWithCurrentPackage","update","updateAppVersion","_isDebugOnly","log","remotePackage","remote","reportStatusDownload","isFailedUpdate","failedInstall","testConfig","getUpdateMetadata","UpdateState","LATEST","updateState","RUNNING","updateMetadata","local","isFirstRun","AcquisitionSdk","Promise","resolve","reject","prototype","call","err","reportStatusDeploy","deployedPackage","status","previousLabelOrAppVersion","previousDeploymentKey","downloadedPackage","notifyApplicationReady","notifyApplicationReadyPromise","notifyApplicationReadyInternal","getNewStatusReport","statusReport","tryReportStatus","resumeListener","Error","label","package","setLatestRollbackInfo","recordStatusReported","AppState","removeEventListener","JSON","stringify","saveStatusReportForRetry","newState","refreshedStatusReport","addEventListener","shouldUpdateBeIgnored","syncOptions","rollbackRetryOptions","isFailedPackage","ignoreFailedUpdates","DEFAULT_ROLLBACK_RETRY_OPTIONS","validateRollbackRetryOptions","getLatestRollbackInfo","latestRollbackInfo","validateLatestRollbackInfo","delayInHours","maxRetryAttempts","hoursSinceLatestRollback","Date","now","time","count","setUpTestDependencies","testSdk","providedTestConfig","testNativeBridge","restartApp","onlyIfUpdateIsPending","sync","syncInProgress","setSyncCompleted","options","syncStatusChangeCallback","downloadProgressCallback","syncStatusCallbackWithTryCatch","downloadProgressCallbackWithTryCatch","error","stack","SyncStatus","SYNC_IN_PROGRESS","syncPromise","syncInternal","then","catch","installMode","InstallMode","ON_NEXT_RESTART","mandatoryInstallMode","IMMEDIATE","minimumBackgroundDuration","updateDialog","syncStatus","CHECKING_FOR_UPDATE","AWAITING_USER_ACTION","DOWNLOADING_PACKAGE","INSTALLING_UPDATE","UP_TO_DATE","UPDATE_IGNORED","UPDATE_INSTALLED","resolvedInstallMode","ON_NEXT_RESUME","UNKNOWN_ERROR","doDownloadAndInstall","download","isMandatory","install","updateShouldBeIgnored","currentPackage","isPending","DEFAULT_UPDATE_DIALOG","message","installButtonText","dialogButtons","mandatoryUpdateMessage","mandatoryContinueButtonLabel","optionalUpdateMessage","optionalInstallButtonLabel","push","text","optionalIgnoreButtonLabel","onPress","appendReleaseDescription","description","descriptionPrefix","Alert","alert","title","codePushify","React","ReactNative","e","Component","decorator","RootComponent","extended","checkFrequency","CheckFrequency","MANUAL","notifyAppReady","rootComponentInstance","refs","rootComponent","syncStatusCallback","codePushStatusDidChange","bind","codePushDownloadDidProgress","codePushOnBinaryVersionMismatch","ON_APP_RESUME","props","render","ref","hoistStatics","Sdk","disallowRestart","disallow","allowRestart","allow","clearUpdates","codePushInstallModeImmediate","codePushInstallModeOnNextRestart","codePushInstallModeOnNextResume","ON_NEXT_SUSPEND","codePushInstallModeOnNextSuspend","ON_APP_START","codePushUpdateStateRunning","PENDING","codePushUpdateStatePending","codePushUpdateStateLatest","DeploymentStatus","FAILED","SUCCEEDED"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/node_modules/react-native-code-push/CodePush.js"],"sourcesContent":["import { AcquisitionManager as Sdk } from \"code-push/script/acquisition-sdk\";\nimport { Alert } from \"./AlertAdapter\";\nimport requestFetchAdapter from \"./request-fetch-adapter\";\nimport { AppState, Platform } from \"react-native\";\nimport log from \"./logging\";\nimport hoistStatics from 'hoist-non-react-statics';\n\nlet NativeCodePush = require(\"react-native\").NativeModules.CodePush;\nconst PackageMixins = require(\"./package-mixins\")(NativeCodePush);\n\nasync function checkForUpdate(deploymentKey = null, handleBinaryVersionMismatchCallback = null) {\n  /*\n   * Before we ask the server if an update exists, we\n   * need to retrieve three pieces of information from the\n   * native side: deployment key, app version (e.g. 1.0.1)\n   * and the hash of the currently running update (if there is one).\n   * This allows the client to only receive updates which are targetted\n   * for their specific deployment and version and which are actually\n   * different from the CodePush update they have already installed.\n   */\n  const nativeConfig = await getConfiguration();\n  /*\n   * If a deployment key was explicitly provided,\n   * then let's override the one we retrieved\n   * from the native-side of the app. This allows\n   * dynamically \"redirecting\" end-users at different\n   * deployments (e.g. an early access deployment for insiders).\n   */\n  const config = deploymentKey ? { ...nativeConfig, ...{ deploymentKey } } : nativeConfig;\n  const sdk = getPromisifiedSdk(requestFetchAdapter, config);\n\n  // Use dynamically overridden getCurrentPackage() during tests.\n  const localPackage = await module.exports.getCurrentPackage();\n\n  /*\n   * If the app has a previously installed update, and that update\n   * was targetted at the same app version that is currently running,\n   * then we want to use its package hash to determine whether a new\n   * release has been made on the server. Otherwise, we only need\n   * to send the app version to the server, since we are interested\n   * in any updates for current binary version, regardless of hash.\n   */\n  let queryPackage;\n  if (localPackage) {\n    queryPackage = localPackage;\n  } else {\n    queryPackage = { appVersion: config.appVersion };\n    if (Platform.OS === \"ios\" && config.packageHash) {\n      queryPackage.packageHash = config.packageHash;\n    }\n  }\n\n  const update = await sdk.queryUpdateWithCurrentPackage(queryPackage);\n\n  /*\n   * There are four cases where checkForUpdate will resolve to null:\n   * ----------------------------------------------------------------\n   * 1) The server said there isn't an update. This is the most common case.\n   * 2) The server said there is an update but it requires a newer binary version.\n   *    This would occur when end-users are running an older binary version than\n   *    is available, and CodePush is making sure they don't get an update that\n   *    potentially wouldn't be compatible with what they are running.\n   * 3) The server said there is an update, but the update's hash is the same as\n   *    the currently running update. This should _never_ happen, unless there is a\n   *    bug in the server, but we're adding this check just to double-check that the\n   *    client app is resilient to a potential issue with the update check.\n   * 4) The server said there is an update, but the update's hash is the same as that\n   *    of the binary's currently running version. This should only happen in Android -\n   *    unlike iOS, we don't attach the binary's hash to the updateCheck request\n   *    because we want to avoid having to install diff updates against the binary's\n   *    version, which we can't do yet on Android.\n   */\n  if (!update || update.updateAppVersion ||\n      localPackage && (update.packageHash === localPackage.packageHash) ||\n      (!localPackage || localPackage._isDebugOnly) && config.packageHash === update.packageHash) {\n    if (update && update.updateAppVersion) {\n      log(\"An update is available but it is not targeting the binary version of your app.\");\n      if (handleBinaryVersionMismatchCallback && typeof handleBinaryVersionMismatchCallback === \"function\") {\n        handleBinaryVersionMismatchCallback(update)\n      }\n    }\n\n    return null;\n  } else {\n    const remotePackage = { ...update, ...PackageMixins.remote(sdk.reportStatusDownload) };\n    remotePackage.failedInstall = await NativeCodePush.isFailedUpdate(remotePackage.packageHash);\n    remotePackage.deploymentKey = deploymentKey || nativeConfig.deploymentKey;\n    return remotePackage;\n  }\n}\n\nconst getConfiguration = (() => {\n  let config;\n  return async function getConfiguration() {\n    if (config) {\n      return config;\n    } else if (testConfig) {\n      return testConfig;\n    } else {\n      config = await NativeCodePush.getConfiguration();\n      return config;\n    }\n  }\n})();\n\nasync function getCurrentPackage() {\n  return await getUpdateMetadata(CodePush.UpdateState.LATEST);\n}\n\nasync function getUpdateMetadata(updateState) {\n  let updateMetadata = await NativeCodePush.getUpdateMetadata(updateState || CodePush.UpdateState.RUNNING);\n  if (updateMetadata) {\n    updateMetadata = {...PackageMixins.local, ...updateMetadata};\n    updateMetadata.failedInstall = await NativeCodePush.isFailedUpdate(updateMetadata.packageHash);\n    updateMetadata.isFirstRun = await NativeCodePush.isFirstRun(updateMetadata.packageHash);\n  }\n  return updateMetadata;\n}\n\nfunction getPromisifiedSdk(requestFetchAdapter, config) {\n  // Use dynamically overridden AcquisitionSdk during tests.\n  const sdk = new module.exports.AcquisitionSdk(requestFetchAdapter, config);\n  sdk.queryUpdateWithCurrentPackage = (queryPackage) => {\n    return new Promise((resolve, reject) => {\n      module.exports.AcquisitionSdk.prototype.queryUpdateWithCurrentPackage.call(sdk, queryPackage, (err, update) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(update);\n        }\n      });\n    });\n  };\n\n  sdk.reportStatusDeploy = (deployedPackage, status, previousLabelOrAppVersion, previousDeploymentKey) => {\n    return new Promise((resolve, reject) => {\n      module.exports.AcquisitionSdk.prototype.reportStatusDeploy.call(sdk, deployedPackage, status, previousLabelOrAppVersion, previousDeploymentKey, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n\n  sdk.reportStatusDownload = (downloadedPackage) => {\n    return new Promise((resolve, reject) => {\n      module.exports.AcquisitionSdk.prototype.reportStatusDownload.call(sdk, downloadedPackage, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  };\n\n  return sdk;\n}\n\n// This ensures that notifyApplicationReadyInternal is only called once\n// in the lifetime of this module instance.\nconst notifyApplicationReady = (() => {\n  let notifyApplicationReadyPromise;\n  return () => {\n    if (!notifyApplicationReadyPromise) {\n      notifyApplicationReadyPromise = notifyApplicationReadyInternal();\n    }\n\n    return notifyApplicationReadyPromise;\n  };\n})();\n\nasync function notifyApplicationReadyInternal() {\n  await NativeCodePush.notifyApplicationReady();\n  const statusReport = await NativeCodePush.getNewStatusReport();\n  statusReport && tryReportStatus(statusReport); // Don't wait for this to complete.\n\n  return statusReport;\n}\n\nasync function tryReportStatus(statusReport, resumeListener) {\n  const config = await getConfiguration();\n  const previousLabelOrAppVersion = statusReport.previousLabelOrAppVersion;\n  const previousDeploymentKey = statusReport.previousDeploymentKey || config.deploymentKey;\n  try {\n    if (statusReport.appVersion) {\n      log(`Reporting binary update (${statusReport.appVersion})`);\n\n      if (!config.deploymentKey) {\n        throw new Error(\"Deployment key is missed\");\n      }\n\n      const sdk = getPromisifiedSdk(requestFetchAdapter, config);\n      await sdk.reportStatusDeploy(/* deployedPackage */ null, /* status */ null, previousLabelOrAppVersion, previousDeploymentKey);\n    } else {\n      const label = statusReport.package.label;\n      if (statusReport.status === \"DeploymentSucceeded\") {\n        log(`Reporting CodePush update success (${label})`);\n      } else {\n        log(`Reporting CodePush update rollback (${label})`);\n        await NativeCodePush.setLatestRollbackInfo(statusReport.package.packageHash);\n      }\n\n      config.deploymentKey = statusReport.package.deploymentKey;\n      const sdk = getPromisifiedSdk(requestFetchAdapter, config);\n      await sdk.reportStatusDeploy(statusReport.package, statusReport.status, previousLabelOrAppVersion, previousDeploymentKey);\n    }\n\n    NativeCodePush.recordStatusReported(statusReport);\n    resumeListener && AppState.removeEventListener(\"change\", resumeListener);\n  } catch (e) {\n    log(`Report status failed: ${JSON.stringify(statusReport)}`);\n    NativeCodePush.saveStatusReportForRetry(statusReport);\n    // Try again when the app resumes\n    if (!resumeListener) {\n      resumeListener = async (newState) => {\n        if (newState !== \"active\") return;\n        const refreshedStatusReport = await NativeCodePush.getNewStatusReport();\n        if (refreshedStatusReport) {\n          tryReportStatus(refreshedStatusReport, resumeListener);\n        } else {\n          AppState.removeEventListener(\"change\", resumeListener);\n        }\n      };\n      AppState.addEventListener(\"change\", resumeListener);\n    }\n  }\n}\n\nasync function shouldUpdateBeIgnored(remotePackage, syncOptions) {\n  let { rollbackRetryOptions } = syncOptions;\n\n  const isFailedPackage = remotePackage && remotePackage.failedInstall;\n  if (!isFailedPackage || !syncOptions.ignoreFailedUpdates) {\n    return false;\n  }\n\n  if (!rollbackRetryOptions) {\n    return true;\n  }\n\n  if (typeof rollbackRetryOptions !== \"object\") {\n    rollbackRetryOptions = CodePush.DEFAULT_ROLLBACK_RETRY_OPTIONS;\n  } else {\n    rollbackRetryOptions = { ...CodePush.DEFAULT_ROLLBACK_RETRY_OPTIONS, ...rollbackRetryOptions };\n  }\n\n  if (!validateRollbackRetryOptions(rollbackRetryOptions)) {\n    return true;\n  }\n\n  const latestRollbackInfo = await NativeCodePush.getLatestRollbackInfo();\n  if (!validateLatestRollbackInfo(latestRollbackInfo, remotePackage.packageHash)) {\n    log(\"The latest rollback info is not valid.\");\n    return true;\n  }\n\n  const { delayInHours, maxRetryAttempts } = rollbackRetryOptions;\n  const hoursSinceLatestRollback = (Date.now() - latestRollbackInfo.time) / (1000 * 60 * 60);\n  if (hoursSinceLatestRollback >= delayInHours && maxRetryAttempts >= latestRollbackInfo.count) {\n    log(\"Previous rollback should be ignored due to rollback retry options.\");\n    return false;\n  }\n\n  return true;\n}\n\nfunction validateLatestRollbackInfo(latestRollbackInfo, packageHash) {\n  return latestRollbackInfo &&\n    latestRollbackInfo.time &&\n    latestRollbackInfo.count &&\n    latestRollbackInfo.packageHash &&\n    latestRollbackInfo.packageHash === packageHash;\n}\n\nfunction validateRollbackRetryOptions(rollbackRetryOptions) {\n  if (typeof rollbackRetryOptions.delayInHours !== \"number\") {\n    log(\"The 'delayInHours' rollback retry parameter must be a number.\");\n    return false;\n  }\n\n  if (typeof rollbackRetryOptions.maxRetryAttempts !== \"number\") {\n    log(\"The 'maxRetryAttempts' rollback retry parameter must be a number.\");\n    return false;\n  }\n\n  if (rollbackRetryOptions.maxRetryAttempts < 1) {\n    log(\"The 'maxRetryAttempts' rollback retry parameter cannot be less then 1.\");\n    return false;\n  }\n\n  return true;\n}\n\nvar testConfig;\n\n// This function is only used for tests. Replaces the default SDK, configuration and native bridge\nfunction setUpTestDependencies(testSdk, providedTestConfig, testNativeBridge) {\n  if (testSdk) module.exports.AcquisitionSdk = testSdk;\n  if (providedTestConfig) testConfig = providedTestConfig;\n  if (testNativeBridge) NativeCodePush = testNativeBridge;\n}\n\nasync function restartApp(onlyIfUpdateIsPending = false) {\n  NativeCodePush.restartApp(onlyIfUpdateIsPending);\n}\n\n// This function allows only one syncInternal operation to proceed at any given time.\n// Parallel calls to sync() while one is ongoing yields CodePush.SyncStatus.SYNC_IN_PROGRESS.\nconst sync = (() => {\n  let syncInProgress = false;\n  const setSyncCompleted = () => { syncInProgress = false; };\n\n  return (options = {}, syncStatusChangeCallback, downloadProgressCallback, handleBinaryVersionMismatchCallback) => {\n    let syncStatusCallbackWithTryCatch, downloadProgressCallbackWithTryCatch;\n    if (typeof syncStatusChangeCallback === \"function\") {\n      syncStatusCallbackWithTryCatch = (...args) => {\n        try {\n          syncStatusChangeCallback(...args);\n        } catch (error) {\n          log(`An error has occurred : ${error.stack}`);\n        }\n      }\n    }\n\n    if (typeof downloadProgressCallback === \"function\") {\n      downloadProgressCallbackWithTryCatch = (...args) => {\n        try {\n          downloadProgressCallback(...args);\n        } catch (error) {\n          log(`An error has occurred: ${error.stack}`);\n        }\n      }\n    }\n\n    if (syncInProgress) {\n      typeof syncStatusCallbackWithTryCatch === \"function\"\n        ? syncStatusCallbackWithTryCatch(CodePush.SyncStatus.SYNC_IN_PROGRESS)\n        : log(\"Sync already in progress.\");\n      return Promise.resolve(CodePush.SyncStatus.SYNC_IN_PROGRESS);\n    }\n\n    syncInProgress = true;\n    const syncPromise = syncInternal(options, syncStatusCallbackWithTryCatch, downloadProgressCallbackWithTryCatch, handleBinaryVersionMismatchCallback);\n    syncPromise\n      .then(setSyncCompleted)\n      .catch(setSyncCompleted);\n\n    return syncPromise;\n  };\n})();\n\n/*\n * The syncInternal method provides a simple, one-line experience for\n * incorporating the check, download and installation of an update.\n *\n * It simply composes the existing API methods together and adds additional\n * support for respecting mandatory updates, ignoring previously failed\n * releases, and displaying a standard confirmation UI to the end-user\n * when an update is available.\n */\nasync function syncInternal(options = {}, syncStatusChangeCallback, downloadProgressCallback, handleBinaryVersionMismatchCallback) {\n  let resolvedInstallMode;\n  const syncOptions = {\n    deploymentKey: null,\n    ignoreFailedUpdates: true,\n    rollbackRetryOptions: null,\n    installMode: CodePush.InstallMode.ON_NEXT_RESTART,\n    mandatoryInstallMode: CodePush.InstallMode.IMMEDIATE,\n    minimumBackgroundDuration: 0,\n    updateDialog: null,\n    ...options\n  };\n\n  syncStatusChangeCallback = typeof syncStatusChangeCallback === \"function\"\n    ? syncStatusChangeCallback\n    : (syncStatus) => {\n        switch(syncStatus) {\n          case CodePush.SyncStatus.CHECKING_FOR_UPDATE:\n            log(\"Checking for update.\");\n            break;\n          case CodePush.SyncStatus.AWAITING_USER_ACTION:\n            log(\"Awaiting user action.\");\n            break;\n          case CodePush.SyncStatus.DOWNLOADING_PACKAGE:\n            log(\"Downloading package.\");\n            break;\n          case CodePush.SyncStatus.INSTALLING_UPDATE:\n            log(\"Installing update.\");\n            break;\n          case CodePush.SyncStatus.UP_TO_DATE:\n            log(\"App is up to date.\");\n            break;\n          case CodePush.SyncStatus.UPDATE_IGNORED:\n            log(\"User cancelled the update.\");\n            break;\n          case CodePush.SyncStatus.UPDATE_INSTALLED:\n            if (resolvedInstallMode == CodePush.InstallMode.ON_NEXT_RESTART) {\n              log(\"Update is installed and will be run on the next app restart.\");\n            } else if (resolvedInstallMode == CodePush.InstallMode.ON_NEXT_RESUME) {\n              if (syncOptions.minimumBackgroundDuration > 0) {\n                log(`Update is installed and will be run after the app has been in the background for at least ${syncOptions.minimumBackgroundDuration} seconds.`);\n              } else {\n                log(\"Update is installed and will be run when the app next resumes.\");\n              }\n            }\n            break;\n          case CodePush.SyncStatus.UNKNOWN_ERROR:\n            log(\"An unknown error occurred.\");\n            break;\n        }\n      };\n\n  try {\n    await CodePush.notifyApplicationReady();\n\n    syncStatusChangeCallback(CodePush.SyncStatus.CHECKING_FOR_UPDATE);\n    const remotePackage = await checkForUpdate(syncOptions.deploymentKey, handleBinaryVersionMismatchCallback);\n\n    const doDownloadAndInstall = async () => {\n      syncStatusChangeCallback(CodePush.SyncStatus.DOWNLOADING_PACKAGE);\n      const localPackage = await remotePackage.download(downloadProgressCallback);\n\n      // Determine the correct install mode based on whether the update is mandatory or not.\n      resolvedInstallMode = localPackage.isMandatory ? syncOptions.mandatoryInstallMode : syncOptions.installMode;\n\n      syncStatusChangeCallback(CodePush.SyncStatus.INSTALLING_UPDATE);\n      await localPackage.install(resolvedInstallMode, syncOptions.minimumBackgroundDuration, () => {\n        syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_INSTALLED);\n      });\n\n      return CodePush.SyncStatus.UPDATE_INSTALLED;\n    };\n\n    const updateShouldBeIgnored = await shouldUpdateBeIgnored(remotePackage, syncOptions);\n\n    if (!remotePackage || updateShouldBeIgnored) {\n      if (updateShouldBeIgnored) {\n          log(\"An update is available, but it is being ignored due to having been previously rolled back.\");\n      }\n\n      const currentPackage = await CodePush.getCurrentPackage();\n      if (currentPackage && currentPackage.isPending) {\n        syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_INSTALLED);\n        return CodePush.SyncStatus.UPDATE_INSTALLED;\n      } else {\n        syncStatusChangeCallback(CodePush.SyncStatus.UP_TO_DATE);\n        return CodePush.SyncStatus.UP_TO_DATE;\n      }\n    } else if (syncOptions.updateDialog) {\n      // updateDialog supports any truthy value (e.g. true, \"goo\", 12),\n      // but we should treat a non-object value as just the default dialog\n      if (typeof syncOptions.updateDialog !== \"object\") {\n        syncOptions.updateDialog = CodePush.DEFAULT_UPDATE_DIALOG;\n      } else {\n        syncOptions.updateDialog = { ...CodePush.DEFAULT_UPDATE_DIALOG, ...syncOptions.updateDialog };\n      }\n\n      return await new Promise((resolve, reject) => {\n        let message = null;\n        let installButtonText = null;\n\n        const dialogButtons = [];\n\n        if (remotePackage.isMandatory) {\n          message = syncOptions.updateDialog.mandatoryUpdateMessage;\n          installButtonText = syncOptions.updateDialog.mandatoryContinueButtonLabel;\n        } else {\n          message = syncOptions.updateDialog.optionalUpdateMessage;\n          installButtonText = syncOptions.updateDialog.optionalInstallButtonLabel;\n          // Since this is an optional update, add a button\n          // to allow the end-user to ignore it\n          dialogButtons.push({\n            text: syncOptions.updateDialog.optionalIgnoreButtonLabel,\n            onPress: () => {\n              syncStatusChangeCallback(CodePush.SyncStatus.UPDATE_IGNORED);\n              resolve(CodePush.SyncStatus.UPDATE_IGNORED);\n            }\n          });\n        }\n        \n        // Since the install button should be placed to the \n        // right of any other button, add it last\n        dialogButtons.push({\n          text: installButtonText,\n          onPress:() => {\n            doDownloadAndInstall()\n              .then(resolve, reject);\n          }\n        })\n\n        // If the update has a description, and the developer\n        // explicitly chose to display it, then set that as the message\n        if (syncOptions.updateDialog.appendReleaseDescription && remotePackage.description) {\n          message += `${syncOptions.updateDialog.descriptionPrefix} ${remotePackage.description}`;\n        }\n\n        syncStatusChangeCallback(CodePush.SyncStatus.AWAITING_USER_ACTION);\n        Alert.alert(syncOptions.updateDialog.title, message, dialogButtons);\n      });\n    } else {\n      return await doDownloadAndInstall();\n    }\n  } catch (error) {\n    syncStatusChangeCallback(CodePush.SyncStatus.UNKNOWN_ERROR);\n    log(error.message);\n    throw error;\n  }\n};\n\nlet CodePush;\n\nfunction codePushify(options = {}) {\n  let React;\n  let ReactNative = require(\"react-native\");\n\n  try { React = require(\"react\"); } catch (e) { }\n  if (!React) {\n    try { React = ReactNative.React; } catch (e) { }\n    if (!React) {\n      throw new Error(\"Unable to find the 'React' module.\");\n    }\n  }\n\n  if (!React.Component) {\n    throw new Error(\n`Unable to find the \"Component\" class, please either:\n1. Upgrade to a newer version of React Native that supports it, or\n2. Call the codePush.sync API in your component instead of using the @codePush decorator`\n    );\n  }\n\n  var decorator = (RootComponent) => {\n    const extended = class CodePushComponent extends React.Component {\n      componentDidMount() {\n        if (options.checkFrequency === CodePush.CheckFrequency.MANUAL) {\n          CodePush.notifyAppReady();\n        } else {\n          let rootComponentInstance = this.refs.rootComponent;\n\n          let syncStatusCallback;\n          if (rootComponentInstance && rootComponentInstance.codePushStatusDidChange) {\n            syncStatusCallback = rootComponentInstance.codePushStatusDidChange;\n            if (rootComponentInstance instanceof React.Component) {\n              syncStatusCallback = syncStatusCallback.bind(rootComponentInstance);\n            }\n          }\n\n          let downloadProgressCallback;\n          if (rootComponentInstance && rootComponentInstance.codePushDownloadDidProgress) {\n            downloadProgressCallback = rootComponentInstance.codePushDownloadDidProgress;\n            if (rootComponentInstance instanceof React.Component) {\n              downloadProgressCallback = downloadProgressCallback.bind(rootComponentInstance);\n            }\n          }\n\n          let handleBinaryVersionMismatchCallback;\n          if (rootComponentInstance && rootComponentInstance.codePushOnBinaryVersionMismatch) {\n            handleBinaryVersionMismatchCallback = rootComponentInstance.codePushOnBinaryVersionMismatch;\n            if (rootComponentInstance instanceof React.Component) {\n              handleBinaryVersionMismatchCallback = handleBinaryVersionMismatchCallback.bind(rootComponentInstance);\n            }\n          }\n\n          CodePush.sync(options, syncStatusCallback, downloadProgressCallback, handleBinaryVersionMismatchCallback);\n          if (options.checkFrequency === CodePush.CheckFrequency.ON_APP_RESUME) {\n            ReactNative.AppState.addEventListener(\"change\", (newState) => {\n              newState === \"active\" && CodePush.sync(options, syncStatusCallback, downloadProgressCallback);\n            });\n          }\n        }\n      }\n\n      render() {\n        const props = {...this.props};\n\n        // we can set ref property on class components only (not stateless)\n        // check it by render method\n        if (RootComponent.prototype.render) {\n          props.ref = \"rootComponent\";\n        }\n\n        return <RootComponent {...props} />\n      }\n    }\n\n    return hoistStatics(extended, RootComponent);\n  }\n\n  if (typeof options === \"function\") {\n    // Infer that the root component was directly passed to us.\n    return decorator(options);\n  } else {\n    return decorator;\n  }\n}\n\n// If the \"NativeCodePush\" variable isn't defined, then\n// the app didn't properly install the native module,\n// and therefore, it doesn't make sense initializing\n// the JS interface when it wouldn't work anyways.\nif (NativeCodePush) {\n  CodePush = codePushify;\n  Object.assign(CodePush, {\n    AcquisitionSdk: Sdk,\n    checkForUpdate,\n    getConfiguration,\n    getCurrentPackage,\n    getUpdateMetadata,\n    log,\n    notifyAppReady: notifyApplicationReady,\n    notifyApplicationReady,\n    restartApp,\n    setUpTestDependencies,\n    sync,\n    disallowRestart: NativeCodePush.disallow,\n    allowRestart: NativeCodePush.allow,\n    clearUpdates: NativeCodePush.clearUpdates,\n    InstallMode: {\n      IMMEDIATE: NativeCodePush.codePushInstallModeImmediate, // Restart the app immediately\n      ON_NEXT_RESTART: NativeCodePush.codePushInstallModeOnNextRestart, // Don't artificially restart the app. Allow the update to be \"picked up\" on the next app restart\n      ON_NEXT_RESUME: NativeCodePush.codePushInstallModeOnNextResume, // Restart the app the next time it is resumed from the background\n      ON_NEXT_SUSPEND: NativeCodePush.codePushInstallModeOnNextSuspend // Restart the app _while_ it is in the background,\n      // but only after it has been in the background for \"minimumBackgroundDuration\" seconds (0 by default),\n      // so that user context isn't lost unless the app suspension is long enough to not matter\n    },\n    SyncStatus: {\n      UP_TO_DATE: 0, // The running app is up-to-date\n      UPDATE_INSTALLED: 1, // The app had an optional/mandatory update that was successfully downloaded and is about to be installed.\n      UPDATE_IGNORED: 2, // The app had an optional update and the end-user chose to ignore it\n      UNKNOWN_ERROR: 3,\n      SYNC_IN_PROGRESS: 4, // There is an ongoing \"sync\" operation in progress.\n      CHECKING_FOR_UPDATE: 5,\n      AWAITING_USER_ACTION: 6,\n      DOWNLOADING_PACKAGE: 7,\n      INSTALLING_UPDATE: 8\n    },\n    CheckFrequency: {\n      ON_APP_START: 0,\n      ON_APP_RESUME: 1,\n      MANUAL: 2\n    },\n    UpdateState: {\n      RUNNING: NativeCodePush.codePushUpdateStateRunning,\n      PENDING: NativeCodePush.codePushUpdateStatePending,\n      LATEST: NativeCodePush.codePushUpdateStateLatest\n    },\n    DeploymentStatus: {\n      FAILED: \"DeploymentFailed\",\n      SUCCEEDED: \"DeploymentSucceeded\",\n    },\n    DEFAULT_UPDATE_DIALOG: {\n      appendReleaseDescription: false,\n      descriptionPrefix: \" Description: \",\n      mandatoryContinueButtonLabel: \"Continue\",\n      mandatoryUpdateMessage: \"An update is available that must be installed.\",\n      optionalIgnoreButtonLabel: \"Ignore\",\n      optionalInstallButtonLabel: \"Install\",\n      optionalUpdateMessage: \"An update is available. Would you like to install it?\",\n      title: \"Update available\"\n    },\n    DEFAULT_ROLLBACK_RETRY_OPTIONS: {\n      delayInHours: 24,\n      maxRetryAttempts: 1\n    }\n  });\n} else {\n  log(\"The CodePush module doesn't appear to be properly installed. Please double-check that everything is setup correctly.\");\n}\n\nmodule.exports = CodePush;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}