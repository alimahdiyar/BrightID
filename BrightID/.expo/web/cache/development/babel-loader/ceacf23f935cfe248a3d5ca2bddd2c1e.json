{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updatePendingConnection = exports.selectPendingConnectionById = exports.selectPendingConnectionByBrightId = exports.selectAllUnconfirmedConnectionsByChannelIds = exports.selectAllUnconfirmedConnections = exports.selectAllPendingConnectionsByChannelIds = exports.selectAllPendingConnections = exports.selectAllPendingConnectionIds = exports.removePendingConnection = exports.removeAllPendingConnections = exports.pendingConnection_states = exports.newPendingConnection = exports.default = exports.confirmPendingConnection = exports.addFakePendingConnection = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _toolkit = require(\"@reduxjs/toolkit\");\n\nvar _i18next = _interopRequireDefault(require(\"i18next\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _channelSlice = require(\"./channelSlice\");\n\nvar _connectionsSlice = require(\"../../reducer/connectionsSlice\");\n\nvar _cryptoHelper = require(\"../../utils/cryptoHelper\");\n\nvar _constants = require(\"../../utils/constants\");\n\nvar _createDeepEqualStringArraySelector = require(\"../../utils/createDeepEqualStringArraySelector\");\n\nvar _brightidError = _interopRequireWildcard(require(\"../../api/brightidError\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar pendingConnectionsAdapter = (0, _toolkit.createEntityAdapter)({\n  selectId: function selectId(pendingConnection) {\n    return pendingConnection.profileId;\n  }\n});\nvar pendingConnection_states;\nexports.pendingConnection_states = pendingConnection_states;\n\n(function (pendingConnection_states) {\n  pendingConnection_states[\"INITIAL\"] = \"INITIAL\";\n  pendingConnection_states[\"DOWNLOADING\"] = \"DOWNLOADING\";\n  pendingConnection_states[\"UNCONFIRMED\"] = \"UNCONFIRMED\";\n  pendingConnection_states[\"CONFIRMING\"] = \"CONFIRMING\";\n  pendingConnection_states[\"CONFIRMED\"] = \"CONFIRMED\";\n  pendingConnection_states[\"ERROR\"] = \"ERROR\";\n  pendingConnection_states[\"MYSELF\"] = \"MYSELF\";\n  pendingConnection_states[\"EXPIRED\"] = \"EXPIRED\";\n})(pendingConnection_states || (exports.pendingConnection_states = pendingConnection_states = {}));\n\nvar newPendingConnection = (0, _toolkit.createAsyncThunk)('pendingConnections/newPendingConnection', function _callee(_ref, _ref2) {\n  var channelId, profileId, api, getState, channel, profileData, sharedProfile, msg, _msg, alreadyPending, existingConnection, profileInfo, pendingConnectionData;\n\n  return _regenerator.default.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          channelId = _ref.channelId, profileId = _ref.profileId, api = _ref.api;\n          getState = _ref2.getState;\n          console.log(\"new pending connection \" + profileId + \" in channel \" + channelId);\n          channel = (0, _channelSlice.selectChannelById)(getState(), channelId);\n\n          if (channel) {\n            _context.next = 6;\n            break;\n          }\n\n          throw new Error('Channel does not exist');\n\n        case 6:\n          _context.next = 8;\n          return _regenerator.default.awrap(channel.api.download({\n            channelId: channelId,\n            dataId: profileId\n          }));\n\n        case 8:\n          profileData = _context.sent;\n          sharedProfile = (0, _cryptoHelper.decryptData)(profileData, channel.aesKey);\n\n          if (!(sharedProfile.version === undefined || sharedProfile.version < _constants.PROFILE_VERSION)) {\n            _context.next = 16;\n            break;\n          }\n\n          msg = _i18next.default.t('pendingConnection.alert.text.otherOutdated', {\n            name: \"\" + sharedProfile.name\n          });\n\n          _reactNative.Alert.alert(_i18next.default.t('pendingConnection.alert.title.connectionImpossible'), msg);\n\n          throw new Error(msg);\n\n        case 16:\n          if (!(sharedProfile.version > _constants.PROFILE_VERSION)) {\n            _context.next = 20;\n            break;\n          }\n\n          _msg = _i18next.default.t('pendingConnection.alert.text.localOutdated', {\n            name: \"\" + sharedProfile.name\n          });\n\n          _reactNative.Alert.alert(_i18next.default.t('pendingConnection.alert.title.connectionImpossible'), _msg);\n\n          throw new Error(_msg);\n\n        case 20:\n          alreadyPending = selectAllUnconfirmedConnections(getState()).find(function (pc) {\n            return sharedProfile.id === pc.pendingConnectionData.sharedProfile.id;\n          });\n\n          if (!alreadyPending) {\n            _context.next = 23;\n            break;\n          }\n\n          throw new Error(\"PendingConnection \" + profileId + \": BrightId \" + sharedProfile.id + \" is already existing.\");\n\n        case 23:\n          existingConnection = (0, _connectionsSlice.selectConnectionById)(getState(), sharedProfile.id);\n\n          if (existingConnection) {\n            console.log(sharedProfile.id + \" exists.\");\n          }\n\n          _context.prev = 25;\n          _context.next = 28;\n          return _regenerator.default.awrap(api.getProfile(sharedProfile.id));\n\n        case 28:\n          profileInfo = _context.sent;\n          _context.next = 39;\n          break;\n\n        case 31:\n          _context.prev = 31;\n          _context.t0 = _context[\"catch\"](25);\n\n          if (!(_context.t0 instanceof _brightidError.default && _context.t0.errorNum === _brightidError.USER_NOT_FOUND)) {\n            _context.next = 38;\n            break;\n          }\n\n          if (!existingConnection) {\n            _context.next = 36;\n            break;\n          }\n\n          throw new Error(\"PendingConnection \" + profileId + \": User already connected, but unknown in node api.\");\n\n        case 36:\n          _context.next = 39;\n          break;\n\n        case 38:\n          throw _context.t0;\n\n        case 39:\n          pendingConnectionData = {\n            sharedProfile: sharedProfile,\n            profileInfo: profileInfo,\n            existingConnection: existingConnection,\n            myself: sharedProfile.id === getState().user.id\n          };\n          return _context.abrupt(\"return\", pendingConnectionData);\n\n        case 41:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[25, 31]], Promise);\n});\nexports.newPendingConnection = newPendingConnection;\nvar initialState = pendingConnectionsAdapter.getInitialState();\nvar pendingConnectionsSlice = (0, _toolkit.createSlice)({\n  name: 'pendingConnections',\n  initialState: initialState,\n  reducers: {\n    addFakePendingConnection: pendingConnectionsAdapter.addOne,\n    removePendingConnection: pendingConnectionsAdapter.removeOne,\n    updatePendingConnection: pendingConnectionsAdapter.updateOne,\n    removeAllPendingConnections: pendingConnectionsAdapter.removeAll,\n    confirmPendingConnection: function confirmPendingConnection(state, action) {\n      var id = action.payload;\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: id,\n        changes: {\n          state: pendingConnection_states.CONFIRMED\n        }\n      });\n    }\n  },\n  extraReducers: function extraReducers(builder) {\n    builder.addCase(newPendingConnection.pending, function (state, action) {\n      state = pendingConnectionsAdapter.addOne(state, {\n        profileId: action.meta.arg.profileId,\n        channelId: action.meta.arg.channelId,\n        state: pendingConnection_states.DOWNLOADING\n      });\n    }).addCase(newPendingConnection.rejected, function (state, action) {\n      console.log(\"Error adding pending connection:\");\n      console.log(action.error.message);\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: action.meta.arg.profileId,\n        changes: {\n          state: pendingConnection_states.ERROR\n        }\n      });\n    }).addCase(newPendingConnection.fulfilled, function (state, _ref3) {\n      var meta = _ref3.meta,\n          payload = _ref3.payload;\n      var profileId = meta.arg.profileId;\n      var changes = {\n        state: payload.myself ? pendingConnection_states.MYSELF : pendingConnection_states.UNCONFIRMED,\n        pendingConnectionData: payload\n      };\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id: profileId,\n        changes: changes\n      });\n    }).addCase(_channelSlice.removeChannel, function (state, action) {\n      var channelId = action.payload;\n      var deleteIds = state.ids.filter(function (id) {\n        return state.entities[id].channelId === channelId;\n      });\n      console.log(\"Channel \" + channelId + \" deleted - removing \" + deleteIds.length + \" pending connections associated to channel\");\n      state = pendingConnectionsAdapter.removeMany(state, deleteIds);\n    });\n  }\n});\n\nvar _pendingConnectionsAd = pendingConnectionsAdapter.getSelectors(function (state) {\n  return state.pendingConnections;\n}),\n    selectAllPendingConnections = _pendingConnectionsAd.selectAll,\n    selectPendingConnectionById = _pendingConnectionsAd.selectById,\n    selectAllPendingConnectionIds = _pendingConnectionsAd.selectIds;\n\nexports.selectAllPendingConnectionIds = selectAllPendingConnectionIds;\nexports.selectPendingConnectionById = selectPendingConnectionById;\nexports.selectAllPendingConnections = selectAllPendingConnections;\nvar selectAllUnconfirmedConnections = (0, _toolkit.createSelector)(selectAllPendingConnections, function (pendingConnections) {\n  return pendingConnections.filter(function (pc) {\n    return pc.state === pendingConnection_states.UNCONFIRMED;\n  });\n});\nexports.selectAllUnconfirmedConnections = selectAllUnconfirmedConnections;\nvar selectPendingConnectionByBrightId = (0, _toolkit.createSelector)(selectAllPendingConnections, function (_, brightId) {\n  return brightId;\n}, function (pendingConnections, brightId) {\n  return pendingConnections.find(function (pc) {\n    return brightId === pc.brightId;\n  });\n});\nexports.selectPendingConnectionByBrightId = selectPendingConnectionByBrightId;\nvar selectAllPendingConnectionsByChannelIds = (0, _createDeepEqualStringArraySelector.createDeepEqualStringArraySelector)(selectAllPendingConnections, function (_, channelIds) {\n  return channelIds;\n}, function (pendingConnections, channelIds) {\n  console.log(\"selectAllPendingConnectionsByChannelIds \" + channelIds + \"...\");\n  return pendingConnections.filter(function (pc) {\n    return channelIds.includes(pc.channelId);\n  });\n});\nexports.selectAllPendingConnectionsByChannelIds = selectAllPendingConnectionsByChannelIds;\nvar selectAllUnconfirmedConnectionsByChannelIds = (0, _createDeepEqualStringArraySelector.createDeepEqualStringArraySelector)(selectAllUnconfirmedConnections, function (_, channelIds) {\n  return channelIds;\n}, function (pendingConnections, channelIds) {\n  console.log(\"selectAllUnconfirmedConnectionsByChannelIds \" + channelIds + \"...\");\n  return pendingConnections.filter(function (pc) {\n    return channelIds.includes(pc.channelId);\n  });\n});\nexports.selectAllUnconfirmedConnectionsByChannelIds = selectAllUnconfirmedConnectionsByChannelIds;\nvar _pendingConnectionsSl = pendingConnectionsSlice.actions,\n    updatePendingConnection = _pendingConnectionsSl.updatePendingConnection,\n    removePendingConnection = _pendingConnectionsSl.removePendingConnection,\n    removeAllPendingConnections = _pendingConnectionsSl.removeAllPendingConnections,\n    confirmPendingConnection = _pendingConnectionsSl.confirmPendingConnection,\n    addFakePendingConnection = _pendingConnectionsSl.addFakePendingConnection;\nexports.addFakePendingConnection = addFakePendingConnection;\nexports.confirmPendingConnection = confirmPendingConnection;\nexports.removeAllPendingConnections = removeAllPendingConnections;\nexports.removePendingConnection = removePendingConnection;\nexports.updatePendingConnection = updatePendingConnection;\nvar _default = pendingConnectionsSlice.reducer;\nexports.default = _default;","map":{"version":3,"names":["pendingConnectionsAdapter","createEntityAdapter","selectId","pendingConnection","profileId","pendingConnection_states","newPendingConnection","createAsyncThunk","channelId","api","getState","console","log","channel","selectChannelById","Error","download","dataId","profileData","sharedProfile","decryptData","aesKey","version","undefined","PROFILE_VERSION","msg","i18next","t","name","Alert","alert","alreadyPending","selectAllUnconfirmedConnections","find","pc","id","pendingConnectionData","existingConnection","selectConnectionById","getProfile","profileInfo","BrightidError","errorNum","USER_NOT_FOUND","myself","user","initialState","getInitialState","pendingConnectionsSlice","createSlice","reducers","addFakePendingConnection","addOne","removePendingConnection","removeOne","updatePendingConnection","updateOne","removeAllPendingConnections","removeAll","confirmPendingConnection","state","action","payload","changes","CONFIRMED","extraReducers","builder","addCase","pending","meta","arg","DOWNLOADING","rejected","error","message","ERROR","fulfilled","MYSELF","UNCONFIRMED","removeChannel","deleteIds","ids","filter","entities","length","removeMany","getSelectors","pendingConnections","selectAllPendingConnections","selectAll","selectPendingConnectionById","selectById","selectAllPendingConnectionIds","selectIds","createSelector","selectPendingConnectionByBrightId","_","brightId","selectAllPendingConnectionsByChannelIds","createDeepEqualStringArraySelector","channelIds","includes","selectAllUnconfirmedConnectionsByChannelIds","actions","reducer"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/pendingConnectionSlice.ts"],"sourcesContent":["import {\n  createSlice,\n  createEntityAdapter,\n  createAsyncThunk,\n  createSelector,\n  PayloadAction,\n} from '@reduxjs/toolkit';\nimport i18next from 'i18next';\nimport { Alert } from 'react-native';\nimport {\n  removeChannel,\n  selectChannelById,\n} from '@/components/PendingConnections/channelSlice';\nimport { selectConnectionById } from '@/reducer/connectionsSlice';\nimport { decryptData } from '@/utils/cryptoHelper';\nimport { PROFILE_VERSION } from '@/utils/constants';\nimport { createDeepEqualStringArraySelector } from '@/utils/createDeepEqualStringArraySelector';\nimport BrightidError, { USER_NOT_FOUND } from '@/api/brightidError';\nimport { NodeApi } from '@/api/brightId';\n\nconst pendingConnectionsAdapter = createEntityAdapter<PendingConnection>({\n  selectId: (pendingConnection) => pendingConnection.profileId,\n});\n\n/*\n  PendingConnection slice contains all pending connections and their profile info\n\n  What is a pendingConnection:\n   - 'id': unique id of this pending connection. Is also profileId on the profile server.\n   - 'channelId': channel this pendingConnection is associated with\n   - 'state': state of this pending connection (valid states TBD)\n   - 'brightId': the brightId if the connection\n   - 'name'\n   - 'photo' (base64-encoded)\n */\nexport enum pendingConnection_states {\n  INITIAL = 'INITIAL',\n  DOWNLOADING = 'DOWNLOADING',\n  UNCONFIRMED = 'UNCONFIRMED',\n  CONFIRMING = 'CONFIRMING',\n  CONFIRMED = 'CONFIRMED',\n  ERROR = 'ERROR',\n  MYSELF = 'MYSELF',\n  EXPIRED = 'EXPIRED',\n}\n\nexport const newPendingConnection = createAsyncThunk<\n  PendingConnectionData,\n  { channelId: string; profileId: string; api: NodeApi },\n  { state: State }\n>(\n  'pendingConnections/newPendingConnection',\n  async ({ channelId, profileId, api }, { getState }) => {\n    console.log(`new pending connection ${profileId} in channel ${channelId}`);\n\n    const channel = selectChannelById(getState(), channelId);\n\n    if (!channel) {\n      throw new Error('Channel does not exist');\n    }\n\n    // download profile\n    const profileData: string = await channel.api.download({\n      channelId,\n      dataId: profileId,\n    });\n\n    const sharedProfile = decryptData(\n      profileData,\n      channel.aesKey,\n    ) as SharedProfile;\n\n    // compare profile version\n    if (\n      sharedProfile.version === undefined || // very old client version\n      sharedProfile.version < PROFILE_VERSION // old client version\n    ) {\n      // other user needs to update his client\n      const msg = i18next.t('pendingConnection.alert.text.otherOutdated', {\n        name: `${sharedProfile.name}`,\n      });\n      Alert.alert(\n        i18next.t('pendingConnection.alert.title.connectionImpossible'),\n        msg,\n      );\n      throw new Error(msg);\n    } else if (sharedProfile.version > PROFILE_VERSION) {\n      // I need to update my client\n      const msg = i18next.t('pendingConnection.alert.text.localOutdated', {\n        name: `${sharedProfile.name}`,\n      });\n      Alert.alert(\n        i18next.t('pendingConnection.alert.title.connectionImpossible'),\n        msg,\n      );\n      throw new Error(msg);\n    }\n    // Is this brightID already in the list of unconfirmed pending connections? Can happen if the same user joins a\n    // channel multiple times (e.g. if users app crashed)\n    const alreadyPending = selectAllUnconfirmedConnections(getState()).find(\n      (pc) => sharedProfile.id === pc.pendingConnectionData.sharedProfile.id,\n    );\n    if (alreadyPending) {\n      throw new Error(\n        `PendingConnection ${profileId}: BrightId ${sharedProfile.id} is already existing.`,\n      );\n    }\n\n    // Is this a known connection reconnecting?\n    const existingConnection = selectConnectionById(\n      getState(),\n      sharedProfile.id,\n    );\n    if (existingConnection) {\n      console.log(`${sharedProfile.id} exists.`);\n    }\n\n    let profileInfo: ProfileInfo;\n    try {\n      profileInfo = await api.getProfile(sharedProfile.id);\n    } catch (err) {\n      if (err instanceof BrightidError && err.errorNum === USER_NOT_FOUND) {\n        // this must be a new user not yet existing on backend.\n        if (existingConnection) {\n          // handle edge case:\n          // The other user is not known in the backend, but already connected with us. This should never happen :/\n          // Since profileInfo is required for reconnecting we can not start the reconnect flow.\n          throw new Error(\n            `PendingConnection ${profileId}: User already connected, but unknown in node api.`,\n          );\n        }\n      } else {\n        throw err;\n      }\n    }\n\n    const pendingConnectionData: PendingConnectionData = {\n      sharedProfile,\n      profileInfo,\n      existingConnection,\n      myself: sharedProfile.id === getState().user.id,\n    };\n    return pendingConnectionData;\n  },\n);\n\n// By default, `createEntityAdapter` gives you `{ ids: [], entities: {} }`.\n// If you want to track 'loading' or other keys, you would initialize them here:\n// `getInitialState({ loading: false, activeRequestId: null })`\nconst initialState = pendingConnectionsAdapter.getInitialState();\n\nconst pendingConnectionsSlice = createSlice({\n  name: 'pendingConnections',\n  initialState,\n  reducers: {\n    addFakePendingConnection: pendingConnectionsAdapter.addOne,\n    removePendingConnection: pendingConnectionsAdapter.removeOne,\n    updatePendingConnection: pendingConnectionsAdapter.updateOne,\n    removeAllPendingConnections: pendingConnectionsAdapter.removeAll,\n    confirmPendingConnection(state, action: PayloadAction<string>) {\n      const id = action.payload;\n      state = pendingConnectionsAdapter.updateOne(state, {\n        id,\n        changes: {\n          state: pendingConnection_states.CONFIRMED,\n        },\n      });\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(newPendingConnection.pending, (state, action) => {\n        // This is called before actual thunk code is executed. Thunk argument is available via\n        // action.meta.arg.\n\n        // Add pending connection in DOWNLOADING state.\n        state = pendingConnectionsAdapter.addOne(state, {\n          profileId: action.meta.arg.profileId,\n          channelId: action.meta.arg.channelId,\n          state: pendingConnection_states.DOWNLOADING,\n        });\n      })\n      .addCase(newPendingConnection.rejected, (state, action) => {\n        // This is called if anything goes wrong\n        console.log(`Error adding pending connection:`);\n        console.log(action.error.message);\n\n        state = pendingConnectionsAdapter.updateOne(state, {\n          id: action.meta.arg.profileId,\n          changes: {\n            state: pendingConnection_states.ERROR,\n          },\n        });\n      })\n      .addCase(newPendingConnection.fulfilled, (state, { meta, payload }) => {\n        // thunk arguments are available via action.meta.arg:\n        const { profileId } = meta.arg;\n\n        // data returned by thunk is available via action.payload:\n        const changes: Partial<PendingConnection> = {\n          state: payload.myself\n            ? pendingConnection_states.MYSELF\n            : pendingConnection_states.UNCONFIRMED,\n          pendingConnectionData: payload,\n        };\n\n        // Perform the update in redux\n        state = pendingConnectionsAdapter.updateOne(state, {\n          id: profileId,\n          changes,\n        });\n      })\n      .addCase(removeChannel, (state, action) => {\n        const channelId = action.payload;\n        const deleteIds = state.ids.filter(\n          (id) => state.entities[id].channelId === channelId,\n        );\n        console.log(\n          `Channel ${channelId} deleted - removing ${deleteIds.length} pending connections associated to channel`,\n        );\n        state = pendingConnectionsAdapter.removeMany(state, deleteIds);\n      });\n  },\n});\n\n// export selectors\n\nexport const {\n  selectAll: selectAllPendingConnections,\n  selectById: selectPendingConnectionById,\n  selectIds: selectAllPendingConnectionIds,\n} = pendingConnectionsAdapter.getSelectors(\n  (state: State) => state.pendingConnections,\n);\n\nexport const selectAllUnconfirmedConnections = createSelector(\n  selectAllPendingConnections,\n  (pendingConnections) =>\n    pendingConnections.filter(\n      (pc) => pc.state === pendingConnection_states.UNCONFIRMED,\n    ),\n);\n\nexport const selectPendingConnectionByBrightId = createSelector(\n  selectAllPendingConnections,\n  (_, brightId: string) => brightId,\n  (pendingConnections, brightId) => {\n    return pendingConnections.find((pc) => brightId === pc.brightId);\n  },\n);\n\n/*\n  Using DeepEqualStringArraySelector here because there are different inputs:\n  - selectAllPendingConnections/selectAllUnconfirmedConnections:\n    Returns an array of objects directly from state. This is immutable, so we can use\n    referential equality check.\n  - channelIds:\n    This array is created dynamically and will be a new object with each invocation. Therefore\n    we have to use deep equality check\n */\nexport const selectAllPendingConnectionsByChannelIds =\n  createDeepEqualStringArraySelector(\n    selectAllPendingConnections,\n    (_, channelIds: string[]) => channelIds,\n    (pendingConnections, channelIds) => {\n      console.log(`selectAllPendingConnectionsByChannelIds ${channelIds}...`);\n      return pendingConnections.filter((pc) =>\n        channelIds.includes(pc.channelId),\n      );\n    },\n  );\nexport const selectAllUnconfirmedConnectionsByChannelIds =\n  createDeepEqualStringArraySelector(\n    selectAllUnconfirmedConnections,\n    (_, channelIds: string[]) => channelIds,\n    (pendingConnections, channelIds) => {\n      console.log(\n        `selectAllUnconfirmedConnectionsByChannelIds ${channelIds}...`,\n      );\n      return pendingConnections.filter((pc) =>\n        channelIds.includes(pc.channelId),\n      );\n    },\n  );\n\n// export actions\n\nexport const {\n  updatePendingConnection,\n  removePendingConnection,\n  removeAllPendingConnections,\n  confirmPendingConnection,\n  addFakePendingConnection,\n} = pendingConnectionsSlice.actions;\n\nexport default pendingConnectionsSlice.reducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}