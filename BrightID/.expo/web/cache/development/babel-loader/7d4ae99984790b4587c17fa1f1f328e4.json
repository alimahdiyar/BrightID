{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.notificationSubscription = notificationSubscription;\n\nvar _pushNotificationIos = _interopRequireDefault(require(\"@react-native-community/push-notification-ios\"));\n\nvar PushNotification = _interopRequireWildcard(require(\"react-native-push-notification\"));\n\nvar _actions = require(\"./actions\");\n\nvar _store = require(\"./store\");\n\nvar _notificationService = _interopRequireDefault(require(\"./api/notificationService\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction notificationSubscription() {\n  PushNotification.configure({\n    onRegister: function onRegister(_ref) {\n      var token = _ref.token;\n\n      var _store$getState = _store.store.getState(),\n          notifications = _store$getState.notifications;\n\n      if (token) {\n        console.log('RECIEVED_NOTIFICATION_TOKEN', token);\n        var oldDeviceToken = notifications.deviceToken && notifications.deviceToken !== token ? notifications.deviceToken : null;\n\n        _notificationService.default.getToken({\n          deviceToken: token,\n          notificationToken: notifications.notificationToken,\n          oldDeviceToken: oldDeviceToken\n        }).then(function (_ref2) {\n          var notificationToken = _ref2.notificationToken;\n          if (notificationToken && notificationToken !== notifications.notificationToken) _store.store.dispatch((0, _actions.setNotificationToken)(notificationToken));\n        }).catch(function (err) {\n          console.log(err.message);\n        });\n\n        _store.store.dispatch((0, _actions.setDeviceToken)(token));\n      }\n    },\n    onNotification: function onNotification(notification) {\n      console.log('NOTIFICATION:', notification);\n      notification.finish(_pushNotificationIos.default.FetchResult.NoData);\n    },\n    onAction: function onAction(notification) {\n      console.log('ACTION:', notification.action);\n      console.log('NOTIFICATION:', notification);\n    },\n    onRegistrationError: function onRegistrationError(err) {\n      console.log(err.message, err);\n    },\n    permissions: {\n      alert: true,\n      badge: true,\n      sound: true\n    },\n    popInitialNotification: true,\n    requestPermissions: true\n  });\n  PushNotification.createChannel({\n    channelId: 'brightid-main',\n    channelName: 'Brightid Main',\n    channelDescription: 'A channel to recieve BrightID notifications',\n    soundName: 'default',\n    importance: 4,\n    vibrate: true\n  }, function (created) {\n    return console.log(\"createChannel returned '\" + created + \"'\");\n  });\n}","map":{"version":3,"names":["notificationSubscription","PushNotification","configure","onRegister","token","store","getState","notifications","console","log","oldDeviceToken","deviceToken","notificationService","getToken","notificationToken","then","dispatch","setNotificationToken","catch","err","message","setDeviceToken","onNotification","notification","finish","PushNotificationIOS","FetchResult","NoData","onAction","action","onRegistrationError","permissions","alert","badge","sound","popInitialNotification","requestPermissions","createChannel","channelId","channelName","channelDescription","soundName","importance","vibrate","created"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/NotificationService.ts"],"sourcesContent":["import PushNotificationIOS from '@react-native-community/push-notification-ios';\nimport * as PushNotification from 'react-native-push-notification';\nimport { setDeviceToken, setNotificationToken } from '@/actions';\nimport { store } from '@/store';\nimport notificationService from '@/api/notificationService';\n\nexport function notificationSubscription() {\n  // Must be outside of any component LifeCycle (such as `componentDidMount`).\n  PushNotification.configure({\n    // (optional) Called when Token is generated (iOS and Android)\n    onRegister({ token }) {\n      const { notifications } = store.getState();\n\n      if (token) {\n        console.log('RECIEVED_NOTIFICATION_TOKEN', token);\n        // always update the server with our device token.\n        // if notificationToken exists, then our connections already have it\n        // so we need to make sure that the notification server is also synced\n\n        const oldDeviceToken =\n          notifications.deviceToken && notifications.deviceToken !== token\n            ? notifications.deviceToken\n            : null;\n\n        notificationService\n          .getToken({\n            deviceToken: token,\n            notificationToken: notifications.notificationToken,\n            oldDeviceToken,\n          })\n          .then(({ notificationToken }) => {\n            if (\n              notificationToken &&\n              notificationToken !== notifications.notificationToken\n            )\n              store.dispatch(setNotificationToken(notificationToken));\n          })\n          .catch((err) => {\n            console.log(err.message);\n          });\n        store.dispatch(setDeviceToken(token));\n      }\n    },\n\n    // (required) Called when a remote is received or opened, or local notification is opened\n    onNotification(notification) {\n      console.log('NOTIFICATION:', notification);\n\n      // process the notification\n\n      // (required) Called when a remote is received or opened, or local notification is opened\n      notification.finish(PushNotificationIOS.FetchResult.NoData);\n    },\n\n    // (optional) Called when Registered Action is pressed and invokeApp is false, if true onNotification will be called (Android)\n    onAction(notification) {\n      console.log('ACTION:', notification.action);\n      console.log('NOTIFICATION:', notification);\n\n      // process the action\n    },\n\n    // (optional) Called when the user fails to register for remote notifications. Typically occurs when APNS is having issues, or the device is a simulator. (iOS)\n    onRegistrationError(err) {\n      console.log(err.message, err);\n    },\n\n    // IOS ONLY (optional): default: all - Permissions to register.\n    permissions: {\n      alert: true,\n      badge: true,\n      sound: true,\n    },\n\n    // Should the initial notification be popped automatically\n    // default: true\n    popInitialNotification: true,\n\n    /**\n     * (optional) default: true\n     * - Specified if permissions (ios) and token (android and ios) will requested or not,\n     * - if not, you must call PushNotificationsHandler.requestPermissions() later\n     * - if you are not using remote notification or do not have Firebase installed, use this:\n     *     requestPermissions: Platform.OS === 'ios'\n     */\n    requestPermissions: true,\n  });\n\n  PushNotification.createChannel(\n    {\n      channelId: 'brightid-main', // (required)\n      channelName: 'Brightid Main', // (required)\n      channelDescription: 'A channel to recieve BrightID notifications', // (optional) default: undefined.\n      soundName: 'default', // (optional) See `soundName` parameter of `localNotification` function\n      importance: 4, // (optional) default: 4. Int value of the Android notification importance\n      vibrate: true, // (optional) default: true. Creates the default vibration patten if true.\n    },\n    (created) => console.log(`createChannel returned '${created}'`), // (optional) callback returns whether the channel was created, false means it already existed.\n  );\n}\n"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEO,SAASA,wBAAT,GAAoC;EAEzCC,gBAAgB,CAACC,SAAjB,CAA2B;IAEzBC,UAFyB,4BAEH;MAAA,IAATC,KAAS,QAATA,KAAS;;MACpB,sBAA0BC,YAAA,CAAMC,QAAN,EAA1B;MAAA,IAAQC,aAAR,mBAAQA,aAAR;;MAEA,IAAIH,KAAJ,EAAW;QACTI,OAAO,CAACC,GAAR,CAAY,6BAAZ,EAA2CL,KAA3C;QAKA,IAAMM,cAAc,GAClBH,aAAa,CAACI,WAAd,IAA6BJ,aAAa,CAACI,WAAd,KAA8BP,KAA3D,GACIG,aAAa,CAACI,WADlB,GAEI,IAHN;;QAKAC,4BAAA,CACGC,QADH,CACY;UACRF,WAAW,EAAEP,KADL;UAERU,iBAAiB,EAAEP,aAAa,CAACO,iBAFzB;UAGRJ,cAAc,EAAdA;QAHQ,CADZ,EAMGK,IANH,CAMQ,iBAA2B;UAAA,IAAxBD,iBAAwB,SAAxBA,iBAAwB;UAC/B,IACEA,iBAAiB,IACjBA,iBAAiB,KAAKP,aAAa,CAACO,iBAFtC,EAIET,YAAA,CAAMW,QAAN,CAAe,IAAAC,6BAAA,EAAqBH,iBAArB,CAAf;QACH,CAZH,EAaGI,KAbH,CAaS,UAACC,GAAD,EAAS;UACdX,OAAO,CAACC,GAAR,CAAYU,GAAG,CAACC,OAAhB;QACD,CAfH;;QAgBAf,YAAA,CAAMW,QAAN,CAAe,IAAAK,uBAAA,EAAejB,KAAf,CAAf;MACD;IACF,CAlCwB;IAqCzBkB,cArCyB,0BAqCVC,YArCU,EAqCI;MAC3Bf,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6Bc,YAA7B;MAKAA,YAAY,CAACC,MAAb,CAAoBC,4BAAA,CAAoBC,WAApB,CAAgCC,MAApD;IACD,CA5CwB;IA+CzBC,QA/CyB,oBA+ChBL,YA/CgB,EA+CF;MACrBf,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBc,YAAY,CAACM,MAApC;MACArB,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6Bc,YAA7B;IAGD,CApDwB;IAuDzBO,mBAvDyB,+BAuDLX,GAvDK,EAuDA;MACvBX,OAAO,CAACC,GAAR,CAAYU,GAAG,CAACC,OAAhB,EAAyBD,GAAzB;IACD,CAzDwB;IA4DzBY,WAAW,EAAE;MACXC,KAAK,EAAE,IADI;MAEXC,KAAK,EAAE,IAFI;MAGXC,KAAK,EAAE;IAHI,CA5DY;IAoEzBC,sBAAsB,EAAE,IApEC;IA6EzBC,kBAAkB,EAAE;EA7EK,CAA3B;EAgFAnC,gBAAgB,CAACoC,aAAjB,CACE;IACEC,SAAS,EAAE,eADb;IAEEC,WAAW,EAAE,eAFf;IAGEC,kBAAkB,EAAE,6CAHtB;IAIEC,SAAS,EAAE,SAJb;IAKEC,UAAU,EAAE,CALd;IAMEC,OAAO,EAAE;EANX,CADF,EASE,UAACC,OAAD;IAAA,OAAapC,OAAO,CAACC,GAAR,8BAAuCmC,OAAvC,OAAb;EAAA,CATF;AAWD"},"metadata":{},"sourceType":"script"}