{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport nacl from 'tweetnacl';\nimport { addChannel, selectChannelById, removeChannel, setMyChannel, updateChannel, selectAllChannelIds, channel_types, selectAllChannels } from \"../channelSlice\";\nimport { selectAllSocialMediaToShare } from \"../../../reducer/socialMediaSlice\";\nimport { retrieveImage } from \"../../../utils/filesystem\";\nimport { encryptData } from \"../../../utils/cryptoHelper\";\nimport { generateChannelData, createChannelInfo } from \"../../../utils/channels\";\nimport { CHANNEL_CONNECTION_LIMIT, MIN_CHANNEL_JOIN_TTL, PROFILE_POLL_INTERVAL, PROFILE_VERSION, CHANNEL_INFO_NAME } from \"../../../utils/constants\";\nimport { newPendingConnection, selectAllPendingConnectionIds } from \"../pendingConnectionSlice\";\nimport { selectBaseUrl } from \"../../../reducer/settingsSlice\";\nimport { strToUint8Array, uInt8ArrayToB64 } from \"../../../utils/encoding\";\nexport var createChannel = function createChannel(channelType, api) {\n  return function _callee(dispatch, getState) {\n    var channel, baseUrl, url, channelInfo;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            baseUrl = selectBaseUrl(getState());\n            url = new URL(baseUrl + \"/profile\");\n            _context.next = 5;\n            return _regeneratorRuntime.awrap(generateChannelData(channelType, url));\n\n          case 5:\n            channel = _context.sent;\n            channel.timeoutId = setTimeout(function () {\n              console.log(\"timer expired for channel \" + channel.id);\n              dispatch(leaveChannel(channel.id));\n            }, channel.ttl);\n            dispatch(addChannel(channel));\n            dispatch(setMyChannel({\n              channelId: channel.id,\n              channelType: channel.type\n            }));\n            channelInfo = createChannelInfo(channel);\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(channel.api.upload({\n              channelId: channel.id,\n              data: channelInfo,\n              dataId: CHANNEL_INFO_NAME,\n              requestedTtl: channel.ttl\n            }));\n\n          case 12:\n            _context.next = 14;\n            return _regeneratorRuntime.awrap(dispatch(encryptAndUploadProfileToChannel(channel.id)));\n\n          case 14:\n            dispatch(subscribeToConnectionRequests(channel.id, api));\n            _context.next = 22;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](0);\n\n            if (channel && channel.id) {\n              dispatch(leaveChannel(channel.id));\n            }\n\n            console.log(\"Error while creating channel: \" + _context.t0);\n            throw _context.t0;\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 17]], Promise);\n  };\n};\nexport var joinChannel = function joinChannel(channel, api) {\n  return function _callee2(dispatch, getState) {\n    var channelIds, ttl_remain, entries, channelInfoIndex;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            console.log(\"Joining channel \" + channel.id + \" at \" + channel.url.href);\n            channelIds = selectAllChannelIds(getState());\n\n            if (!channelIds.includes(channel.id)) {\n              _context2.next = 5;\n              break;\n            }\n\n            console.log(\"Channel \" + channel.id + \" already joined\");\n            return _context2.abrupt(\"return\");\n\n          case 5:\n            ttl_remain = channel.timestamp + channel.ttl - Date.now();\n            _context2.prev = 6;\n\n            if (!(ttl_remain < MIN_CHANNEL_JOIN_TTL)) {\n              _context2.next = 10;\n              break;\n            }\n\n            console.log(\"Remaining ttl \" + ttl_remain + \" of channel \" + channel.id + \" too low. Aborting join.\");\n            throw new Error('Channel expired');\n\n          case 10:\n            _context2.next = 12;\n            return _regeneratorRuntime.awrap(channel.api.list(channel.id));\n\n          case 12:\n            entries = _context2.sent;\n            channelInfoIndex = entries.indexOf(CHANNEL_INFO_NAME);\n\n            if (channelInfoIndex > -1) {\n              entries.splice(channelInfoIndex, 1);\n            }\n\n            if (!(entries.length >= CHANNEL_CONNECTION_LIMIT)) {\n              _context2.next = 17;\n              break;\n            }\n\n            throw new Error(\"Channel is full\");\n\n          case 17:\n            channel.timeoutId = setTimeout(function () {\n              console.log(\"timer expired for channel \" + channel.id);\n              dispatch(leaveChannel(channel.id));\n            }, ttl_remain);\n            dispatch(addChannel(channel));\n            dispatch(subscribeToConnectionRequests(channel.id, api));\n            _context2.next = 26;\n            break;\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](6);\n            dispatch(leaveChannel(channel.id));\n            throw _context2.t0;\n\n          case 26:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[6, 22]], Promise);\n  };\n};\nexport var leaveChannel = function leaveChannel(channelId) {\n  return function (dispatch, getState) {\n    var channel = selectChannelById(getState(), channelId);\n\n    if (channel) {\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channelId));\n      dispatch(removeChannel(channelId));\n    }\n  };\n};\nexport var leaveAllChannels = function leaveAllChannels() {\n  return function (dispatch, getState) {\n    var channels = selectAllChannels(getState());\n\n    for (var _iterator = _createForOfIteratorHelperLoose(channels), _step; !(_step = _iterator()).done;) {\n      var channel = _step.value;\n      console.log(\"Leaving channel \" + channel.id);\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n      dispatch(removeChannel(channel.id));\n    }\n  };\n};\nexport var subscribeToConnectionRequests = function subscribeToConnectionRequests(channelId, api) {\n  return function (dispatch, getState) {\n    var _selectChannelById = selectChannelById(getState(), channelId),\n        pollTimerId = _selectChannelById.pollTimerId;\n\n    if (pollTimerId) {\n      console.log(\"Stopping previous timer \" + pollTimerId + \" for channel \" + channelId);\n      clearInterval(pollTimerId);\n    }\n\n    pollTimerId = setInterval(function () {\n      dispatch(fetchChannelProfiles(channelId, api));\n    }, PROFILE_POLL_INTERVAL);\n    console.log(\"Start polling channel \" + channelId + \", pollTImerId \" + pollTimerId);\n    dispatch(updateChannel({\n      id: channelId,\n      changes: {\n        pollTimerId: pollTimerId\n      }\n    }));\n  };\n};\nexport var unsubscribeFromConnectionRequests = function unsubscribeFromConnectionRequests(channelId) {\n  return function (dispatch, getState) {\n    var _selectChannelById2 = selectChannelById(getState(), channelId),\n        pollTimerId = _selectChannelById2.pollTimerId;\n\n    if (pollTimerId) {\n      console.log(\"Stop polling channel \" + channelId + \" (timer \" + pollTimerId + \")\");\n      clearInterval(pollTimerId);\n      dispatch(updateChannel({\n        id: channelId,\n        changes: {\n          pollTimerId: null\n        }\n      }));\n    }\n  };\n};\nexport var fetchChannelProfiles = function fetchChannelProfiles(channelId, api) {\n  return function _callee3(dispatch, getState) {\n    var channel, profileIds, channelInfoIndex, knownProfileIds, stopPolling, _iterator2, _step2, profileId, foundInitiator, _iterator3, _step3, _profileId, _iterator4, _step4, _profileId2;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            channel = selectChannelById(getState(), channelId);\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(channel.api.list(channelId));\n\n          case 3:\n            profileIds = _context3.sent;\n            channelInfoIndex = profileIds.indexOf(CHANNEL_INFO_NAME);\n\n            if (channelInfoIndex > -1) {\n              profileIds.splice(channelInfoIndex, 1);\n            }\n\n            profileIds = profileIds.slice(0, CHANNEL_CONNECTION_LIMIT);\n            knownProfileIds = selectAllPendingConnectionIds(getState());\n\n            if (__DEV__ && profileIds.length > knownProfileIds.length + 1) {\n              console.log(\"Got \" + profileIds.length + \" profileIds:\", profileIds);\n            }\n\n            stopPolling = false;\n            _context3.t0 = channel.type;\n            _context3.next = _context3.t0 === channel_types.STAR ? 13 : _context3.t0 === channel_types.GROUP ? 33 : _context3.t0 === channel_types.SINGLE ? 43 : 53;\n            break;\n\n          case 13:\n            if (!(channel.initiatorProfileId === channel.myProfileId)) {\n              _context3.next = 25;\n              break;\n            }\n\n            _iterator2 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 15:\n            if ((_step2 = _iterator2()).done) {\n              _context3.next = 22;\n              break;\n            }\n\n            profileId = _step2.value;\n\n            if (!(profileId !== channel.myProfileId && !knownProfileIds.includes(profileId))) {\n              _context3.next = 20;\n              break;\n            }\n\n            _context3.next = 20;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: profileId,\n              api: api\n            })));\n\n          case 20:\n            _context3.next = 15;\n            break;\n\n          case 22:\n            stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n            _context3.next = 32;\n            break;\n\n          case 25:\n            console.log(\"STAR channel - Participant waiting for initiator profile\");\n            foundInitiator = profileIds.includes(channel.initiatorProfileId);\n\n            if (!(foundInitiator && !knownProfileIds.includes(channel.initiatorProfileId))) {\n              _context3.next = 31;\n              break;\n            }\n\n            console.log(\"STAR channel - Participant found initiator profileID \" + channel.initiatorProfileId);\n            _context3.next = 31;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: channel.initiatorProfileId,\n              api: api\n            })));\n\n          case 31:\n            stopPolling = foundInitiator;\n\n          case 32:\n            return _context3.abrupt(\"break\", 53);\n\n          case 33:\n            _iterator3 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 34:\n            if ((_step3 = _iterator3()).done) {\n              _context3.next = 41;\n              break;\n            }\n\n            _profileId = _step3.value;\n\n            if (!(_profileId !== channel.myProfileId && !knownProfileIds.includes(_profileId))) {\n              _context3.next = 39;\n              break;\n            }\n\n            _context3.next = 39;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: _profileId,\n              api: api\n            })));\n\n          case 39:\n            _context3.next = 34;\n            break;\n\n          case 41:\n            stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n            return _context3.abrupt(\"break\", 53);\n\n          case 43:\n            _iterator4 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 44:\n            if ((_step4 = _iterator4()).done) {\n              _context3.next = 51;\n              break;\n            }\n\n            _profileId2 = _step4.value;\n\n            if (!(_profileId2 !== channel.myProfileId && !knownProfileIds.includes(_profileId2))) {\n              _context3.next = 49;\n              break;\n            }\n\n            _context3.next = 49;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: _profileId2,\n              api: api\n            })));\n\n          case 49:\n            _context3.next = 44;\n            break;\n\n          case 51:\n            stopPolling = profileIds.length >= 2;\n            return _context3.abrupt(\"break\", 53);\n\n          case 53:\n            if (stopPolling) {\n              console.log(\"Got expected profiles for channel \" + channel.id + \". Unsubscribing.\");\n              dispatch(unsubscribeFromConnectionRequests(channel.id));\n            }\n\n          case 54:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var encryptAndUploadProfileToChannel = function encryptAndUploadProfileToChannel(channelId) {\n  return function _callee4(dispatch, getState) {\n    var channel, _getState$user, id, filename, name, notificationToken, socialMedia, photo, profileTimestamp, dataObj, message, secretKey, encrypted;\n\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            channel = selectChannelById(getState(), channelId);\n            _getState$user = getState().user, id = _getState$user.id, filename = _getState$user.photo.filename, name = _getState$user.name;\n            notificationToken = getState().notifications.notificationToken;\n            socialMedia = selectAllSocialMediaToShare(getState());\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(retrieveImage(filename));\n\n          case 6:\n            photo = _context4.sent;\n            profileTimestamp = Date.now();\n            dataObj = {\n              id: id,\n              photo: photo,\n              name: name,\n              socialMedia: socialMedia,\n              profileTimestamp: profileTimestamp,\n              notificationToken: notificationToken,\n              version: PROFILE_VERSION\n            };\n\n            if (channel.initiatorProfileId === channel.myProfileId) {\n              message = id + \"|\" + profileTimestamp;\n              secretKey = getState().keypair.secretKey;\n              dataObj.requestProof = uInt8ArrayToB64(nacl.sign.detached(strToUint8Array(message), secretKey));\n            }\n\n            console.log(\"Encrypting profile data with key \" + channel.aesKey);\n            encrypted = encryptData(dataObj, channel.aesKey);\n            console.log(\"Posting profile data...\");\n            _context4.next = 15;\n            return _regeneratorRuntime.awrap(channel.api.upload({\n              channelId: channelId,\n              data: encrypted,\n              dataId: channel.myProfileId\n            }));\n\n          case 15:\n            dispatch(updateChannel({\n              id: channelId,\n              changes: {\n                myProfileTimestamp: profileTimestamp\n              }\n            }));\n\n          case 16:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/actions/channelThunks.ts"],"names":["createChannel","baseUrl","selectBaseUrl","getState","url","channel","generateChannelData","setTimeout","console","dispatch","leaveChannel","addChannel","setMyChannel","channelId","channelType","channelInfo","createChannelInfo","data","dataId","requestedTtl","encryptAndUploadProfileToChannel","subscribeToConnectionRequests","joinChannel","channelIds","selectAllChannelIds","ttl_remain","Date","entries","channelInfoIndex","selectChannelById","clearTimeout","unsubscribeFromConnectionRequests","removeChannel","leaveAllChannels","channels","selectAllChannels","pollTimerId","clearInterval","setInterval","fetchChannelProfiles","updateChannel","id","changes","profileIds","knownProfileIds","selectAllPendingConnectionIds","__DEV__","stopPolling","channel_types","profileId","newPendingConnection","api","foundInitiator","filename","name","notificationToken","socialMedia","selectAllSocialMediaToShare","photo","retrieveImage","profileTimestamp","dataObj","version","message","secretKey","uInt8ArrayToB64","nacl","strToUint8Array","encrypted","encryptData","myProfileTimestamp"],"mappings":"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","sourcesContent":["import nacl from 'tweetnacl';\nimport {\n  addChannel,\n  selectChannelById,\n  removeChannel,\n  setMyChannel,\n  updateChannel,\n  selectAllChannelIds,\n  channel_types,\n  selectAllChannels,\n} from '@/components/PendingConnections/channelSlice';\nimport { selectAllSocialMediaToShare } from '@/reducer/socialMediaSlice';\nimport { retrieveImage } from '@/utils/filesystem';\nimport { encryptData } from '@/utils/cryptoHelper';\nimport { generateChannelData, createChannelInfo } from '@/utils/channels';\nimport {\n  CHANNEL_CONNECTION_LIMIT,\n  MIN_CHANNEL_JOIN_TTL,\n  PROFILE_POLL_INTERVAL,\n  PROFILE_VERSION,\n  CHANNEL_INFO_NAME,\n} from '@/utils/constants';\nimport {\n  newPendingConnection,\n  selectAllPendingConnectionIds,\n} from '@/components/PendingConnections/pendingConnectionSlice';\nimport { selectBaseUrl } from '@/reducer/settingsSlice';\nimport { NodeApi } from '@/api/brightId';\nimport { strToUint8Array, uInt8ArrayToB64 } from '@/utils/encoding';\n\nexport const createChannel =\n  (channelType: ChannelType, api: NodeApi) =>\n  async (dispatch: dispatch, getState: getState) => {\n    let channel: Channel | null | undefined;\n    try {\n      const baseUrl = selectBaseUrl(getState());\n      const url = new URL(`${baseUrl}/profile`);\n      // use this for local running profile service\n      // const url = new URL(`http://10.0.2.2:3000/`);\n      channel = await generateChannelData(channelType, url);\n\n      // Set timeout to expire channel\n      channel.timeoutId = setTimeout(() => {\n        console.log(`timer expired for channel ${channel.id}`);\n        dispatch(leaveChannel(channel.id));\n      }, channel.ttl);\n      dispatch(addChannel(channel));\n      dispatch(\n        setMyChannel({ channelId: channel.id, channelType: channel.type }),\n      );\n\n      // upload channel info\n      const channelInfo: ChannelInfo = createChannelInfo(channel);\n      await channel.api.upload({\n        channelId: channel.id,\n        data: channelInfo,\n        dataId: CHANNEL_INFO_NAME,\n        requestedTtl: channel.ttl,\n      });\n\n      // upload my profile\n      await dispatch(encryptAndUploadProfileToChannel(channel.id));\n      // start polling for profiles\n      dispatch(subscribeToConnectionRequests(channel.id, api));\n    } catch (e) {\n      // Something went wrong while creating channel.\n      if (channel && channel.id) {\n        dispatch(leaveChannel(channel.id));\n      }\n      console.log(`Error while creating channel: ${e}`);\n      // need to throw to prevent app from looping\n      throw e;\n    }\n  };\n\nexport const joinChannel =\n  (channel: Channel, api: NodeApi) =>\n  async (dispatch: dispatch, getState: getState) => {\n    console.log(`Joining channel ${channel.id} at ${channel.url.href}`);\n    // check to see if channel exists\n    const channelIds = selectAllChannelIds(getState());\n    if (channelIds.includes(channel.id)) {\n      console.log(`Channel ${channel.id} already joined`);\n      return;\n    }\n\n    // calc remaining lifetime of channel\n    const ttl_remain = channel.timestamp + channel.ttl - Date.now();\n\n    try {\n      // don't join channel if it is/is about to expired\n      if (ttl_remain < MIN_CHANNEL_JOIN_TTL) {\n        console.log(\n          `Remaining ttl ${ttl_remain} of channel ${channel.id} too low. Aborting join.`,\n        );\n        throw new Error('Channel expired');\n      }\n\n      // don't join channel if it already has maximum allowed number of entries.\n      // Note that this is a client-side limitation in order to keep the UI usable.\n      const entries = await channel.api.list(channel.id);\n      // channel.api.list() will include the channelInfo.json file.\n      // Remove it from list as I don't want to download and interpret it as a profile.\n      const channelInfoIndex = entries.indexOf(CHANNEL_INFO_NAME);\n      if (channelInfoIndex > -1) {\n        entries.splice(channelInfoIndex, 1);\n      }\n      if (entries.length >= CHANNEL_CONNECTION_LIMIT) {\n        throw new Error(`Channel is full`);\n      }\n\n      // Start timer to expire channel\n      channel.timeoutId = setTimeout(() => {\n        console.log(`timer expired for channel ${channel.id}`);\n        dispatch(leaveChannel(channel.id));\n      }, ttl_remain);\n\n      // add channel to store\n      // we need channel to exist prior to uploadingProfileToChannel\n      dispatch(addChannel(channel));\n\n      // start polling for profiles\n      dispatch(subscribeToConnectionRequests(channel.id, api));\n    } catch (e) {\n      // Something went wrong while trying to join channel.\n      dispatch(leaveChannel(channel.id));\n      throw e;\n    }\n  };\n\nexport const leaveChannel =\n  (channelId: string) => (dispatch: dispatch, getState: getState) => {\n    const channel: Channel = selectChannelById(getState(), channelId);\n    if (channel) {\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channelId));\n      dispatch(removeChannel(channelId));\n    }\n  };\n\nexport const leaveAllChannels =\n  () => (dispatch: dispatch, getState: getState) => {\n    const channels = selectAllChannels(getState());\n    for (const channel of channels) {\n      console.log(`Leaving channel ${channel.id}`);\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n      dispatch(removeChannel(channel.id));\n    }\n  };\n\nexport const subscribeToConnectionRequests =\n  (channelId: string, api: NodeApi) =>\n  (dispatch: dispatch, getState: getState) => {\n    let { pollTimerId } = selectChannelById(getState(), channelId);\n\n    if (pollTimerId) {\n      console.log(\n        `Stopping previous timer ${\n          pollTimerId as any\n        } for channel ${channelId}`,\n      );\n      clearInterval(pollTimerId);\n    }\n\n    pollTimerId = setInterval(() => {\n      // fetch all profileIDs in channel\n      dispatch(fetchChannelProfiles(channelId, api));\n    }, PROFILE_POLL_INTERVAL);\n\n    console.log(\n      `Start polling channel ${channelId}, pollTImerId ${pollTimerId}`,\n    );\n\n    dispatch(\n      updateChannel({\n        id: channelId,\n        changes: {\n          pollTimerId,\n        },\n      }),\n    );\n  };\n\nexport const unsubscribeFromConnectionRequests =\n  (channelId: string) => (dispatch: dispatch, getState: getState) => {\n    const { pollTimerId } = selectChannelById(getState(), channelId);\n\n    if (pollTimerId) {\n      console.log(`Stop polling channel ${channelId} (timer ${pollTimerId})`);\n      clearInterval(pollTimerId);\n      dispatch(\n        updateChannel({\n          id: channelId,\n          changes: {\n            pollTimerId: null,\n          },\n        }),\n      );\n    }\n  };\n\nexport const fetchChannelProfiles =\n  (channelId: string, api: NodeApi) =>\n  async (dispatch: Dispatch, getState: GetState) => {\n    const channel = selectChannelById(getState(), channelId);\n    let profileIds = await channel.api.list(channelId);\n\n    // channel.api.list() will include the channelInfo.json file.\n    // Remove it from list as I don't want to download and interpret it as a profile.\n    const channelInfoIndex = profileIds.indexOf(CHANNEL_INFO_NAME);\n    if (channelInfoIndex > -1) {\n      profileIds.splice(channelInfoIndex, 1);\n    }\n\n    // Only get up to CHANNEL_CONNECTION_LIMIT profiles\n    profileIds = profileIds.slice(0, CHANNEL_CONNECTION_LIMIT);\n    const knownProfileIds = selectAllPendingConnectionIds(getState());\n    if (__DEV__ && profileIds.length > knownProfileIds.length + 1) {\n      console.log(`Got ${profileIds.length} profileIds:`, profileIds);\n    }\n\n    /*\n  Polling logic:\n  type STAR:\n   - Channel creator: Load all profiles\n   - Other participant: Only load creator profile\n  type GROUP:\n   - everybody load all profiles\n  type SINGLE:\n   - Channel creator: Load participant profile\n   - Other participant: Load creator profile\n */\n    let stopPolling = false;\n    switch (channel.type) {\n      case channel_types.STAR:\n        if (channel.initiatorProfileId === channel.myProfileId) {\n          // Channel creator: Load all profiles\n          for (const profileId of profileIds) {\n            if (\n              profileId !== channel.myProfileId &&\n              !knownProfileIds.includes(profileId)\n            ) {\n              await dispatch(\n                newPendingConnection({\n                  channelId,\n                  profileId,\n                  api,\n                }),\n              );\n            }\n          }\n          // stop polling when channel limit is reached\n          stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n        } else {\n          // other participant: Only load initiator profile\n          console.log(\n            `STAR channel - Participant waiting for initiator profile`,\n          );\n          const foundInitiator = profileIds.includes(\n            channel.initiatorProfileId,\n          );\n          if (\n            foundInitiator &&\n            !knownProfileIds.includes(channel.initiatorProfileId)\n          ) {\n            console.log(\n              `STAR channel - Participant found initiator profileID ${channel.initiatorProfileId}`,\n            );\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId: channel.initiatorProfileId,\n                api,\n              }),\n            );\n          }\n          // stop polling when initiator profile is found\n          stopPolling = foundInitiator;\n        }\n        break;\n      case channel_types.GROUP:\n        // Always load all profiles\n        for (const profileId of profileIds) {\n          if (\n            profileId !== channel.myProfileId &&\n            !knownProfileIds.includes(profileId)\n          ) {\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId,\n                api,\n              }),\n            );\n          }\n        }\n        // stop polling only when channel limit is reached\n        stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n        break;\n      case channel_types.SINGLE:\n        // there should be only 2 profiles in the channel. Just load all.\n        for (const profileId of profileIds) {\n          if (\n            profileId !== channel.myProfileId &&\n            !knownProfileIds.includes(profileId)\n          ) {\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId,\n                api,\n              }),\n            );\n          }\n        }\n        // stop polling when 2 profiles are found (own profile and peer profile)\n        stopPolling = profileIds.length >= 2;\n        break;\n    }\n\n    if (stopPolling) {\n      console.log(\n        `Got expected profiles for channel ${channel.id}. Unsubscribing.`,\n      );\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n    }\n  };\n\nexport const encryptAndUploadProfileToChannel =\n  (channelId: string) => async (dispatch: Dispatch, getState: GetState) => {\n    // get channel\n    const channel = selectChannelById(getState(), channelId);\n    // get user data\n    const {\n      id,\n      photo: { filename },\n      name,\n    } = getState().user;\n\n    const { notificationToken } = getState().notifications;\n\n    const socialMedia = selectAllSocialMediaToShare(getState());\n\n    // retrieve photo\n    const photo = await retrieveImage(filename);\n    const profileTimestamp = Date.now();\n\n    const dataObj: SharedProfile = {\n      id,\n      photo,\n      name,\n      socialMedia,\n      profileTimestamp,\n      notificationToken,\n      version: PROFILE_VERSION,\n    };\n\n    if (channel.initiatorProfileId === channel.myProfileId) {\n      // create request proof that proves the user requested\n      // the connection by creating the qr code\n      const message = `${id}|${profileTimestamp}`;\n      const { secretKey } = getState().keypair;\n      dataObj.requestProof = uInt8ArrayToB64(\n        nacl.sign.detached(strToUint8Array(message), secretKey),\n      );\n    }\n\n    console.log(`Encrypting profile data with key ${channel.aesKey}`);\n    const encrypted = encryptData(dataObj, channel.aesKey);\n    console.log(`Posting profile data...`);\n    await channel.api.upload({\n      channelId,\n      data: encrypted,\n      dataId: channel.myProfileId,\n    });\n    dispatch(\n      updateChannel({\n        id: channelId,\n        changes: {\n          myProfileTimestamp: profileTimestamp,\n        },\n      }),\n    );\n  };\n"]},"metadata":{},"sourceType":"module"}