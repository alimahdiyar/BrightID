{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n    case 'raw':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n\n      default:\n        if (retried) return;\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n}\n\n;\n\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\nexports.StringDecoder = StringDecoder;\n\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\nStringDecoder.prototype.text = utf8Text;\n\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n\n    return nb;\n  }\n\n  return 0;\n}\n\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return \"\\uFFFD\";\n  }\n\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return \"\\uFFFD\";\n    }\n\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return \"\\uFFFD\";\n      }\n    }\n  }\n}\n\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + \"\\uFFFD\";\n  return r;\n}\n\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n\n    return r;\n  }\n\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","map":{"version":3,"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/string_decoder/lib/string_decoder.js"],"names":["Buffer","require","isEncoding","encoding","enc","retried","nenc","_normalizeEncoding","exports","normalizeEncoding","nb","StringDecoder","buf","r","i","byte","j","utf8CheckByte","self","p","utf8CheckExtraBytes","total","utf8CheckIncomplete","end","c","n"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}"]},"metadata":{},"sourceType":"script"}