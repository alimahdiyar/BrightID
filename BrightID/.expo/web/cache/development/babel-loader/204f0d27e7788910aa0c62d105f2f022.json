{"ast":null,"code":";\n\n(function (root) {\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n  var freeModule = typeof module == 'object' && module && !module.nodeType && module;\n  var freeGlobal = typeof global == 'object' && global;\n\n  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n    root = freeGlobal;\n  }\n\n  var punycode,\n      maxInt = 2147483647,\n      base = 36,\n      tMin = 1,\n      tMax = 26,\n      skew = 38,\n      damp = 700,\n      initialBias = 72,\n      initialN = 128,\n      delimiter = '-',\n      regexPunycode = /^xn--/,\n      regexNonASCII = /[^\\x20-\\x7E]/,\n      regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n      errors = {\n    'overflow': 'Overflow: input needs wider integers to process',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'invalid-input': 'Invalid input'\n  },\n      baseMinusTMin = base - tMin,\n      floor = Math.floor,\n      stringFromCharCode = String.fromCharCode,\n      key;\n\n  function error(type) {\n    throw new RangeError(errors[type]);\n  }\n\n  function map(array, fn) {\n    var length = array.length;\n    var result = [];\n\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n\n    return result;\n  }\n\n  function mapDomain(string, fn) {\n    var parts = string.split('@');\n    var result = '';\n\n    if (parts.length > 1) {\n      result = parts[0] + '@';\n      string = parts[1];\n    }\n\n    string = string.replace(regexSeparators, '\\x2E');\n    var labels = string.split('.');\n    var encoded = map(labels, fn).join('.');\n    return result + encoded;\n  }\n\n  function ucs2decode(string) {\n    var output = [],\n        counter = 0,\n        length = string.length,\n        value,\n        extra;\n\n    while (counter < length) {\n      value = string.charCodeAt(counter++);\n\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        extra = string.charCodeAt(counter++);\n\n        if ((extra & 0xFC00) == 0xDC00) {\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n\n    return output;\n  }\n\n  function ucs2encode(array) {\n    return map(array, function (value) {\n      var output = '';\n\n      if (value > 0xFFFF) {\n        value -= 0x10000;\n        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n        value = 0xDC00 | value & 0x3FF;\n      }\n\n      output += stringFromCharCode(value);\n      return output;\n    }).join('');\n  }\n\n  function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n      return codePoint - 22;\n    }\n\n    if (codePoint - 65 < 26) {\n      return codePoint - 65;\n    }\n\n    if (codePoint - 97 < 26) {\n      return codePoint - 97;\n    }\n\n    return base;\n  }\n\n  function digitToBasic(digit, flag) {\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  }\n\n  function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n\n    for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  }\n\n  function decode(input) {\n    var output = [],\n        inputLength = input.length,\n        out,\n        i = 0,\n        n = initialN,\n        bias = initialBias,\n        basic,\n        j,\n        index,\n        oldi,\n        w,\n        k,\n        digit,\n        t,\n        baseMinusT;\n    basic = input.lastIndexOf(delimiter);\n\n    if (basic < 0) {\n      basic = 0;\n    }\n\n    for (j = 0; j < basic; ++j) {\n      if (input.charCodeAt(j) >= 0x80) {\n        error('not-basic');\n      }\n\n      output.push(input.charCodeAt(j));\n    }\n\n    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n      for (oldi = i, w = 1, k = base;; k += base) {\n        if (index >= inputLength) {\n          error('invalid-input');\n        }\n\n        digit = basicToDigit(input.charCodeAt(index++));\n\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error('overflow');\n        }\n\n        i += digit * w;\n        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n        if (digit < t) {\n          break;\n        }\n\n        baseMinusT = base - t;\n\n        if (w > floor(maxInt / baseMinusT)) {\n          error('overflow');\n        }\n\n        w *= baseMinusT;\n      }\n\n      out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0);\n\n      if (floor(i / out) > maxInt - n) {\n        error('overflow');\n      }\n\n      n += floor(i / out);\n      i %= out;\n      output.splice(i++, 0, n);\n    }\n\n    return ucs2encode(output);\n  }\n\n  function encode(input) {\n    var n,\n        delta,\n        handledCPCount,\n        basicLength,\n        bias,\n        j,\n        m,\n        q,\n        k,\n        t,\n        currentValue,\n        output = [],\n        inputLength,\n        handledCPCountPlusOne,\n        baseMinusT,\n        qMinusT;\n    input = ucs2decode(input);\n    inputLength = input.length;\n    n = initialN;\n    delta = 0;\n    bias = initialBias;\n\n    for (j = 0; j < inputLength; ++j) {\n      currentValue = input[j];\n\n      if (currentValue < 0x80) {\n        output.push(stringFromCharCode(currentValue));\n      }\n    }\n\n    handledCPCount = basicLength = output.length;\n\n    if (basicLength) {\n      output.push(delimiter);\n    }\n\n    while (handledCPCount < inputLength) {\n      for (m = maxInt, j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n\n        if (currentValue >= n && currentValue < m) {\n          m = currentValue;\n        }\n      }\n\n      handledCPCountPlusOne = handledCPCount + 1;\n\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error('overflow');\n      }\n\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n\n        if (currentValue < n && ++delta > maxInt) {\n          error('overflow');\n        }\n\n        if (currentValue == n) {\n          for (q = delta, k = base;; k += base) {\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n            if (q < t) {\n              break;\n            }\n\n            qMinusT = q - t;\n            baseMinusT = base - t;\n            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n            q = floor(qMinusT / baseMinusT);\n          }\n\n          output.push(stringFromCharCode(digitToBasic(q, 0)));\n          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n          delta = 0;\n          ++handledCPCount;\n        }\n      }\n\n      ++delta;\n      ++n;\n    }\n\n    return output.join('');\n  }\n\n  function toUnicode(input) {\n    return mapDomain(input, function (string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n  }\n\n  function toASCII(input) {\n    return mapDomain(input, function (string) {\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n  }\n\n  punycode = {\n    'version': '1.4.1',\n    'ucs2': {\n      'decode': ucs2decode,\n      'encode': ucs2encode\n    },\n    'decode': decode,\n    'encode': encode,\n    'toASCII': toASCII,\n    'toUnicode': toUnicode\n  };\n\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    define('punycode', function () {\n      return punycode;\n    });\n  } else if (freeExports && freeModule) {\n    if (module.exports == freeExports) {\n      freeModule.exports = punycode;\n    } else {\n      for (key in punycode) {\n        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n      }\n    }\n  } else {\n    root.punycode = punycode;\n  }\n})(this);","map":{"version":3,"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/punycode/punycode.js"],"names":["freeExports","exports","freeModule","module","freeGlobal","root","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","length","array","result","fn","parts","string","labels","encoded","map","output","counter","value","extra","codePoint","digit","flag","k","delta","firstTime","inputLength","input","i","n","bias","basic","j","error","index","oldi","w","basicToDigit","t","baseMinusT","out","adapt","ucs2encode","ucs2decode","currentValue","handledCPCount","basicLength","m","handledCPCountPlusOne","q","qMinusT","digitToBasic","mapDomain","decode","encode","punycode","define"],"mappings":"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","sourcesContent":["/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n"]},"metadata":{},"sourceType":"script"}