{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.socialRecovery = exports.setupRecovery = exports.setRecoveryKeys = exports.restoreUserData = exports.recoverData = exports.finishRecovery = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _tweetnacl = _interopRequireDefault(require(\"tweetnacl\"));\n\nvar _filesystem = require(\"../../../../utils/filesystem\");\n\nvar _encoding = require(\"../../../../utils/encoding\");\n\nvar _actions = require(\"../../../../actions\");\n\nvar _brightidError = _interopRequireWildcard(require(\"../../../../api/brightidError\"));\n\nvar _fetchUserInfo = _interopRequireDefault(require(\"../../../../actions/fetchUserInfo\"));\n\nvar _backupThunks = require(\"./backupThunks\");\n\nvar _recoveryDataSlice = require(\"../recoveryDataSlice\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar THREE_DAYS = 259200000;\n\nvar pastLimit = function pastLimit(timestamp) {\n  return timestamp + THREE_DAYS < Date.now();\n};\n\nvar setupRecovery = function setupRecovery() {\n  return function _callee(dispatch, getState) {\n    var _getState, recoveryData, _await$nacl$sign$keyP, publicKey, secretKey, aesKey;\n\n    return _regenerator.default.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.log(\"Setting up recovery...\");\n            _getState = getState(), recoveryData = _getState.recoveryData;\n            _context.next = 4;\n            return _regenerator.default.awrap((0, _filesystem.createImageDirectory)());\n\n          case 4:\n            if (!(!recoveryData.timestamp || pastLimit(recoveryData.timestamp))) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.next = 7;\n            return _regenerator.default.awrap(_tweetnacl.default.sign.keyPair());\n\n          case 7:\n            _await$nacl$sign$keyP = _context.sent;\n            publicKey = _await$nacl$sign$keyP.publicKey;\n            secretKey = _await$nacl$sign$keyP.secretKey;\n            _context.next = 12;\n            return _regenerator.default.awrap((0, _encoding.urlSafeRandomKey)(16));\n\n          case 12:\n            aesKey = _context.sent;\n            dispatch((0, _recoveryDataSlice.init)({\n              publicKey: publicKey,\n              secretKey: secretKey,\n              aesKey: aesKey\n            }));\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nexports.setupRecovery = setupRecovery;\n\nvar socialRecovery = function socialRecovery(api) {\n  return function _callee2(dispatch, getState) {\n    var _getState2, recoveryData, sigs, op, errorString;\n\n    return _regenerator.default.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _getState2 = getState(), recoveryData = _getState2.recoveryData;\n            sigs = Object.values(recoveryData.sigs);\n            console.log('setting signing key');\n            _context2.prev = 3;\n            _context2.next = 6;\n            return _regenerator.default.awrap(api.socialRecovery({\n              id: recoveryData.id,\n              signingKey: recoveryData.publicKey,\n              timestamp: recoveryData.timestamp,\n              id1: sigs[0].signer,\n              id2: sigs[1].signer,\n              sig1: sigs[0].sig,\n              sig2: sigs[1].sig\n            }));\n\n          case 6:\n            op = _context2.sent;\n            dispatch((0, _actions.addOperation)(op));\n            return _context2.abrupt(\"return\", op);\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](3);\n            errorString = '';\n\n            if (!(_context2.t0 instanceof _brightidError.default)) {\n              _context2.next = 21;\n              break;\n            }\n\n            if (!(_context2.t0.errorNum === _brightidError.OPERATION_APPLIED_BEFORE)) {\n              _context2.next = 18;\n              break;\n            }\n\n            console.log(\"Social Recovery operation already applied. Ignoring this error.\");\n            return _context2.abrupt(\"return\", 'ALREADY APPLIED');\n\n          case 18:\n            errorString = _context2.t0.errorNum + \" - \" + _context2.t0.message;\n            _context2.next = 22;\n            break;\n\n          case 21:\n            if (_context2.t0 instanceof Error) {\n              errorString = _context2.t0.name + \" - \" + _context2.t0.message;\n            } else {\n              errorString = \"\" + _context2.t0;\n            }\n\n          case 22:\n            console.log(\"Error in socialRecovery: \" + errorString);\n            dispatch((0, _recoveryDataSlice.resetRecoverySigs)());\n            throw new Error(errorString);\n\n          case 25:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[3, 11]], Promise);\n  };\n};\n\nexports.socialRecovery = socialRecovery;\n\nvar restoreUserData = function _callee3(id, pass) {\n  var decrypted, _JSON$parse, userData, connections, _JSON$parse$groups, groups, userPhoto, filename;\n\n  return _regenerator.default.async(function _callee3$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regenerator.default.awrap((0, _backupThunks.fetchBackupData)('data', id, pass));\n\n        case 2:\n          decrypted = _context3.sent;\n          _JSON$parse = JSON.parse(decrypted), userData = _JSON$parse.userData, connections = _JSON$parse.connections, _JSON$parse$groups = _JSON$parse.groups, groups = _JSON$parse$groups === void 0 ? [] : _JSON$parse$groups;\n\n          if (!(!userData || !connections)) {\n            _context3.next = 6;\n            break;\n          }\n\n          throw new Error('bad password');\n\n        case 6:\n          _context3.prev = 6;\n          _context3.next = 9;\n          return _regenerator.default.awrap((0, _backupThunks.fetchBackupData)(id, id, pass));\n\n        case 9:\n          userPhoto = _context3.sent;\n          _context3.next = 15;\n          break;\n\n        case 12:\n          _context3.prev = 12;\n          _context3.t0 = _context3[\"catch\"](6);\n          console.log(\"Failed to recover user photo\");\n\n        case 15:\n          if (!userPhoto) {\n            _context3.next = 20;\n            break;\n          }\n\n          _context3.next = 18;\n          return _regenerator.default.awrap((0, _filesystem.saveImage)({\n            imageName: id,\n            base64Image: userPhoto\n          }));\n\n        case 18:\n          filename = _context3.sent;\n          userData.photo = {\n            filename: filename\n          };\n\n        case 20:\n          return _context3.abrupt(\"return\", {\n            userData: userData,\n            connections: connections,\n            groups: groups\n          });\n\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[6, 12]], Promise);\n};\n\nexports.restoreUserData = restoreUserData;\n\nvar setRecoveryKeys = function setRecoveryKeys() {\n  return function (dispatch, getState) {\n    var _getState$recoveryDat = getState().recoveryData,\n        publicKey = _getState$recoveryDat.publicKey,\n        secretKey = _getState$recoveryDat.secretKey;\n    dispatch((0, _actions.setKeypair)({\n      publicKey: publicKey,\n      secretKey: secretKey\n    }));\n  };\n};\n\nexports.setRecoveryKeys = setRecoveryKeys;\n\nvar recoverData = function recoverData(pass, api, setTotalItems, setCurrentItem) {\n  return function _callee4(dispatch, getState) {\n    var id, restoredData, userData, connections, groups, apps, blindSigApps, currentItem, _iterator, _step, conn, decrypted, filename, errorString, _iterator2, _step2, _group$photo, group, _decrypted, _errorString, _iterator3, _step3, app, _iterator4, _step4, verification, vel, roundedTimestamp, key, _decrypted2;\n\n    return _regenerator.default.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            id = getState().recoveryData.id;\n            console.log(\"Starting recoverData for \" + id);\n            _context4.next = 4;\n            return _regenerator.default.awrap(restoreUserData(id, pass));\n\n          case 4:\n            restoredData = _context4.sent;\n            console.log(\"Got recovery data for \" + id);\n            userData = restoredData.userData;\n            connections = restoredData.connections;\n            groups = restoredData.groups;\n            _context4.next = 11;\n            return _regenerator.default.awrap(api.getApps());\n\n          case 11:\n            apps = _context4.sent;\n            blindSigApps = apps.filter(function (app) {\n              return app.usingBlindSig;\n            });\n            setTotalItems(connections.length + groups.length + blindSigApps.length);\n            dispatch((0, _actions.setConnections)(connections));\n            dispatch((0, _actions.setGroups)(groups));\n            dispatch((0, _recoveryDataSlice.updateNamePhoto)({\n              name: userData.name,\n              photo: userData.photo\n            }));\n            currentItem = 1;\n            _iterator = _createForOfIteratorHelperLoose(connections);\n\n          case 19:\n            if ((_step = _iterator()).done) {\n              _context4.next = 40;\n              break;\n            }\n\n            conn = _step.value;\n            _context4.prev = 21;\n            setCurrentItem(currentItem++);\n            _context4.next = 25;\n            return _regenerator.default.awrap((0, _backupThunks.fetchBackupData)(conn.id, id, pass));\n\n          case 25:\n            decrypted = _context4.sent;\n            _context4.next = 28;\n            return _regenerator.default.awrap((0, _filesystem.saveImage)({\n              imageName: conn.id,\n              base64Image: decrypted\n            }));\n\n          case 28:\n            filename = _context4.sent;\n            conn.photo = {\n              filename: filename\n            };\n            _context4.next = 38;\n            break;\n\n          case 32:\n            _context4.prev = 32;\n            _context4.t0 = _context4[\"catch\"](21);\n            errorString = '';\n\n            if (_context4.t0 instanceof Error) {\n              errorString = _context4.t0.name + \" - \" + _context4.t0.message;\n            } else {\n              errorString = \"\" + _context4.t0;\n            }\n\n            console.log('Connection image not found', errorString);\n            conn.photo = {\n              filename: ''\n            };\n\n          case 38:\n            _context4.next = 19;\n            break;\n\n          case 40:\n            _iterator2 = _createForOfIteratorHelperLoose(groups);\n\n          case 41:\n            if ((_step2 = _iterator2()).done) {\n              _context4.next = 60;\n              break;\n            }\n\n            group = _step2.value;\n            setCurrentItem(currentItem++);\n\n            if (!((_group$photo = group.photo) != null && _group$photo.filename)) {\n              _context4.next = 58;\n              break;\n            }\n\n            _context4.prev = 45;\n            _context4.next = 48;\n            return _regenerator.default.awrap((0, _backupThunks.fetchBackupData)(group.id, id, pass));\n\n          case 48:\n            _decrypted = _context4.sent;\n            _context4.next = 51;\n            return _regenerator.default.awrap((0, _filesystem.saveImage)({\n              imageName: group.id,\n              base64Image: _decrypted\n            }));\n\n          case 51:\n            _context4.next = 58;\n            break;\n\n          case 53:\n            _context4.prev = 53;\n            _context4.t1 = _context4[\"catch\"](45);\n            _errorString = '';\n\n            if (_context4.t1 instanceof Error) {\n              _errorString = _context4.t1.name + \" - \" + _context4.t1.message;\n            } else {\n              _errorString = \"\" + _context4.t1;\n            }\n\n            console.log('Group image not found', _errorString);\n\n          case 58:\n            _context4.next = 41;\n            break;\n\n          case 60:\n            _iterator3 = _createForOfIteratorHelperLoose(blindSigApps);\n\n          case 61:\n            if ((_step3 = _iterator3()).done) {\n              _context4.next = 85;\n              break;\n            }\n\n            app = _step3.value;\n            setCurrentItem(currentItem++);\n            _iterator4 = _createForOfIteratorHelperLoose(app.verifications);\n\n          case 65:\n            if ((_step4 = _iterator4()).done) {\n              _context4.next = 83;\n              break;\n            }\n\n            verification = _step4.value;\n            vel = app.verificationExpirationLength;\n            roundedTimestamp = vel ? Math.floor(Date.now() / vel) * vel : 0;\n            key = (0, _encoding.hash)(app.id + \" \" + verification + \" \" + roundedTimestamp);\n            _context4.prev = 70;\n            _context4.next = 73;\n            return _regenerator.default.awrap((0, _backupThunks.fetchBackupData)(key, id, pass));\n\n          case 73:\n            _decrypted2 = _context4.sent;\n            _context4.next = 76;\n            return _regenerator.default.awrap(dispatch((0, _actions.upsertSig)(JSON.parse(_decrypted2))));\n\n          case 76:\n            _context4.next = 81;\n            break;\n\n          case 78:\n            _context4.prev = 78;\n            _context4.t2 = _context4[\"catch\"](70);\n            console.log(\"blind sig not found for \" + key, _context4.t2.message);\n\n          case 81:\n            _context4.next = 65;\n            break;\n\n          case 83:\n            _context4.next = 61;\n            break;\n\n          case 85:\n            dispatch((0, _fetchUserInfo.default)(api));\n\n          case 86:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, [[21, 32], [45, 53], [70, 78]], Promise);\n  };\n};\n\nexports.recoverData = recoverData;\n\nvar finishRecovery = function finishRecovery() {\n  return function _callee5(dispatch, getState) {\n    var _getState$recoveryDat2, id, name, photo;\n\n    return _regenerator.default.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _getState$recoveryDat2 = getState().recoveryData, id = _getState$recoveryDat2.id, name = _getState$recoveryDat2.name, photo = _getState$recoveryDat2.photo;\n            dispatch((0, _recoveryDataSlice.resetRecoveryData)());\n            dispatch((0, _actions.setUserData)({\n              id: id,\n              name: name,\n              photo: photo\n            }));\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nexports.finishRecovery = finishRecovery;","map":{"version":3,"names":["THREE_DAYS","pastLimit","timestamp","Date","now","setupRecovery","dispatch","getState","console","log","recoveryData","createImageDirectory","nacl","sign","keyPair","publicKey","secretKey","urlSafeRandomKey","aesKey","init","socialRecovery","api","sigs","Object","values","id","signingKey","id1","signer","id2","sig1","sig","sig2","op","addOperation","errorString","BrightidError","errorNum","OPERATION_APPLIED_BEFORE","message","Error","name","resetRecoverySigs","restoreUserData","pass","fetchBackupData","decrypted","JSON","parse","userData","connections","groups","userPhoto","saveImage","imageName","base64Image","filename","photo","setRecoveryKeys","setKeypair","recoverData","setTotalItems","setCurrentItem","restoredData","getApps","apps","blindSigApps","filter","app","usingBlindSig","length","setConnections","setGroups","updateNamePhoto","currentItem","conn","group","verifications","verification","vel","verificationExpirationLength","roundedTimestamp","Math","floor","key","hash","upsertSig","fetchUserInfo","finishRecovery","resetRecoveryData","setUserData"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/recoveryThunks.ts"],"sourcesContent":["import nacl from 'tweetnacl';\nimport { createImageDirectory, saveImage } from '@/utils/filesystem';\nimport { hash, urlSafeRandomKey } from '@/utils/encoding';\nimport {\n  setUserData,\n  setConnections,\n  setGroups,\n  setKeypair,\n  addOperation,\n  upsertSig,\n} from '@/actions';\nimport BrightidError, { OPERATION_APPLIED_BEFORE } from '@/api/brightidError';\nimport { NodeApi } from '@/api/brightId';\nimport fetchUserInfo from '@/actions/fetchUserInfo';\nimport { fetchBackupData } from './backupThunks';\nimport {\n  init,\n  resetRecoveryData,\n  resetRecoverySigs,\n  updateNamePhoto,\n} from '../recoveryDataSlice';\n\n// HELPERS\n\nconst THREE_DAYS = 259200000;\n\nconst pastLimit = (timestamp) => timestamp + THREE_DAYS < Date.now();\n\n// THUNKS\n\nexport const setupRecovery =\n  () => async (dispatch: dispatch, getState: getState) => {\n    console.log(`Setting up recovery...`);\n    const { recoveryData } = getState();\n    await createImageDirectory();\n    // setup recovery data\n    if (!recoveryData.timestamp || pastLimit(recoveryData.timestamp)) {\n      const { publicKey, secretKey } = await nacl.sign.keyPair();\n      const aesKey = await urlSafeRandomKey(16);\n      // setup recovery data slice with new keypair\n      dispatch(init({ publicKey, secretKey, aesKey }));\n    }\n  };\n\nexport const socialRecovery =\n  (api: NodeApi) => async (dispatch: dispatch, getState: getState) => {\n    const { recoveryData } = getState();\n    const sigs = Object.values(recoveryData.sigs);\n    console.log('setting signing key');\n    try {\n      const op = await api.socialRecovery({\n        id: recoveryData.id,\n        signingKey: recoveryData.publicKey,\n        timestamp: recoveryData.timestamp,\n        id1: sigs[0].signer,\n        id2: sigs[1].signer,\n        sig1: sigs[0].sig,\n        sig2: sigs[1].sig,\n      });\n      dispatch(addOperation(op));\n      return op;\n    } catch (err) {\n      let errorString = '';\n      if (err instanceof BrightidError) {\n        if (err.errorNum === OPERATION_APPLIED_BEFORE) {\n          console.log(\n            `Social Recovery operation already applied. Ignoring this error.`,\n          );\n          return 'ALREADY APPLIED';\n        }\n        errorString = `${err.errorNum} - ${err.message}`;\n      } else if (err instanceof Error) {\n        errorString = `${err.name} - ${err.message}`;\n      } else {\n        errorString = `${err}`;\n      }\n      console.log(`Error in socialRecovery: ${errorString}`);\n      dispatch(resetRecoverySigs());\n      throw new Error(errorString);\n    }\n  };\n\nexport const restoreUserData = async (id: string, pass: string) => {\n  const decrypted = await fetchBackupData('data', id, pass);\n  const { userData, connections, groups = [] } = JSON.parse(decrypted);\n  if (!userData || !connections) {\n    // TODO Better error handling\n    throw new Error('bad password');\n  }\n\n  let userPhoto;\n  try {\n    userPhoto = await fetchBackupData(id, id, pass);\n  } catch (e) {\n    console.log(`Failed to recover user photo`);\n    // ignore this error and try to continue recovery process\n  }\n\n  if (userPhoto) {\n    const filename = await saveImage({\n      imageName: id,\n      base64Image: userPhoto,\n    });\n    userData.photo = { filename };\n  }\n\n  return { userData, connections, groups };\n};\n\nexport const setRecoveryKeys =\n  () => (dispatch: dispatch, getState: getState) => {\n    const { publicKey, secretKey } = getState().recoveryData;\n    dispatch(setKeypair({ publicKey, secretKey }));\n  };\n\nexport const recoverData =\n  (\n    pass: string,\n    api: NodeApi,\n    setTotalItems: (totalItems: number) => void,\n    setCurrentItem: (currentItem: number) => void,\n  ) =>\n  async (dispatch: dispatch, getState: getState) => {\n    const { id } = getState().recoveryData;\n    console.log(`Starting recoverData for ${id}`);\n    // throws if data is bad\n    const restoredData = await restoreUserData(id, pass);\n    console.log(`Got recovery data for ${id}`);\n    const { userData } = restoredData;\n    const { connections } = restoredData;\n    const { groups } = restoredData;\n    const apps = await api.getApps();\n    const blindSigApps = apps.filter((app) => app.usingBlindSig);\n    setTotalItems(connections.length + groups.length + blindSigApps.length);\n    dispatch(setConnections(connections));\n    dispatch(setGroups(groups));\n    dispatch(updateNamePhoto({ name: userData.name, photo: userData.photo }));\n\n    let currentItem = 1;\n\n    // fetch connection images\n    for (const conn of connections) {\n      try {\n        setCurrentItem(currentItem++);\n        const decrypted = await fetchBackupData(conn.id, id, pass);\n        const filename = await saveImage({\n          imageName: conn.id,\n          base64Image: decrypted,\n        });\n        conn.photo = { filename };\n      } catch (err) {\n        let errorString = '';\n        if (err instanceof Error) {\n          errorString = `${err.name} - ${err.message}`;\n        } else {\n          errorString = `${err}`;\n        }\n        console.log('Connection image not found', errorString);\n        conn.photo = { filename: '' };\n      }\n    }\n\n    // fetch group images\n    for (const group of groups) {\n      setCurrentItem(currentItem++);\n      if (group.photo?.filename) {\n        try {\n          const decrypted = await fetchBackupData(group.id, id, pass);\n          await saveImage({\n            imageName: group.id,\n            base64Image: decrypted,\n          });\n        } catch (err) {\n          let errorString = '';\n          if (err instanceof Error) {\n            errorString = `${err.name} - ${err.message}`;\n          } else {\n            errorString = `${err}`;\n          }\n          console.log('Group image not found', errorString);\n        }\n      }\n    }\n\n    // fetch blind sigs\n    for (const app of blindSigApps) {\n      setCurrentItem(currentItem++);\n      for (const verification of app.verifications) {\n        const vel = app.verificationExpirationLength;\n        const roundedTimestamp = vel ? Math.floor(Date.now() / vel) * vel : 0;\n        const key = hash(`${app.id} ${verification} ${roundedTimestamp}`);\n        try {\n          const decrypted = await fetchBackupData(key, id, pass);\n          await dispatch(upsertSig(JSON.parse(decrypted)));\n        } catch (err) {\n          console.log(`blind sig not found for ${key}`, err.message);\n        }\n      }\n    }\n\n    dispatch(fetchUserInfo(api));\n  };\n\nexport const finishRecovery =\n  () => async (dispatch: dispatch, getState: getState) => {\n    // collect user data that was populated either by uploads from recovery connections or by restoring backup\n    const { id, name, photo } = getState().recoveryData;\n    // clear recovery data from state\n    dispatch(resetRecoveryData());\n    // finally set the user data\n    dispatch(setUserData({ id, name, photo }));\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}