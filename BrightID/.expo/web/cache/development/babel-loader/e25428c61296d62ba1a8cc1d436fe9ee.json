{"ast":null,"code":"import { getModality } from \"../modality\";\nimport useEvent from \"../useEvent\";\nimport useLayoutEffect from \"../useLayoutEffect\";\nvar emptyObject = {};\nvar opts = {\n  passive: true\n};\nvar lockEventType = 'react-gui:hover:lock';\nvar unlockEventType = 'react-gui:hover:unlock';\n\nvar supportsPointerEvent = function supportsPointerEvent() {\n  return !!(typeof window !== 'undefined' && window.PointerEvent != null);\n};\n\nfunction dispatchCustomEvent(target, type, payload) {\n  var event = document.createEvent('CustomEvent');\n\n  var _ref = payload || emptyObject,\n      _ref$bubbles = _ref.bubbles,\n      bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,\n      _ref$cancelable = _ref.cancelable,\n      cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable,\n      detail = _ref.detail;\n\n  event.initCustomEvent(type, bubbles, cancelable, detail);\n  target.dispatchEvent(event);\n}\n\nfunction getPointerType(event) {\n  var pointerType = event.pointerType;\n  return pointerType != null ? pointerType : getModality();\n}\n\nexport default function useHover(targetRef, config) {\n  var contain = config.contain,\n      disabled = config.disabled,\n      onHoverStart = config.onHoverStart,\n      onHoverChange = config.onHoverChange,\n      onHoverUpdate = config.onHoverUpdate,\n      onHoverEnd = config.onHoverEnd;\n  var canUsePE = supportsPointerEvent();\n  var addMoveListener = useEvent(canUsePE ? 'pointermove' : 'mousemove', opts);\n  var addEnterListener = useEvent(canUsePE ? 'pointerenter' : 'mouseenter', opts);\n  var addLeaveListener = useEvent(canUsePE ? 'pointerleave' : 'mouseleave', opts);\n  var addLockListener = useEvent(lockEventType, opts);\n  var addUnlockListener = useEvent(unlockEventType, opts);\n  useLayoutEffect(function () {\n    var target = targetRef.current;\n\n    if (target !== null) {\n      var hoverEnd = function hoverEnd(e) {\n        if (onHoverEnd != null) {\n          onHoverEnd(e);\n        }\n\n        if (onHoverChange != null) {\n          onHoverChange(false);\n        }\n\n        addMoveListener(target, null);\n        addLeaveListener(target, null);\n      };\n\n      var leaveListener = function leaveListener(e) {\n        var target = targetRef.current;\n\n        if (target != null && getPointerType(e) !== 'touch') {\n          if (contain) {\n            dispatchCustomEvent(target, unlockEventType);\n          }\n\n          hoverEnd(e);\n        }\n      };\n\n      var moveListener = function moveListener(e) {\n        if (getPointerType(e) !== 'touch') {\n          if (onHoverUpdate != null) {\n            if (e.x == null) {\n              e.x = e.clientX;\n            }\n\n            if (e.y == null) {\n              e.y = e.clientY;\n            }\n\n            onHoverUpdate(e);\n          }\n        }\n      };\n\n      var hoverStart = function hoverStart(e) {\n        if (onHoverStart != null) {\n          onHoverStart(e);\n        }\n\n        if (onHoverChange != null) {\n          onHoverChange(true);\n        }\n\n        if (onHoverUpdate != null) {\n          addMoveListener(target, !disabled ? moveListener : null);\n        }\n\n        addLeaveListener(target, !disabled ? leaveListener : null);\n      };\n\n      var enterListener = function enterListener(e) {\n        var target = targetRef.current;\n\n        if (target != null && getPointerType(e) !== 'touch') {\n          if (contain) {\n            dispatchCustomEvent(target, lockEventType);\n          }\n\n          hoverStart(e);\n\n          var lockListener = function lockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverEnd(e);\n            }\n          };\n\n          var unlockListener = function unlockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverStart(e);\n            }\n          };\n\n          addLockListener(target, !disabled ? lockListener : null);\n          addUnlockListener(target, !disabled ? unlockListener : null);\n        }\n      };\n\n      addEnterListener(target, !disabled ? enterListener : null);\n    }\n  }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);\n}","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/node_modules/react-native-web/dist/modules/useHover/index.js"],"names":["emptyObject","opts","passive","lockEventType","unlockEventType","supportsPointerEvent","window","event","document","_ref","payload","_ref$bubbles","bubbles","_ref$cancelable","cancelable","detail","target","pointerType","getModality","contain","config","disabled","onHoverStart","onHoverChange","onHoverUpdate","onHoverEnd","canUsePE","addMoveListener","useEvent","addEnterListener","addLeaveListener","addLockListener","addUnlockListener","useLayoutEffect","targetRef","hoverEnd","leaveListener","getPointerType","dispatchCustomEvent","moveListener","e","hoverStart","enterListener","lockListener","lockEvent","unlockListener"],"mappings":"AAQA,SAAA,WAAA;AACA,OAAA,QAAA;AACA,OAAA,eAAA;AAQA,IAAIA,WAAW,GAAf,EAAA;AACA,IAAIC,IAAI,GAAG;EACTC,OAAO,EADT;AAAW,CAAX;AAGA,IAAIC,aAAa,GAAjB,sBAAA;AACA,IAAIC,eAAe,GAAnB,wBAAA;;AAEA,IAAIC,oBAAoB,GAAG,SAAA,oBAAA,GAAgC;EACzD,OAAO,CAAC,EAAE,OAAA,MAAA,KAAA,WAAA,IAAiCC,MAAM,CAANA,YAAAA,IAA3C,IAAQ,CAAR;AADF,CAAA;;AAIA,SAAA,mBAAA,CAAA,MAAA,EAAA,IAAA,EAAA,OAAA,EAAoD;EAClD,IAAIC,KAAK,GAAGC,QAAQ,CAARA,WAAAA,CAAZ,aAAYA,CAAZ;;EAEA,IAAIC,IAAI,GAAGC,OAAO,IAAlB,WAAA;EAAA,IACIC,YAAY,GAAGF,IAAI,CADvB,OAAA;EAAA,IAEIG,OAAO,GAAGD,YAAY,KAAK,KAAjBA,CAAAA,GAAAA,IAAAA,GAFd,YAAA;EAAA,IAGIE,eAAe,GAAGJ,IAAI,CAH1B,UAAA;EAAA,IAIIK,UAAU,GAAGD,eAAe,KAAK,KAApBA,CAAAA,GAAAA,IAAAA,GAJjB,eAAA;EAAA,IAKIE,MAAM,GAAGN,IAAI,CALjB,MAAA;;EAOAF,KAAK,CAALA,eAAAA,CAAAA,IAAAA,EAAAA,OAAAA,EAAAA,UAAAA,EAAAA,MAAAA;EACAS,MAAM,CAANA,aAAAA,CAAAA,KAAAA;AAIF;;AAAA,SAAA,cAAA,CAAA,KAAA,EAA+B;EAC7B,IAAIC,WAAW,GAAGV,KAAK,CAAvB,WAAA;EACA,OAAOU,WAAW,IAAXA,IAAAA,GAAAA,WAAAA,GAAoCC,WAA3C,EAAA;AAGF;;AAAA,eAAe,SAAA,QAAA,CAAA,SAAA,EAAA,MAAA,EAAqC;EAClD,IAAIC,OAAO,GAAGC,MAAM,CAApB,OAAA;EAAA,IACIC,QAAQ,GAAGD,MAAM,CADrB,QAAA;EAAA,IAEIE,YAAY,GAAGF,MAAM,CAFzB,YAAA;EAAA,IAGIG,aAAa,GAAGH,MAAM,CAH1B,aAAA;EAAA,IAIII,aAAa,GAAGJ,MAAM,CAJ1B,aAAA;EAAA,IAKIK,UAAU,GAAGL,MAAM,CALvB,UAAA;EAMA,IAAIM,QAAQ,GAAGrB,oBAAf,EAAA;EACA,IAAIsB,eAAe,GAAGC,QAAQ,CAACF,QAAQ,GAAA,aAAA,GAAT,WAAA,EAA9B,IAA8B,CAA9B;EACA,IAAIG,gBAAgB,GAAGD,QAAQ,CAACF,QAAQ,GAAA,cAAA,GAAT,YAAA,EAA/B,IAA+B,CAA/B;EACA,IAAII,gBAAgB,GAAGF,QAAQ,CAACF,QAAQ,GAAA,cAAA,GAAT,YAAA,EAA/B,IAA+B,CAA/B;EAEA,IAAIK,eAAe,GAAGH,QAAQ,CAAA,aAAA,EAA9B,IAA8B,CAA9B;EACA,IAAII,iBAAiB,GAAGJ,QAAQ,CAAA,eAAA,EAAhC,IAAgC,CAAhC;EACAK,eAAe,CAAC,YAAY;IAC1B,IAAIjB,MAAM,GAAGkB,SAAS,CAAtB,OAAA;;IAEA,IAAIlB,MAAM,KAAV,IAAA,EAAqB;MAInB,IAAImB,QAAQ,GAAG,SAAA,QAAA,CAAA,CAAA,EAAqB;QAClC,IAAIV,UAAU,IAAd,IAAA,EAAwB;UACtBA,UAAU,CAAVA,CAAU,CAAVA;QAGF;;QAAA,IAAIF,aAAa,IAAjB,IAAA,EAA2B;UACzBA,aAAa,CAAbA,KAAa,CAAbA;QAIFI;;QAAAA,eAAe,CAAA,MAAA,EAAfA,IAAe,CAAfA;QACAG,gBAAgB,CAAA,MAAA,EAAhBA,IAAgB,CAAhBA;MAXF,CAAA;;MAkBA,IAAIM,aAAa,GAAG,SAAA,aAAA,CAAA,CAAA,EAA0B;QAC5C,IAAIpB,MAAM,GAAGkB,SAAS,CAAtB,OAAA;;QAEA,IAAIlB,MAAM,IAANA,IAAAA,IAAkBqB,cAAc,CAAdA,CAAc,CAAdA,KAAtB,OAAA,EAAqD;UACnD,IAAA,OAAA,EAAa;YACXC,mBAAmB,CAAA,MAAA,EAAnBA,eAAmB,CAAnBA;UAGFH;;UAAAA,QAAQ,CAARA,CAAQ,CAARA;QAEH;MAVD,CAAA;;MAgBA,IAAII,YAAY,GAAG,SAAA,YAAA,CAAA,CAAA,EAAyB;QAC1C,IAAIF,cAAc,CAAdA,CAAc,CAAdA,KAAJ,OAAA,EAAmC;UACjC,IAAIb,aAAa,IAAjB,IAAA,EAA2B;YAEzB,IAAIgB,CAAC,CAADA,CAAAA,IAAJ,IAAA,EAAiB;cACfA,CAAC,CAADA,CAAAA,GAAMA,CAAC,CAAPA,OAAAA;YAGF;;YAAA,IAAIA,CAAC,CAADA,CAAAA,IAAJ,IAAA,EAAiB;cACfA,CAAC,CAADA,CAAAA,GAAMA,CAAC,CAAPA,OAAAA;YAGFhB;;YAAAA,aAAa,CAAbA,CAAa,CAAbA;UAEH;QACF;MAfD,CAAA;;MAqBA,IAAIiB,UAAU,GAAG,SAAA,UAAA,CAAA,CAAA,EAAuB;QACtC,IAAInB,YAAY,IAAhB,IAAA,EAA0B;UACxBA,YAAY,CAAZA,CAAY,CAAZA;QAGF;;QAAA,IAAIC,aAAa,IAAjB,IAAA,EAA2B;UACzBA,aAAa,CAAbA,IAAa,CAAbA;QAIF;;QAAA,IAAIC,aAAa,IAAjB,IAAA,EAA2B;UACzBG,eAAe,CAAA,MAAA,EAAS,CAAA,QAAA,GAAA,YAAA,GAAxBA,IAAe,CAAfA;QAGFG;;QAAAA,gBAAgB,CAAA,MAAA,EAAS,CAAA,QAAA,GAAA,aAAA,GAAzBA,IAAgB,CAAhBA;MAdF,CAAA;;MAqBA,IAAIY,aAAa,GAAG,SAAA,aAAA,CAAA,CAAA,EAA0B;QAC5C,IAAI1B,MAAM,GAAGkB,SAAS,CAAtB,OAAA;;QAEA,IAAIlB,MAAM,IAANA,IAAAA,IAAkBqB,cAAc,CAAdA,CAAc,CAAdA,KAAtB,OAAA,EAAqD;UACnD,IAAA,OAAA,EAAa;YACXC,mBAAmB,CAAA,MAAA,EAAnBA,aAAmB,CAAnBA;UAGFG;;UAAAA,UAAU,CAAVA,CAAU,CAAVA;;UAEA,IAAIE,YAAY,GAAG,SAAA,YAAA,CAAA,SAAA,EAAiC;YAClD,IAAIC,SAAS,CAATA,MAAAA,KAAJ,MAAA,EAAiC;cAC/BT,QAAQ,CAARA,CAAQ,CAARA;YAEH;UAJD,CAAA;;UAMA,IAAIU,cAAc,GAAG,SAAA,cAAA,CAAA,SAAA,EAAmC;YACtD,IAAID,SAAS,CAATA,MAAAA,KAAJ,MAAA,EAAiC;cAC/BH,UAAU,CAAVA,CAAU,CAAVA;YAEH;UAJD,CAAA;;UAMAV,eAAe,CAAA,MAAA,EAAS,CAAA,QAAA,GAAA,YAAA,GAAxBA,IAAe,CAAfA;UACAC,iBAAiB,CAAA,MAAA,EAAS,CAAA,QAAA,GAAA,cAAA,GAA1BA,IAAiB,CAAjBA;QAEH;MAzBD,CAAA;;MA2BAH,gBAAgB,CAAA,MAAA,EAAS,CAAA,QAAA,GAAA,aAAA,GAAzBA,IAAgB,CAAhBA;IAEH;EAhHc,CAAA,EAgHZ,CAAA,gBAAA,EAAA,eAAA,EAAA,gBAAA,EAAA,eAAA,EAAA,iBAAA,EAAA,OAAA,EAAA,QAAA,EAAA,YAAA,EAAA,aAAA,EAAA,aAAA,EAAA,UAAA,EAhHHI,SAgHG,CAhHY,CAAfA;AAiHD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getModality } from '../modality';\nimport useEvent from '../useEvent';\nimport useLayoutEffect from '../useLayoutEffect';\n/**\n * Types\n */\n\n/**\n * Implementation\n */\nvar emptyObject = {};\nvar opts = {\n  passive: true\n};\nvar lockEventType = 'react-gui:hover:lock';\nvar unlockEventType = 'react-gui:hover:unlock';\n\nvar supportsPointerEvent = function supportsPointerEvent() {\n  return !!(typeof window !== 'undefined' && window.PointerEvent != null);\n};\n\nfunction dispatchCustomEvent(target, type, payload) {\n  var event = document.createEvent('CustomEvent');\n\n  var _ref = payload || emptyObject,\n      _ref$bubbles = _ref.bubbles,\n      bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,\n      _ref$cancelable = _ref.cancelable,\n      cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable,\n      detail = _ref.detail;\n\n  event.initCustomEvent(type, bubbles, cancelable, detail);\n  target.dispatchEvent(event);\n} // This accounts for the non-PointerEvent fallback events.\n\n\nfunction getPointerType(event) {\n  var pointerType = event.pointerType;\n  return pointerType != null ? pointerType : getModality();\n}\n\nexport default function useHover(targetRef, config) {\n  var contain = config.contain,\n      disabled = config.disabled,\n      onHoverStart = config.onHoverStart,\n      onHoverChange = config.onHoverChange,\n      onHoverUpdate = config.onHoverUpdate,\n      onHoverEnd = config.onHoverEnd;\n  var canUsePE = supportsPointerEvent();\n  var addMoveListener = useEvent(canUsePE ? 'pointermove' : 'mousemove', opts);\n  var addEnterListener = useEvent(canUsePE ? 'pointerenter' : 'mouseenter', opts);\n  var addLeaveListener = useEvent(canUsePE ? 'pointerleave' : 'mouseleave', opts); // These custom events are used to implement the \"contain\" prop.\n\n  var addLockListener = useEvent(lockEventType, opts);\n  var addUnlockListener = useEvent(unlockEventType, opts);\n  useLayoutEffect(function () {\n    var target = targetRef.current;\n\n    if (target !== null) {\n      /**\n       * End the hover gesture\n       */\n      var hoverEnd = function hoverEnd(e) {\n        if (onHoverEnd != null) {\n          onHoverEnd(e);\n        }\n\n        if (onHoverChange != null) {\n          onHoverChange(false);\n        } // Remove the listeners once finished.\n\n\n        addMoveListener(target, null);\n        addLeaveListener(target, null);\n      };\n      /**\n       * Leave element\n       */\n\n\n      var leaveListener = function leaveListener(e) {\n        var target = targetRef.current;\n\n        if (target != null && getPointerType(e) !== 'touch') {\n          if (contain) {\n            dispatchCustomEvent(target, unlockEventType);\n          }\n\n          hoverEnd(e);\n        }\n      };\n      /**\n       * Move within element\n       */\n\n\n      var moveListener = function moveListener(e) {\n        if (getPointerType(e) !== 'touch') {\n          if (onHoverUpdate != null) {\n            // Not all browsers have these properties\n            if (e.x == null) {\n              e.x = e.clientX;\n            }\n\n            if (e.y == null) {\n              e.y = e.clientY;\n            }\n\n            onHoverUpdate(e);\n          }\n        }\n      };\n      /**\n       * Start the hover gesture\n       */\n\n\n      var hoverStart = function hoverStart(e) {\n        if (onHoverStart != null) {\n          onHoverStart(e);\n        }\n\n        if (onHoverChange != null) {\n          onHoverChange(true);\n        } // Set the listeners needed for the rest of the hover gesture.\n\n\n        if (onHoverUpdate != null) {\n          addMoveListener(target, !disabled ? moveListener : null);\n        }\n\n        addLeaveListener(target, !disabled ? leaveListener : null);\n      };\n      /**\n       * Enter element\n       */\n\n\n      var enterListener = function enterListener(e) {\n        var target = targetRef.current;\n\n        if (target != null && getPointerType(e) !== 'touch') {\n          if (contain) {\n            dispatchCustomEvent(target, lockEventType);\n          }\n\n          hoverStart(e);\n\n          var lockListener = function lockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverEnd(e);\n            }\n          };\n\n          var unlockListener = function unlockListener(lockEvent) {\n            if (lockEvent.target !== target) {\n              hoverStart(e);\n            }\n          };\n\n          addLockListener(target, !disabled ? lockListener : null);\n          addUnlockListener(target, !disabled ? unlockListener : null);\n        }\n      };\n\n      addEnterListener(target, !disabled ? enterListener : null);\n    }\n  }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);\n}"]},"metadata":{},"sourceType":"module"}