{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Animated from 'react-native-reanimated';\nvar event = Animated.event,\n    divide = Animated.divide,\n    onChange = Animated.onChange,\n    cond = Animated.cond,\n    eq = Animated.eq,\n    round = Animated.round,\n    call = Animated.call,\n    Value = Animated.Value;\n\nvar ScrollPager = function (_React$Component) {\n  _inherits(ScrollPager, _React$Component);\n\n  var _super = _createSuper(ScrollPager);\n\n  function ScrollPager() {\n    var _this;\n\n    _classCallCheck(this, ScrollPager);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"initialOffset\", {\n      x: _this.props.navigationState.index * _this.props.layout.width,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"wasTouched\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"interactionHandle\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"scrollViewRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"jumpTo\", function (key) {\n      _this.wasTouched = false;\n      var _this$props = _this.props,\n          navigationState = _this$props.navigationState,\n          keyboardDismissMode = _this$props.keyboardDismissMode,\n          onIndexChange = _this$props.onIndexChange;\n      var index = navigationState.routes.findIndex(function (route) {\n        return route.key === key;\n      });\n\n      if (navigationState.index === index) {\n        _this.scrollTo(index * _this.props.layout.width);\n      } else {\n        onIndexChange(index);\n\n        if (keyboardDismissMode === 'auto') {\n          Keyboard.dismiss();\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"scrollTo\", function (x) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (_this.scrollViewRef.current) {\n        var _this$scrollViewRef$c, _this$scrollViewRef$c2;\n\n        var scrollView = typeof ((_this$scrollViewRef$c = _this.scrollViewRef.current) === null || _this$scrollViewRef$c === void 0 ? void 0 : _this$scrollViewRef$c.scrollTo) === 'function' ? _this.scrollViewRef.current : (_this$scrollViewRef$c2 = _this.scrollViewRef.current) === null || _this$scrollViewRef$c2 === void 0 ? void 0 : _this$scrollViewRef$c2.getNode();\n        scrollView === null || scrollView === void 0 ? void 0 : scrollView.scrollTo({\n          x: x,\n          animated: animated\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"enterListeners\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"addListener\", function (type, listener) {\n      switch (type) {\n        case 'enter':\n          _this.enterListeners.push(listener);\n\n          break;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"removeListener\", function (type, listener) {\n      switch (type) {\n        case 'enter':\n          {\n            var index = _this.enterListeners.indexOf(listener);\n\n            if (index > -1) {\n              _this.enterListeners.splice(index, 1);\n            }\n\n            break;\n          }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"position\", new Animated.Value(_this.props.navigationState.index * _this.props.layout.width));\n\n    _defineProperty(_assertThisInitialized(_this), \"onScroll\", event([{\n      nativeEvent: {\n        contentOffset: {\n          x: _this.position\n        }\n      }\n    }]));\n\n    _defineProperty(_assertThisInitialized(_this), \"layoutWidthNode\", new Value(_this.props.layout.width));\n\n    _defineProperty(_assertThisInitialized(_this), \"relativePosition\", divide(_this.position, _this.layoutWidthNode));\n\n    return _this;\n  }\n\n  _createClass(ScrollPager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.layout.width) {\n        this.scrollTo(this.props.navigationState.index * this.props.layout.width, false);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var offset = this.props.navigationState.index * this.props.layout.width;\n\n      if (prevProps.navigationState.routes.length !== this.props.navigationState.routes.length || prevProps.layout.width !== this.props.layout.width) {\n        this.scrollTo(offset, false);\n      } else if (prevProps.navigationState.index !== this.props.navigationState.index) {\n        this.scrollTo(offset);\n      }\n\n      if (prevProps.layout.width !== this.props.layout.width) {\n        this.layoutWidthNode.setValue(this.props.layout.width);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.interactionHandle !== null) {\n        InteractionManager.clearInteractionHandle(this.interactionHandle);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          children = _this$props2.children,\n          layout = _this$props2.layout,\n          onSwipeStart = _this$props2.onSwipeStart,\n          onSwipeEnd = _this$props2.onSwipeEnd,\n          overscroll = _this$props2.overscroll,\n          onIndexChange = _this$props2.onIndexChange,\n          navigationState = _this$props2.navigationState;\n\n      var handleSwipeStart = function handleSwipeStart() {\n        _this2.wasTouched = false;\n        onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();\n        _this2.interactionHandle = InteractionManager.createInteractionHandle();\n      };\n\n      var handleSwipeEnd = function handleSwipeEnd() {\n        _this2.wasTouched = true;\n        onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();\n\n        if (_this2.interactionHandle !== null) {\n          InteractionManager.clearInteractionHandle(_this2.interactionHandle);\n        }\n      };\n\n      return children({\n        position: this.relativePosition,\n        addListener: this.addListener,\n        removeListener: this.removeListener,\n        jumpTo: this.jumpTo,\n        render: function render(children) {\n          return React.createElement(Animated.ScrollView, {\n            pagingEnabled: true,\n            directionalLockEnabled: true,\n            keyboardDismissMode: \"on-drag\",\n            keyboardShouldPersistTaps: \"always\",\n            overScrollMode: \"never\",\n            scrollToOverflowEnabled: true,\n            scrollEnabled: _this2.props.swipeEnabled,\n            automaticallyAdjustContentInsets: false,\n            bounces: overscroll,\n            scrollsToTop: false,\n            showsHorizontalScrollIndicator: false,\n            scrollEventThrottle: 1,\n            onScroll: _this2.onScroll,\n            onScrollBeginDrag: handleSwipeStart,\n            onScrollEndDrag: handleSwipeEnd,\n            onMomentumScrollEnd: _this2.onScroll,\n            contentOffset: _this2.initialOffset,\n            style: styles.container,\n            contentContainerStyle: layout.width ? {\n              flexDirection: 'row',\n              width: layout.width * navigationState.routes.length,\n              flex: 1\n            } : null,\n            ref: _this2.scrollViewRef\n          }, children, React.createElement(Animated.Code, {\n            exec: onChange(_this2.relativePosition, cond(eq(round(_this2.relativePosition), _this2.relativePosition), [call([_this2.relativePosition], function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 1),\n                  relativePosition = _ref2[0];\n\n              if (_this2.wasTouched) {\n                onIndexChange(relativePosition);\n                _this2.wasTouched = false;\n              }\n            })]))\n          }));\n        }\n      });\n    }\n  }]);\n\n  return ScrollPager;\n}(React.Component);\n\nexport { ScrollPager as default };\n\n_defineProperty(ScrollPager, \"defaultProps\", {\n  bounces: true\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  }\n});","map":{"version":3,"sources":["ScrollPager.tsx"],"names":["event","divide","onChange","cond","eq","round","call","Value","Animated","ScrollPager","React","Component","bounces","componentDidMount","componentDidUpdate","offset","prevProps","componentWillUnmount","InteractionManager","x","y","key","navigationState","keyboardDismissMode","onIndexChange","index","route","Keyboard","animated","scrollView","nativeEvent","contentOffset","render","children","layout","onSwipeStart","onSwipeEnd","overscroll","handleSwipeStart","handleSwipeEnd","position","addListener","removeListener","jumpTo","pagingEnabled","directionalLockEnabled","keyboardShouldPersistTaps","overScrollMode","scrollToOverflowEnabled","scrollEnabled","automaticallyAdjustContentInsets","scrollsToTop","showsHorizontalScrollIndicator","scrollEventThrottle","onScroll","onScrollBeginDrag","onScrollEndDrag","onMomentumScrollEnd","style","styles","contentContainerStyle","flexDirection","width","flex","ref","exec","relativePosition","StyleSheet","container"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, Keyboard, InteractionManager } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport { Props } from './Pager';\nimport { Route, Listener } from './types';\n\nconst { event, divide, onChange, cond, eq, round, call, Value } = Animated;\n\ntype State = {\n  initialOffset: { x: number; y: number };\n};\n\nexport default class ScrollPager<T extends Route> extends React.Component<\n  Props<T> & { overscroll?: boolean },\n  State\n> {\n  static defaultProps = {\n    bounces: true,\n  };\n\n  componentDidMount() {\n    if (this.props.layout.width) {\n      this.scrollTo(\n        this.props.navigationState.index * this.props.layout.width,\n        false\n      );\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const offset = this.props.navigationState.index * this.props.layout.width;\n\n    if (\n      prevProps.navigationState.routes.length !==\n        this.props.navigationState.routes.length ||\n      prevProps.layout.width !== this.props.layout.width\n    ) {\n      this.scrollTo(offset, false);\n    } else if (\n      prevProps.navigationState.index !== this.props.navigationState.index\n    ) {\n      this.scrollTo(offset);\n    }\n\n    if (prevProps.layout.width !== this.props.layout.width) {\n      this.layoutWidthNode.setValue(this.props.layout.width);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  private initialOffset = {\n    x: this.props.navigationState.index * this.props.layout.width,\n    y: 0,\n  };\n\n  private wasTouched: boolean = false;\n\n  // InteractionHandle to handle tasks around animations\n  private interactionHandle: number | null = null;\n\n  private scrollViewRef = React.createRef<Animated.ScrollView>();\n\n  private jumpTo = (key: string) => {\n    this.wasTouched = false;\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\n\n    const index = navigationState.routes.findIndex(\n      (route) => route.key === key\n    );\n\n    if (navigationState.index === index) {\n      this.scrollTo(index * this.props.layout.width);\n    } else {\n      onIndexChange(index);\n      if (keyboardDismissMode === 'auto') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private scrollTo = (x: number, animated = true) => {\n    if (this.scrollViewRef.current) {\n      // getNode() is not necessary in newer versions of React Native\n      const scrollView =\n        // @ts-ignore\n        typeof this.scrollViewRef.current?.scrollTo === 'function'\n          ? this.scrollViewRef.current\n          : this.scrollViewRef.current?.getNode();\n\n      // @ts-ignore\n      scrollView?.scrollTo({\n        x,\n        animated: animated,\n      });\n    }\n  };\n\n  private enterListeners: Listener[] = [];\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private position = new Animated.Value(\n    this.props.navigationState.index * this.props.layout.width\n  );\n\n  private onScroll = event([\n    {\n      nativeEvent: {\n        contentOffset: {\n          x: this.position,\n        },\n      },\n    },\n  ]);\n\n  private layoutWidthNode = new Value(this.props.layout.width);\n\n  private relativePosition = divide(this.position, this.layoutWidthNode);\n\n  render() {\n    const {\n      children,\n      layout,\n      onSwipeStart,\n      onSwipeEnd,\n      overscroll,\n      onIndexChange,\n      navigationState,\n    } = this.props;\n\n    const handleSwipeStart = () => {\n      this.wasTouched = false;\n      onSwipeStart?.();\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    };\n\n    const handleSwipeEnd = () => {\n      this.wasTouched = true;\n      onSwipeEnd?.();\n      if (this.interactionHandle !== null) {\n        InteractionManager.clearInteractionHandle(this.interactionHandle);\n      }\n    };\n\n    return children({\n      position: this.relativePosition,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: (children) => (\n        <Animated.ScrollView\n          pagingEnabled\n          directionalLockEnabled\n          keyboardDismissMode=\"on-drag\"\n          keyboardShouldPersistTaps=\"always\"\n          overScrollMode=\"never\"\n          scrollToOverflowEnabled\n          scrollEnabled={this.props.swipeEnabled}\n          automaticallyAdjustContentInsets={false}\n          bounces={overscroll}\n          scrollsToTop={false}\n          showsHorizontalScrollIndicator={false}\n          scrollEventThrottle={1}\n          onScroll={this.onScroll}\n          onScrollBeginDrag={handleSwipeStart}\n          onScrollEndDrag={handleSwipeEnd}\n          onMomentumScrollEnd={this.onScroll}\n          contentOffset={this.initialOffset}\n          style={styles.container}\n          contentContainerStyle={\n            layout.width\n              ? {\n                  flexDirection: 'row',\n                  width: layout.width * navigationState.routes.length,\n                  flex: 1,\n                }\n              : null\n          }\n          ref={this.scrollViewRef}\n        >\n          {children}\n          <Animated.Code\n            exec={onChange(\n              this.relativePosition,\n              cond(eq(round(this.relativePosition), this.relativePosition), [\n                call([this.relativePosition], ([relativePosition]) => {\n                  if (this.wasTouched) {\n                    onIndexChange(relativePosition);\n                    this.wasTouched = false;\n                  }\n                }),\n              ])\n            )}\n          />\n        </Animated.ScrollView>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}