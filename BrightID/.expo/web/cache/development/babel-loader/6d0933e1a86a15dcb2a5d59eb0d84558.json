{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uploadSig = exports.uploadMutualInfo = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _tweetnacl = _interopRequireDefault(require(\"tweetnacl\"));\n\nvar _fastJsonStableStringify = _interopRequireDefault(require(\"fast-json-stable-stringify\"));\n\nvar _encoding = require(\"../../../../utils/encoding\");\n\nvar _connectionsSlice = require(\"../../../../reducer/connectionsSlice\");\n\nvar _store = require(\"../../../../store\");\n\nvar _recovery = require(\"../../../../utils/recovery\");\n\nvar _channels = require(\"../../../../utils/channels\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar uploadSig = function uploadSig(_ref) {\n  var id = _ref.id,\n      aesKey = _ref.aesKey,\n      channelApi = _ref.channelApi;\n  return function _callee(_, getState) {\n    var _getState, secretKey, signer, _await$loadRecoveryDa, signingKey, timestamp, op, message, sig, data;\n\n    return _regenerator.default.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _getState = getState(), secretKey = _getState.keypair.secretKey, signer = _getState.user.id;\n            _context.next = 3;\n            return _regenerator.default.awrap((0, _recovery.loadRecoveryData)(channelApi, aesKey));\n\n          case 3:\n            _await$loadRecoveryDa = _context.sent;\n            signingKey = _await$loadRecoveryDa.signingKey;\n            timestamp = _await$loadRecoveryDa.timestamp;\n            op = {\n              name: 'Social Recovery',\n              id: id,\n              signingKey: signingKey,\n              timestamp: timestamp,\n              v: 6\n            };\n            message = (0, _fastJsonStableStringify.default)(op);\n            sig = (0, _encoding.uInt8ArrayToB64)(_tweetnacl.default.sign.detached((0, _encoding.strToUint8Array)(message), secretKey));\n            data = {\n              signer: signer,\n              id: id,\n              sig: sig\n            };\n            _context.next = 12;\n            return _regenerator.default.awrap(channelApi.upload({\n              channelId: (0, _encoding.hash)(aesKey),\n              dataId: \"sig_\" + signer,\n              data: data\n            }));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nexports.uploadSig = uploadSig;\n\nvar uploadMutualInfo = function _callee2(_ref2) {\n  var conn, aesKey, channelApi, nodeApi, _store$getState, signingKey, groups, user, dataIds, connections, connectionsById, groupsById, otherSideConnections, knownLevels, mutualConnections, otherSideGroups, mutualGroups, _iterator, _step, c, _iterator2, _step2, g;\n\n  return _regenerator.default.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          conn = _ref2.conn, aesKey = _ref2.aesKey, channelApi = _ref2.channelApi, nodeApi = _ref2.nodeApi;\n          _store$getState = _store.store.getState(), signingKey = _store$getState.keypair.publicKey, groups = _store$getState.groups.groups, user = _store$getState.user;\n          _context2.next = 4;\n          return _regenerator.default.awrap(channelApi.list((0, _encoding.hash)(aesKey)));\n\n        case 4:\n          dataIds = _context2.sent;\n\n          if (dataIds.includes(\"connection_\" + conn.id + \":\" + (0, _encoding.b64ToUrlSafeB64)(signingKey))) {\n            _context2.next = 9;\n            break;\n          }\n\n          console.log(\"uploading recovery data for connection\");\n          _context2.next = 9;\n          return _regenerator.default.awrap((0, _channels.uploadConnection)({\n            conn: conn,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 9:\n          connections = (0, _connectionsSlice.selectAllConnections)(_store.store.getState());\n          connectionsById = _lodash.default.keyBy(connections, 'id');\n          groupsById = _lodash.default.keyBy(groups, 'id');\n          _context2.next = 14;\n          return _regenerator.default.awrap(nodeApi.getConnections(conn.id, 'inbound'));\n\n        case 14:\n          otherSideConnections = _context2.sent;\n          knownLevels = ['just met', 'already known', 'recovery'];\n          mutualConnections = otherSideConnections ? otherSideConnections.filter(function (c) {\n            return connectionsById[c.id] && connectionsById[c.id].name && knownLevels.includes(c.level) && !dataIds.includes(\"connection_\" + c.id + \":\" + (0, _encoding.b64ToUrlSafeB64)(signingKey));\n          }).map(function (c) {\n            return connectionsById[c.id];\n          }) : [];\n\n          if (!dataIds.includes(\"connection_\" + user.id + \":\" + (0, _encoding.b64ToUrlSafeB64)(signingKey))) {\n            mutualConnections.push(user);\n          }\n\n          _context2.next = 20;\n          return _regenerator.default.awrap(nodeApi.getMemberships(conn.id));\n\n        case 20:\n          otherSideGroups = _context2.sent;\n          mutualGroups = otherSideGroups ? otherSideGroups.filter(function (g) {\n            return groupsById[g.id];\n          }).map(function (g) {\n            return groupsById[g.id];\n          }) : [];\n          console.log('uploading mutual connections');\n          _iterator = _createForOfIteratorHelperLoose(mutualConnections);\n\n        case 24:\n          if ((_step = _iterator()).done) {\n            _context2.next = 30;\n            break;\n          }\n\n          c = _step.value;\n          _context2.next = 28;\n          return _regenerator.default.awrap((0, _channels.uploadConnection)({\n            conn: c,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 28:\n          _context2.next = 24;\n          break;\n\n        case 30:\n          console.log('uploading mutual groups');\n          _iterator2 = _createForOfIteratorHelperLoose(mutualGroups);\n\n        case 32:\n          if ((_step2 = _iterator2()).done) {\n            _context2.next = 38;\n            break;\n          }\n\n          g = _step2.value;\n          _context2.next = 36;\n          return _regenerator.default.awrap((0, _channels.uploadGroup)({\n            group: g,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 36:\n          _context2.next = 32;\n          break;\n\n        case 38:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nexports.uploadMutualInfo = uploadMutualInfo;","map":{"version":3,"names":["uploadSig","id","aesKey","channelApi","_","getState","secretKey","keypair","signer","user","loadRecoveryData","signingKey","timestamp","op","name","v","message","stringify","sig","uInt8ArrayToB64","nacl","sign","detached","strToUint8Array","data","upload","channelId","hash","dataId","uploadMutualInfo","conn","nodeApi","store","publicKey","groups","list","dataIds","includes","b64ToUrlSafeB64","console","log","uploadConnection","connections","selectAllConnections","connectionsById","keyBy","groupsById","getConnections","otherSideConnections","knownLevels","mutualConnections","filter","c","level","map","push","getMemberships","otherSideGroups","mutualGroups","g","uploadGroup","group"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/channelUploadThunks.ts"],"sourcesContent":["import _ from 'lodash';\nimport nacl from 'tweetnacl';\nimport stringify from 'fast-json-stable-stringify';\nimport {\n  b64ToUrlSafeB64,\n  strToUint8Array,\n  uInt8ArrayToB64,\n  hash,\n} from '@/utils/encoding';\nimport { selectAllConnections } from '@/reducer/connectionsSlice';\nimport ChannelAPI from '@/api/channelService';\nimport { NodeApi } from '@/api/brightId';\nimport { store } from '@/store';\nimport { loadRecoveryData } from '@/utils/recovery';\nimport { uploadConnection, uploadGroup } from '@/utils/channels';\n\nexport const uploadSig =\n  ({\n    id,\n    aesKey,\n    channelApi,\n  }: {\n    id: string;\n    aesKey: string;\n    channelApi: ChannelAPI;\n  }) =>\n  async (_, getState) => {\n    const {\n      keypair: { secretKey },\n      user: { id: signer },\n    } = getState();\n\n    const { signingKey, timestamp } = await loadRecoveryData(\n      channelApi,\n      aesKey,\n    );\n\n    const op = {\n      name: 'Social Recovery',\n      id,\n      signingKey,\n      timestamp,\n      v: 6,\n    };\n    const message = stringify(op);\n    const sig = uInt8ArrayToB64(\n      nacl.sign.detached(strToUint8Array(message), secretKey),\n    );\n\n    const data = { signer, id, sig };\n\n    await channelApi.upload({\n      channelId: hash(aesKey),\n      dataId: `sig_${signer}`,\n      data,\n    });\n  };\n\nexport const uploadMutualInfo = async ({\n  conn,\n  aesKey,\n  channelApi,\n  nodeApi,\n}: {\n  conn: Connection;\n  aesKey: string;\n  channelApi: ChannelAPI;\n  nodeApi: NodeApi;\n}) => {\n  const {\n    keypair: { publicKey: signingKey },\n    groups: { groups },\n    user,\n  } = store.getState();\n  const dataIds = await channelApi.list(hash(aesKey));\n  if (\n    !dataIds.includes(`connection_${conn.id}:${b64ToUrlSafeB64(signingKey)}`)\n  ) {\n    console.log(`uploading recovery data for connection`);\n    await uploadConnection({\n      conn,\n      channelApi,\n      aesKey,\n      signingKey,\n    });\n  }\n  const connections = selectAllConnections(store.getState());\n\n  const connectionsById = _.keyBy(connections, 'id');\n  const groupsById = _.keyBy(groups, 'id');\n\n  const otherSideConnections = await nodeApi.getConnections(conn.id, 'inbound');\n  const knownLevels = ['just met', 'already known', 'recovery'];\n  const mutualConnections = otherSideConnections\n    ? otherSideConnections\n        .filter(\n          (c) =>\n            connectionsById[c.id] &&\n            connectionsById[c.id].name &&\n            knownLevels.includes(c.level) &&\n            !dataIds.includes(\n              `connection_${c.id}:${b64ToUrlSafeB64(signingKey)}`,\n            ),\n        )\n        .map((c) => connectionsById[c.id])\n    : [];\n\n  if (\n    !dataIds.includes(`connection_${user.id}:${b64ToUrlSafeB64(signingKey)}`)\n  ) {\n    mutualConnections.push(user);\n  }\n\n  const otherSideGroups = await nodeApi.getMemberships(conn.id);\n  const mutualGroups = otherSideGroups\n    ? otherSideGroups\n        .filter((g) => groupsById[g.id])\n        .map((g) => groupsById[g.id])\n    : [];\n\n  console.log('uploading mutual connections');\n  for (const c of mutualConnections) {\n    await uploadConnection({\n      conn: c,\n      channelApi,\n      aesKey,\n      signingKey,\n    });\n  }\n  console.log('uploading mutual groups');\n  for (const g of mutualGroups) {\n    await uploadGroup({ group: g, channelApi, aesKey, signingKey });\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}