{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uploadGroup = exports.uploadContextInfo = exports.uploadConnection = exports.uploadBlindSig = exports.parseChannelQrURL = exports.generateChannelData = exports.createChannelInfo = exports.buildChannelQrUrl = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _i18next = _interopRequireDefault(require(\"i18next\"));\n\nvar _encoding = require(\"./encoding\");\n\nvar _constants = require(\"./constants\");\n\nvar _channelSlice = require(\"../components/PendingConnections/channelSlice\");\n\nvar _channelService = _interopRequireDefault(require(\"../api/channelService\"));\n\nvar _cryptoHelper = require(\"./cryptoHelper\");\n\nvar _filesystem = require(\"./filesystem\");\n\nvar generateChannelData = function _callee(channelType, url) {\n  var aesKey, id, timestamp, ttl, myProfileId, initiatorProfileId, type, state, channelApi;\n  return _regenerator.default.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regenerator.default.awrap((0, _encoding.urlSafeRandomKey)(16));\n\n        case 2:\n          aesKey = _context.sent;\n          _context.next = 5;\n          return _regenerator.default.awrap((0, _encoding.urlSafeRandomKey)(9));\n\n        case 5:\n          id = _context.sent;\n          timestamp = Date.now();\n          ttl = _constants.CHANNEL_TTL;\n          _context.next = 10;\n          return _regenerator.default.awrap((0, _encoding.urlSafeRandomKey)(9));\n\n        case 10:\n          myProfileId = _context.sent;\n          initiatorProfileId = myProfileId;\n          type = channelType;\n          state = _channelSlice.channel_states.OPEN;\n          channelApi = new _channelService.default(url.href);\n          return _context.abrupt(\"return\", {\n            aesKey: aesKey,\n            api: channelApi,\n            id: id,\n            initiatorProfileId: initiatorProfileId,\n            myProfileId: myProfileId,\n            state: state,\n            timestamp: timestamp,\n            ttl: ttl,\n            type: type,\n            url: url\n          });\n\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nexports.generateChannelData = generateChannelData;\n\nvar createChannelInfo = function createChannelInfo(channel) {\n  var version;\n\n  switch (channel.type) {\n    case _channelSlice.channel_types.SINGLE:\n    case _channelSlice.channel_types.GROUP:\n      version = _constants.CHANNEL_INFO_VERSION_1;\n      break;\n\n    case _channelSlice.channel_types.STAR:\n      version = _constants.CHANNEL_INFO_VERSION_2;\n      break;\n\n    default:\n      throw new Error(\"Unhandled channel type \" + channel.type);\n  }\n\n  var obj = {\n    version: version,\n    type: channel.type,\n    timestamp: channel.timestamp,\n    ttl: channel.ttl,\n    initiatorProfileId: channel.initiatorProfileId\n  };\n  return obj;\n};\n\nexports.createChannelInfo = createChannelInfo;\n\nvar buildChannelQrUrl = function buildChannelQrUrl(_ref) {\n  var aesKey = _ref.aesKey,\n      id = _ref.id,\n      url = _ref.url;\n  var qrUrl = new URL(url.href);\n  qrUrl.searchParams.append('aes', aesKey);\n  qrUrl.searchParams.append('id', id);\n  return qrUrl;\n};\n\nexports.buildChannelQrUrl = buildChannelQrUrl;\n\nvar parseChannelQrURL = function _callee2(url) {\n  var aesKey, id, channelApi, channelInfo, msg, _msg, myProfileId, channel;\n\n  return _regenerator.default.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          aesKey = url.searchParams.get('aes');\n          url.searchParams.delete('aes');\n          id = url.searchParams.get('id');\n          url.searchParams.delete('id');\n          channelApi = new _channelService.default(url.href);\n          _context2.next = 7;\n          return _regenerator.default.awrap(channelApi.download({\n            channelId: id,\n            dataId: _constants.CHANNEL_INFO_NAME\n          }));\n\n        case 7:\n          channelInfo = _context2.sent;\n          console.log(\"Got ChannelInfo:\");\n          console.log(channelInfo);\n\n          if (!(channelInfo.version > _constants.MAX_CHANNEL_INFO_VERSION)) {\n            _context2.next = 15;\n            break;\n          }\n\n          msg = _i18next.default.t('channel.alert.text.localOutdated', 'client version outdated - please update your client and retry');\n          throw new Error(msg);\n\n        case 15:\n          if (!(channelInfo.version < _constants.MIN_CHANNEL_INFO_VERSION)) {\n            _context2.next = 18;\n            break;\n          }\n\n          _msg = _i18next.default.t('channel.alert.text.otherOutdated', 'other client version outdated - QRCode creator needs to update client and retry');\n          throw new Error(_msg);\n\n        case 18:\n          _context2.next = 20;\n          return _regenerator.default.awrap((0, _encoding.urlSafeRandomKey)(9));\n\n        case 20:\n          myProfileId = _context2.sent;\n          channel = {\n            aesKey: aesKey,\n            api: channelApi,\n            id: id,\n            initiatorProfileId: channelInfo.initiatorProfileId,\n            myProfileId: myProfileId,\n            state: _channelSlice.channel_states.OPEN,\n            timestamp: channelInfo.timestamp,\n            ttl: channelInfo.ttl,\n            type: channelInfo.type,\n            url: url\n          };\n          return _context2.abrupt(\"return\", channel);\n\n        case 23:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nexports.parseChannelQrURL = parseChannelQrURL;\n\nvar uploadConnection = function _callee3(_ref2) {\n  var conn, channelApi, aesKey, signingKey, id, name, photo, timestamp, socialMedia, photoString, dataObj, encrypted;\n  return _regenerator.default.async(function _callee3$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          conn = _ref2.conn, channelApi = _ref2.channelApi, aesKey = _ref2.aesKey, signingKey = _ref2.signingKey;\n          _context3.prev = 1;\n          id = conn.id, name = conn.name, photo = conn.photo, timestamp = conn.timestamp, socialMedia = conn.socialMedia;\n          photoString = '';\n\n          if (name) {\n            _context3.next = 6;\n            break;\n          }\n\n          return _context3.abrupt(\"return\");\n\n        case 6:\n          if (!(photo != null && photo.filename)) {\n            _context3.next = 10;\n            break;\n          }\n\n          _context3.next = 9;\n          return _regenerator.default.awrap((0, _filesystem.retrieveImage)(photo.filename));\n\n        case 9:\n          photoString = _context3.sent;\n\n        case 10:\n          dataObj = {\n            id: id,\n            photo: photoString,\n            name: name,\n            timestamp: timestamp,\n            socialMedia: socialMedia\n          };\n          encrypted = (0, _cryptoHelper.encryptData)(dataObj, aesKey);\n          console.log(\"Posting profile data of \" + id + \" ...\");\n          _context3.next = 15;\n          return _regenerator.default.awrap(channelApi.upload({\n            channelId: (0, _encoding.hash)(aesKey),\n            data: encrypted,\n            dataId: \"connection_\" + id + \":\" + (0, _encoding.b64ToUrlSafeB64)(signingKey)\n          }));\n\n        case 15:\n          _context3.next = 20;\n          break;\n\n        case 17:\n          _context3.prev = 17;\n          _context3.t0 = _context3[\"catch\"](1);\n          console.error(\"uploadConnection: \" + _context3.t0.message);\n\n        case 20:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[1, 17]], Promise);\n};\n\nexports.uploadConnection = uploadConnection;\n\nvar uploadGroup = function _callee4(_ref3) {\n  var group, channelApi, aesKey, signingKey, id, name, photo, groupKey, members, admins, photoString, dataObj, encrypted;\n  return _regenerator.default.async(function _callee4$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          group = _ref3.group, channelApi = _ref3.channelApi, aesKey = _ref3.aesKey, signingKey = _ref3.signingKey;\n          _context4.prev = 1;\n          id = group.id, name = group.name, photo = group.photo, groupKey = group.aesKey, members = group.members, admins = group.admins;\n          photoString = '';\n\n          if (groupKey) {\n            _context4.next = 6;\n            break;\n          }\n\n          return _context4.abrupt(\"return\");\n\n        case 6:\n          if (!(photo != null && photo.filename)) {\n            _context4.next = 10;\n            break;\n          }\n\n          _context4.next = 9;\n          return _regenerator.default.awrap((0, _filesystem.retrieveImage)(photo.filename));\n\n        case 9:\n          photoString = _context4.sent;\n\n        case 10:\n          dataObj = {\n            id: id,\n            photo: photoString,\n            name: name,\n            aesKey: groupKey,\n            members: members,\n            admins: admins\n          };\n          encrypted = (0, _cryptoHelper.encryptData)(dataObj, aesKey);\n          console.log(\"Posting group data of \" + id + \" ...\");\n          _context4.next = 15;\n          return _regenerator.default.awrap(channelApi.upload({\n            channelId: (0, _encoding.hash)(aesKey),\n            data: encrypted,\n            dataId: \"group_\" + id + \":\" + (0, _encoding.b64ToUrlSafeB64)(signingKey)\n          }));\n\n        case 15:\n          _context4.next = 20;\n          break;\n\n        case 17:\n          _context4.prev = 17;\n          _context4.t0 = _context4[\"catch\"](1);\n          console.error(\"uploadGroup: \" + _context4.t0.message);\n\n        case 20:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 17]], Promise);\n};\n\nexports.uploadGroup = uploadGroup;\n\nvar uploadBlindSig = function _callee5(_ref4) {\n  var sig, channelApi, aesKey, signingKey, prefix, encrypted;\n  return _regenerator.default.async(function _callee5$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          sig = _ref4.sig, channelApi = _ref4.channelApi, aesKey = _ref4.aesKey, signingKey = _ref4.signingKey, prefix = _ref4.prefix;\n          _context5.prev = 1;\n          encrypted = (0, _cryptoHelper.encryptData)(sig, aesKey);\n          console.log(\"Posting blind sig for app: \" + sig.app + \" verification: \" + sig.verification + \" ...\");\n          _context5.next = 6;\n          return _regenerator.default.awrap(channelApi.upload({\n            channelId: (0, _encoding.hash)(aesKey),\n            data: encrypted,\n            dataId: prefix + \"blindsig_\" + (0, _encoding.hash)(sig.uid) + \":\" + (0, _encoding.b64ToUrlSafeB64)(signingKey)\n          }));\n\n        case 6:\n          _context5.next = 11;\n          break;\n\n        case 8:\n          _context5.prev = 8;\n          _context5.t0 = _context5[\"catch\"](1);\n          console.error(\"uploadBlindSig: \" + _context5.t0.message);\n\n        case 11:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, [[1, 8]], Promise);\n};\n\nexports.uploadBlindSig = uploadBlindSig;\n\nvar uploadContextInfo = function _callee6(_ref5) {\n  var contextInfo, channelApi, aesKey, signingKey, prefix, encrypted;\n  return _regenerator.default.async(function _callee6$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          contextInfo = _ref5.contextInfo, channelApi = _ref5.channelApi, aesKey = _ref5.aesKey, signingKey = _ref5.signingKey, prefix = _ref5.prefix;\n          _context6.prev = 1;\n          encrypted = (0, _cryptoHelper.encryptData)(contextInfo, aesKey);\n          console.log(\"Posting ContextInfo: \" + contextInfo.context + \" - \" + contextInfo.contextId + \"...\");\n          _context6.next = 6;\n          return _regenerator.default.awrap(channelApi.upload({\n            channelId: (0, _encoding.hash)(aesKey),\n            data: encrypted,\n            dataId: prefix + \"contextInfo_\" + (0, _encoding.hash)(contextInfo.context) + \":\" + (0, _encoding.b64ToUrlSafeB64)(signingKey)\n          }));\n\n        case 6:\n          _context6.next = 11;\n          break;\n\n        case 8:\n          _context6.prev = 8;\n          _context6.t0 = _context6[\"catch\"](1);\n          console.error(\"uploadContextInfo: \" + _context6.t0.message);\n\n        case 11:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, [[1, 8]], Promise);\n};\n\nexports.uploadContextInfo = uploadContextInfo;","map":{"version":3,"names":["generateChannelData","channelType","url","urlSafeRandomKey","aesKey","id","timestamp","Date","now","ttl","CHANNEL_TTL","myProfileId","initiatorProfileId","type","state","channel_states","OPEN","channelApi","ChannelAPI","href","api","createChannelInfo","channel","version","channel_types","SINGLE","GROUP","CHANNEL_INFO_VERSION_1","STAR","CHANNEL_INFO_VERSION_2","Error","obj","buildChannelQrUrl","qrUrl","URL","searchParams","append","parseChannelQrURL","get","delete","download","channelId","dataId","CHANNEL_INFO_NAME","channelInfo","console","log","MAX_CHANNEL_INFO_VERSION","msg","i18next","t","MIN_CHANNEL_INFO_VERSION","uploadConnection","conn","signingKey","name","photo","socialMedia","photoString","filename","retrieveImage","dataObj","encrypted","encryptData","upload","hash","data","b64ToUrlSafeB64","error","message","uploadGroup","group","groupKey","members","admins","uploadBlindSig","sig","prefix","app","verification","uid","uploadContextInfo","contextInfo","context","contextId"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/utils/channels.ts"],"sourcesContent":["import i18next from 'i18next';\nimport { b64ToUrlSafeB64, hash, urlSafeRandomKey } from '@/utils/encoding';\nimport {\n  CHANNEL_TTL,\n  CHANNEL_INFO_NAME,\n  MIN_CHANNEL_INFO_VERSION,\n  CHANNEL_INFO_VERSION_1,\n  CHANNEL_INFO_VERSION_2,\n  MAX_CHANNEL_INFO_VERSION,\n} from '@/utils/constants';\nimport {\n  channel_states,\n  channel_types,\n} from '@/components/PendingConnections/channelSlice';\nimport ChannelAPI from '@/api/channelService';\nimport { encryptData } from '@/utils/cryptoHelper';\nimport { retrieveImage } from '@/utils/filesystem';\n\nexport const generateChannelData = async (\n  channelType: ChannelType,\n  url: URL,\n): Promise<Channel> => {\n  const aesKey = await urlSafeRandomKey(16);\n  const id = await urlSafeRandomKey(9);\n  const timestamp = Date.now();\n  const ttl = CHANNEL_TTL;\n  const myProfileId = await urlSafeRandomKey(9);\n  const initiatorProfileId = myProfileId;\n  const type = channelType;\n  const state = channel_states.OPEN;\n  const channelApi = new ChannelAPI(url.href);\n\n  return {\n    aesKey,\n    api: channelApi,\n    id,\n    initiatorProfileId,\n    myProfileId,\n    state,\n    timestamp,\n    ttl,\n    type,\n    url,\n  };\n};\n\nexport const createChannelInfo = (channel: Channel) => {\n  /*\n    Channel types \"SINGLE\" and \"GROUP\" are compatible with CHANNEL_INFO_VERSION 1.\n    Channel type \"STAR\" requires CHANNEL_INFO_VERSION 2\n   */\n  let version;\n  switch (channel.type) {\n    case channel_types.SINGLE:\n    case channel_types.GROUP:\n      version = CHANNEL_INFO_VERSION_1;\n      break;\n    case channel_types.STAR:\n      version = CHANNEL_INFO_VERSION_2;\n      break;\n    default:\n      throw new Error(`Unhandled channel type ${channel.type}`);\n  }\n  const obj: ChannelInfo = {\n    version,\n    type: channel.type,\n    timestamp: channel.timestamp,\n    ttl: channel.ttl,\n    initiatorProfileId: channel.initiatorProfileId,\n  };\n  return obj;\n};\n\nexport const buildChannelQrUrl = ({ aesKey, id, url }: Channel) => {\n  const qrUrl = new URL(url.href);\n  qrUrl.searchParams.append('aes', aesKey);\n  qrUrl.searchParams.append('id', id);\n  return qrUrl;\n};\n\nexport const parseChannelQrURL = async (url: URL) => {\n  // parse and remove aesKey from URL\n  const aesKey = url.searchParams.get('aes');\n  url.searchParams.delete('aes');\n  // parse and remove channelID from URL\n  const id = url.searchParams.get('id');\n  url.searchParams.delete('id');\n\n  // create channelAPI\n  const channelApi = new ChannelAPI(url.href);\n  // download channelInfo\n  const channelInfo = await channelApi.download({\n    channelId: id,\n    dataId: CHANNEL_INFO_NAME,\n  });\n  console.log(`Got ChannelInfo:`);\n  console.log(channelInfo);\n\n  if (channelInfo.version > MAX_CHANNEL_INFO_VERSION) {\n    const msg = i18next.t(\n      'channel.alert.text.localOutdated',\n      'client version outdated - please update your client and retry',\n    );\n    throw new Error(msg);\n  } else if (channelInfo.version < MIN_CHANNEL_INFO_VERSION) {\n    const msg = i18next.t(\n      'channel.alert.text.otherOutdated',\n      'other client version outdated - QRCode creator needs to update client and retry',\n    );\n    throw new Error(msg);\n  }\n\n  const myProfileId = await urlSafeRandomKey(9);\n\n  const channel: Channel = {\n    aesKey,\n    api: channelApi,\n    id,\n    initiatorProfileId: channelInfo.initiatorProfileId,\n    myProfileId,\n    state: channel_states.OPEN,\n    timestamp: channelInfo.timestamp,\n    ttl: channelInfo.ttl,\n    type: channelInfo.type,\n    url,\n  };\n  return channel;\n};\n\nexport const uploadConnection = async ({\n  conn,\n  channelApi,\n  aesKey,\n  signingKey,\n}: {\n  conn: Connection;\n  channelApi: ChannelAPI;\n  aesKey: string;\n  signingKey: string;\n}) => {\n  try {\n    const { id, name, photo, timestamp, socialMedia } = conn;\n    let photoString = '';\n\n    if (!name) {\n      return;\n    }\n\n    // retrieve photo\n    if (photo?.filename) {\n      photoString = await retrieveImage(photo.filename);\n    }\n\n    const dataObj: SyncConnection = {\n      id,\n      photo: photoString,\n      name,\n      timestamp,\n      socialMedia,\n    };\n\n    const encrypted = encryptData(dataObj, aesKey);\n    console.log(`Posting profile data of ${id} ...`);\n    await channelApi.upload({\n      channelId: hash(aesKey),\n      data: encrypted,\n      dataId: `connection_${id}:${b64ToUrlSafeB64(signingKey)}`,\n    });\n  } catch (err) {\n    console.error(`uploadConnection: ${err.message}`);\n  }\n};\n\nexport const uploadGroup = async ({\n  group,\n  channelApi,\n  aesKey,\n  signingKey,\n}: {\n  group: {\n    id: string;\n    name?: string;\n    photo?: Photo;\n    aesKey?: string;\n    members: Array<string>;\n    admins: Array<string>;\n  };\n  channelApi: ChannelAPI;\n  aesKey: string;\n  signingKey: string;\n}) => {\n  try {\n    const { id, name, photo, aesKey: groupKey, members, admins } = group;\n    let photoString = '';\n    if (!groupKey) {\n      // not worth uploading group data is missing\n      return;\n    }\n    // retrieve photo\n    if (photo?.filename) {\n      photoString = await retrieveImage(photo.filename);\n    }\n\n    const dataObj = {\n      id,\n      photo: photoString,\n      name,\n      aesKey: groupKey,\n      members,\n      admins,\n    };\n\n    const encrypted = encryptData(dataObj, aesKey);\n    console.log(`Posting group data of ${id} ...`);\n    await channelApi.upload({\n      channelId: hash(aesKey),\n      data: encrypted,\n      dataId: `group_${id}:${b64ToUrlSafeB64(signingKey)}`,\n    });\n  } catch (err) {\n    console.error(`uploadGroup: ${err.message}`);\n  }\n};\n\nexport const uploadBlindSig = async ({\n  sig,\n  channelApi,\n  aesKey,\n  signingKey,\n  prefix,\n}: {\n  sig: SigInfo;\n  channelApi: ChannelAPI;\n  aesKey: string;\n  signingKey: string;\n  prefix: string;\n}) => {\n  try {\n    const encrypted = encryptData(sig, aesKey);\n    console.log(\n      `Posting blind sig for app: ${sig.app} verification: ${sig.verification} ...`,\n    );\n    await channelApi.upload({\n      channelId: hash(aesKey),\n      data: encrypted,\n      // use hash of sig.uid to avoid revealing it\n      dataId: `${prefix}blindsig_${hash(sig.uid)}:${b64ToUrlSafeB64(\n        signingKey,\n      )}`,\n    });\n  } catch (err) {\n    console.error(`uploadBlindSig: ${err.message}`);\n  }\n};\n\nexport const uploadContextInfo = async ({\n  contextInfo,\n  channelApi,\n  aesKey,\n  signingKey,\n  prefix,\n}: {\n  contextInfo: ContextInfo;\n  channelApi: ChannelAPI;\n  aesKey: string;\n  signingKey: string;\n  prefix: string;\n}) => {\n  try {\n    const encrypted = encryptData(contextInfo, aesKey);\n    console.log(\n      `Posting ContextInfo: ${contextInfo.context} - ${contextInfo.contextId}...`,\n    );\n    await channelApi.upload({\n      channelId: hash(aesKey),\n      data: encrypted,\n      dataId: `${prefix}contextInfo_${hash(\n        contextInfo.context,\n      )}:${b64ToUrlSafeB64(signingKey)}`,\n    });\n  } catch (err) {\n    console.error(`uploadContextInfo: ${err.message}`);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}