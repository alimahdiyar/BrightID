{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport nacl from 'tweetnacl';\nimport { addChannel, selectChannelById, removeChannel, setMyChannel, updateChannel, selectAllChannelIds, channel_types, selectAllChannels } from \"../channelSlice\";\nimport { selectAllSocialMediaToShare } from \"../../../reducer/socialMediaSlice\";\nimport { retrieveImage } from \"../../../utils/filesystem\";\nimport { encryptData } from \"../../../utils/cryptoHelper\";\nimport { generateChannelData, createChannelInfo } from \"../../../utils/channels\";\nimport { CHANNEL_CONNECTION_LIMIT, MIN_CHANNEL_JOIN_TTL, PROFILE_POLL_INTERVAL, PROFILE_VERSION, CHANNEL_INFO_NAME } from \"../../../utils/constants\";\nimport { newPendingConnection, selectAllPendingConnectionIds } from \"../pendingConnectionSlice\";\nimport { selectBaseUrl } from \"../../../reducer/settingsSlice\";\nimport { strToUint8Array, uInt8ArrayToB64 } from \"../../../utils/encoding\";\nexport var createChannel = function createChannel(channelType, api) {\n  return function _callee(dispatch, getState) {\n    var channel, baseUrl, url, channelInfo;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            baseUrl = selectBaseUrl(getState());\n            url = new URL(baseUrl + \"/profile\");\n            _context.next = 5;\n            return _regeneratorRuntime.awrap(generateChannelData(channelType, url));\n\n          case 5:\n            channel = _context.sent;\n            channel.timeoutId = setTimeout(function () {\n              console.log(\"timer expired for channel \" + channel.id);\n              dispatch(leaveChannel(channel.id));\n            }, channel.ttl);\n            dispatch(addChannel(channel));\n            dispatch(setMyChannel({\n              channelId: channel.id,\n              channelType: channel.type\n            }));\n            channelInfo = createChannelInfo(channel);\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(channel.api.upload({\n              channelId: channel.id,\n              data: channelInfo,\n              dataId: CHANNEL_INFO_NAME,\n              requestedTtl: channel.ttl\n            }));\n\n          case 12:\n            _context.next = 14;\n            return _regeneratorRuntime.awrap(dispatch(encryptAndUploadProfileToChannel(channel.id)));\n\n          case 14:\n            dispatch(subscribeToConnectionRequests(channel.id, api));\n            _context.next = 22;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context[\"catch\"](0);\n\n            if (channel && channel.id) {\n              dispatch(leaveChannel(channel.id));\n            }\n\n            console.log(\"Error while creating channel: \" + _context.t0);\n            throw _context.t0;\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 17]], Promise);\n  };\n};\nexport var joinChannel = function joinChannel(channel, api) {\n  return function _callee2(dispatch, getState) {\n    var channelIds, ttl_remain, entries, channelInfoIndex;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            console.log(\"Joining channel \" + channel.id + \" at \" + channel.url.href);\n            channelIds = selectAllChannelIds(getState());\n\n            if (!channelIds.includes(channel.id)) {\n              _context2.next = 5;\n              break;\n            }\n\n            console.log(\"Channel \" + channel.id + \" already joined\");\n            return _context2.abrupt(\"return\");\n\n          case 5:\n            ttl_remain = channel.timestamp + channel.ttl - Date.now();\n            _context2.prev = 6;\n\n            if (!(ttl_remain < MIN_CHANNEL_JOIN_TTL)) {\n              _context2.next = 10;\n              break;\n            }\n\n            console.log(\"Remaining ttl \" + ttl_remain + \" of channel \" + channel.id + \" too low. Aborting join.\");\n            throw new Error('Channel expired');\n\n          case 10:\n            _context2.next = 12;\n            return _regeneratorRuntime.awrap(channel.api.list(channel.id));\n\n          case 12:\n            entries = _context2.sent;\n            channelInfoIndex = entries.indexOf(CHANNEL_INFO_NAME);\n\n            if (channelInfoIndex > -1) {\n              entries.splice(channelInfoIndex, 1);\n            }\n\n            if (!(entries.length >= CHANNEL_CONNECTION_LIMIT)) {\n              _context2.next = 17;\n              break;\n            }\n\n            throw new Error(\"Channel is full\");\n\n          case 17:\n            channel.timeoutId = setTimeout(function () {\n              console.log(\"timer expired for channel \" + channel.id);\n              dispatch(leaveChannel(channel.id));\n            }, ttl_remain);\n            dispatch(addChannel(channel));\n            dispatch(subscribeToConnectionRequests(channel.id, api));\n            _context2.next = 26;\n            break;\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](6);\n            dispatch(leaveChannel(channel.id));\n            throw _context2.t0;\n\n          case 26:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[6, 22]], Promise);\n  };\n};\nexport var leaveChannel = function leaveChannel(channelId) {\n  return function (dispatch, getState) {\n    var channel = selectChannelById(getState(), channelId);\n\n    if (channel) {\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channelId));\n      dispatch(removeChannel(channelId));\n    }\n  };\n};\nexport var leaveAllChannels = function leaveAllChannels() {\n  return function (dispatch, getState) {\n    var channels = selectAllChannels(getState());\n\n    for (var _iterator = _createForOfIteratorHelperLoose(channels), _step; !(_step = _iterator()).done;) {\n      var channel = _step.value;\n      console.log(\"Leaving channel \" + channel.id);\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n      dispatch(removeChannel(channel.id));\n    }\n  };\n};\nexport var subscribeToConnectionRequests = function subscribeToConnectionRequests(channelId, api) {\n  return function (dispatch, getState) {\n    var _selectChannelById = selectChannelById(getState(), channelId),\n        pollTimerId = _selectChannelById.pollTimerId;\n\n    if (pollTimerId) {\n      console.log(\"Stopping previous timer \" + pollTimerId + \" for channel \" + channelId);\n      clearInterval(pollTimerId);\n    }\n\n    pollTimerId = setInterval(function () {\n      dispatch(fetchChannelProfiles(channelId, api));\n    }, PROFILE_POLL_INTERVAL);\n    console.log(\"Start polling channel \" + channelId + \", pollTImerId \" + pollTimerId);\n    dispatch(updateChannel({\n      id: channelId,\n      changes: {\n        pollTimerId: pollTimerId\n      }\n    }));\n  };\n};\nexport var unsubscribeFromConnectionRequests = function unsubscribeFromConnectionRequests(channelId) {\n  return function (dispatch, getState) {\n    var _selectChannelById2 = selectChannelById(getState(), channelId),\n        pollTimerId = _selectChannelById2.pollTimerId;\n\n    if (pollTimerId) {\n      console.log(\"Stop polling channel \" + channelId + \" (timer \" + pollTimerId + \")\");\n      clearInterval(pollTimerId);\n      dispatch(updateChannel({\n        id: channelId,\n        changes: {\n          pollTimerId: null\n        }\n      }));\n    }\n  };\n};\nexport var fetchChannelProfiles = function fetchChannelProfiles(channelId, api) {\n  return function _callee3(dispatch, getState) {\n    var channel, profileIds, channelInfoIndex, knownProfileIds, stopPolling, _iterator2, _step2, profileId, foundInitiator, _iterator3, _step3, _profileId, _iterator4, _step4, _profileId2;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            channel = selectChannelById(getState(), channelId);\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(channel.api.list(channelId));\n\n          case 3:\n            profileIds = _context3.sent;\n            channelInfoIndex = profileIds.indexOf(CHANNEL_INFO_NAME);\n\n            if (channelInfoIndex > -1) {\n              profileIds.splice(channelInfoIndex, 1);\n            }\n\n            profileIds = profileIds.slice(0, CHANNEL_CONNECTION_LIMIT);\n            knownProfileIds = selectAllPendingConnectionIds(getState());\n\n            if (__DEV__ && profileIds.length > knownProfileIds.length + 1) {\n              console.log(\"Got \" + profileIds.length + \" profileIds:\", profileIds);\n            }\n\n            stopPolling = false;\n            _context3.t0 = channel.type;\n            _context3.next = _context3.t0 === channel_types.STAR ? 13 : _context3.t0 === channel_types.GROUP ? 33 : _context3.t0 === channel_types.SINGLE ? 43 : 53;\n            break;\n\n          case 13:\n            if (!(channel.initiatorProfileId === channel.myProfileId)) {\n              _context3.next = 25;\n              break;\n            }\n\n            _iterator2 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 15:\n            if ((_step2 = _iterator2()).done) {\n              _context3.next = 22;\n              break;\n            }\n\n            profileId = _step2.value;\n\n            if (!(profileId !== channel.myProfileId && !knownProfileIds.includes(profileId))) {\n              _context3.next = 20;\n              break;\n            }\n\n            _context3.next = 20;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: profileId,\n              api: api\n            })));\n\n          case 20:\n            _context3.next = 15;\n            break;\n\n          case 22:\n            stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n            _context3.next = 32;\n            break;\n\n          case 25:\n            console.log(\"STAR channel - Participant waiting for initiator profile\");\n            foundInitiator = profileIds.includes(channel.initiatorProfileId);\n\n            if (!(foundInitiator && !knownProfileIds.includes(channel.initiatorProfileId))) {\n              _context3.next = 31;\n              break;\n            }\n\n            console.log(\"STAR channel - Participant found initiator profileID \" + channel.initiatorProfileId);\n            _context3.next = 31;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: channel.initiatorProfileId,\n              api: api\n            })));\n\n          case 31:\n            stopPolling = foundInitiator;\n\n          case 32:\n            return _context3.abrupt(\"break\", 53);\n\n          case 33:\n            _iterator3 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 34:\n            if ((_step3 = _iterator3()).done) {\n              _context3.next = 41;\n              break;\n            }\n\n            _profileId = _step3.value;\n\n            if (!(_profileId !== channel.myProfileId && !knownProfileIds.includes(_profileId))) {\n              _context3.next = 39;\n              break;\n            }\n\n            _context3.next = 39;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: _profileId,\n              api: api\n            })));\n\n          case 39:\n            _context3.next = 34;\n            break;\n\n          case 41:\n            stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n            return _context3.abrupt(\"break\", 53);\n\n          case 43:\n            _iterator4 = _createForOfIteratorHelperLoose(profileIds);\n\n          case 44:\n            if ((_step4 = _iterator4()).done) {\n              _context3.next = 51;\n              break;\n            }\n\n            _profileId2 = _step4.value;\n\n            if (!(_profileId2 !== channel.myProfileId && !knownProfileIds.includes(_profileId2))) {\n              _context3.next = 49;\n              break;\n            }\n\n            _context3.next = 49;\n            return _regeneratorRuntime.awrap(dispatch(newPendingConnection({\n              channelId: channelId,\n              profileId: _profileId2,\n              api: api\n            })));\n\n          case 49:\n            _context3.next = 44;\n            break;\n\n          case 51:\n            stopPolling = profileIds.length >= 2;\n            return _context3.abrupt(\"break\", 53);\n\n          case 53:\n            if (stopPolling) {\n              console.log(\"Got expected profiles for channel \" + channel.id + \". Unsubscribing.\");\n              dispatch(unsubscribeFromConnectionRequests(channel.id));\n            }\n\n          case 54:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var encryptAndUploadProfileToChannel = function encryptAndUploadProfileToChannel(channelId) {\n  return function _callee4(dispatch, getState) {\n    var channel, _getState$user, id, filename, name, notificationToken, socialMedia, photo, profileTimestamp, dataObj, message, secretKey, encrypted;\n\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            channel = selectChannelById(getState(), channelId);\n            _getState$user = getState().user, id = _getState$user.id, filename = _getState$user.photo.filename, name = _getState$user.name;\n            notificationToken = getState().notifications.notificationToken;\n            socialMedia = selectAllSocialMediaToShare(getState());\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(retrieveImage(filename));\n\n          case 6:\n            photo = _context4.sent;\n            profileTimestamp = Date.now();\n            dataObj = {\n              id: id,\n              photo: photo,\n              name: name,\n              socialMedia: socialMedia,\n              profileTimestamp: profileTimestamp,\n              notificationToken: notificationToken,\n              version: PROFILE_VERSION\n            };\n\n            if (channel.initiatorProfileId === channel.myProfileId) {\n              message = id + \"|\" + profileTimestamp;\n              secretKey = getState().keypair.secretKey;\n              dataObj.requestProof = uInt8ArrayToB64(nacl.sign.detached(strToUint8Array(message), secretKey));\n            }\n\n            console.log(\"Encrypting profile data with key \" + channel.aesKey);\n            encrypted = encryptData(dataObj, channel.aesKey);\n            console.log(\"Posting profile data...\");\n            _context4.next = 15;\n            return _regeneratorRuntime.awrap(channel.api.upload({\n              channelId: channelId,\n              data: encrypted,\n              dataId: channel.myProfileId\n            }));\n\n          case 15:\n            dispatch(updateChannel({\n              id: channelId,\n              changes: {\n                myProfileTimestamp: profileTimestamp\n              }\n            }));\n\n          case 16:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"names":["nacl","addChannel","selectChannelById","removeChannel","setMyChannel","updateChannel","selectAllChannelIds","channel_types","selectAllChannels","selectAllSocialMediaToShare","retrieveImage","encryptData","generateChannelData","createChannelInfo","CHANNEL_CONNECTION_LIMIT","MIN_CHANNEL_JOIN_TTL","PROFILE_POLL_INTERVAL","PROFILE_VERSION","CHANNEL_INFO_NAME","newPendingConnection","selectAllPendingConnectionIds","selectBaseUrl","strToUint8Array","uInt8ArrayToB64","createChannel","channelType","api","dispatch","getState","baseUrl","url","URL","channel","timeoutId","setTimeout","console","log","id","leaveChannel","ttl","channelId","type","channelInfo","upload","data","dataId","requestedTtl","encryptAndUploadProfileToChannel","subscribeToConnectionRequests","joinChannel","href","channelIds","includes","ttl_remain","timestamp","Date","now","Error","list","entries","channelInfoIndex","indexOf","splice","length","clearTimeout","unsubscribeFromConnectionRequests","leaveAllChannels","channels","pollTimerId","clearInterval","setInterval","fetchChannelProfiles","changes","profileIds","slice","knownProfileIds","__DEV__","stopPolling","STAR","GROUP","SINGLE","initiatorProfileId","myProfileId","profileId","foundInitiator","user","filename","photo","name","notificationToken","notifications","socialMedia","profileTimestamp","dataObj","version","message","secretKey","keypair","requestProof","sign","detached","aesKey","encrypted","myProfileTimestamp"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/actions/channelThunks.ts"],"sourcesContent":["import nacl from 'tweetnacl';\nimport {\n  addChannel,\n  selectChannelById,\n  removeChannel,\n  setMyChannel,\n  updateChannel,\n  selectAllChannelIds,\n  channel_types,\n  selectAllChannels,\n} from '@/components/PendingConnections/channelSlice';\nimport { selectAllSocialMediaToShare } from '@/reducer/socialMediaSlice';\nimport { retrieveImage } from '@/utils/filesystem';\nimport { encryptData } from '@/utils/cryptoHelper';\nimport { generateChannelData, createChannelInfo } from '@/utils/channels';\nimport {\n  CHANNEL_CONNECTION_LIMIT,\n  MIN_CHANNEL_JOIN_TTL,\n  PROFILE_POLL_INTERVAL,\n  PROFILE_VERSION,\n  CHANNEL_INFO_NAME,\n} from '@/utils/constants';\nimport {\n  newPendingConnection,\n  selectAllPendingConnectionIds,\n} from '@/components/PendingConnections/pendingConnectionSlice';\nimport { selectBaseUrl } from '@/reducer/settingsSlice';\nimport { NodeApi } from '@/api/brightId';\nimport { strToUint8Array, uInt8ArrayToB64 } from '@/utils/encoding';\n\nexport const createChannel =\n  (channelType: ChannelType, api: NodeApi) =>\n  async (dispatch: dispatch, getState: getState) => {\n    let channel: Channel | null | undefined;\n    try {\n      const baseUrl = selectBaseUrl(getState());\n      const url = new URL(`${baseUrl}/profile`);\n      // use this for local running profile service\n      // const url = new URL(`http://10.0.2.2:3000/`);\n      channel = await generateChannelData(channelType, url);\n\n      // Set timeout to expire channel\n      channel.timeoutId = setTimeout(() => {\n        console.log(`timer expired for channel ${channel.id}`);\n        dispatch(leaveChannel(channel.id));\n      }, channel.ttl);\n      dispatch(addChannel(channel));\n      dispatch(\n        setMyChannel({ channelId: channel.id, channelType: channel.type }),\n      );\n\n      // upload channel info\n      const channelInfo: ChannelInfo = createChannelInfo(channel);\n      await channel.api.upload({\n        channelId: channel.id,\n        data: channelInfo,\n        dataId: CHANNEL_INFO_NAME,\n        requestedTtl: channel.ttl,\n      });\n\n      // upload my profile\n      await dispatch(encryptAndUploadProfileToChannel(channel.id));\n      // start polling for profiles\n      dispatch(subscribeToConnectionRequests(channel.id, api));\n    } catch (e) {\n      // Something went wrong while creating channel.\n      if (channel && channel.id) {\n        dispatch(leaveChannel(channel.id));\n      }\n      console.log(`Error while creating channel: ${e}`);\n      // need to throw to prevent app from looping\n      throw e;\n    }\n  };\n\nexport const joinChannel =\n  (channel: Channel, api: NodeApi) =>\n  async (dispatch: dispatch, getState: getState) => {\n    console.log(`Joining channel ${channel.id} at ${channel.url.href}`);\n    // check to see if channel exists\n    const channelIds = selectAllChannelIds(getState());\n    if (channelIds.includes(channel.id)) {\n      console.log(`Channel ${channel.id} already joined`);\n      return;\n    }\n\n    // calc remaining lifetime of channel\n    const ttl_remain = channel.timestamp + channel.ttl - Date.now();\n\n    try {\n      // don't join channel if it is/is about to expired\n      if (ttl_remain < MIN_CHANNEL_JOIN_TTL) {\n        console.log(\n          `Remaining ttl ${ttl_remain} of channel ${channel.id} too low. Aborting join.`,\n        );\n        throw new Error('Channel expired');\n      }\n\n      // don't join channel if it already has maximum allowed number of entries.\n      // Note that this is a client-side limitation in order to keep the UI usable.\n      const entries = await channel.api.list(channel.id);\n      // channel.api.list() will include the channelInfo.json file.\n      // Remove it from list as I don't want to download and interpret it as a profile.\n      const channelInfoIndex = entries.indexOf(CHANNEL_INFO_NAME);\n      if (channelInfoIndex > -1) {\n        entries.splice(channelInfoIndex, 1);\n      }\n      if (entries.length >= CHANNEL_CONNECTION_LIMIT) {\n        throw new Error(`Channel is full`);\n      }\n\n      // Start timer to expire channel\n      channel.timeoutId = setTimeout(() => {\n        console.log(`timer expired for channel ${channel.id}`);\n        dispatch(leaveChannel(channel.id));\n      }, ttl_remain);\n\n      // add channel to store\n      // we need channel to exist prior to uploadingProfileToChannel\n      dispatch(addChannel(channel));\n\n      // start polling for profiles\n      dispatch(subscribeToConnectionRequests(channel.id, api));\n    } catch (e) {\n      // Something went wrong while trying to join channel.\n      dispatch(leaveChannel(channel.id));\n      throw e;\n    }\n  };\n\nexport const leaveChannel =\n  (channelId: string) => (dispatch: dispatch, getState: getState) => {\n    const channel: Channel = selectChannelById(getState(), channelId);\n    if (channel) {\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channelId));\n      dispatch(removeChannel(channelId));\n    }\n  };\n\nexport const leaveAllChannels =\n  () => (dispatch: dispatch, getState: getState) => {\n    const channels = selectAllChannels(getState());\n    for (const channel of channels) {\n      console.log(`Leaving channel ${channel.id}`);\n      clearTimeout(channel.timeoutId);\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n      dispatch(removeChannel(channel.id));\n    }\n  };\n\nexport const subscribeToConnectionRequests =\n  (channelId: string, api: NodeApi) =>\n  (dispatch: dispatch, getState: getState) => {\n    let { pollTimerId } = selectChannelById(getState(), channelId);\n\n    if (pollTimerId) {\n      console.log(\n        `Stopping previous timer ${\n          pollTimerId as any\n        } for channel ${channelId}`,\n      );\n      clearInterval(pollTimerId);\n    }\n\n    pollTimerId = setInterval(() => {\n      // fetch all profileIDs in channel\n      dispatch(fetchChannelProfiles(channelId, api));\n    }, PROFILE_POLL_INTERVAL);\n\n    console.log(\n      `Start polling channel ${channelId}, pollTImerId ${pollTimerId}`,\n    );\n\n    dispatch(\n      updateChannel({\n        id: channelId,\n        changes: {\n          pollTimerId,\n        },\n      }),\n    );\n  };\n\nexport const unsubscribeFromConnectionRequests =\n  (channelId: string) => (dispatch: dispatch, getState: getState) => {\n    const { pollTimerId } = selectChannelById(getState(), channelId);\n\n    if (pollTimerId) {\n      console.log(`Stop polling channel ${channelId} (timer ${pollTimerId})`);\n      clearInterval(pollTimerId);\n      dispatch(\n        updateChannel({\n          id: channelId,\n          changes: {\n            pollTimerId: null,\n          },\n        }),\n      );\n    }\n  };\n\nexport const fetchChannelProfiles =\n  (channelId: string, api: NodeApi) =>\n  async (dispatch: Dispatch, getState: GetState) => {\n    const channel = selectChannelById(getState(), channelId);\n    let profileIds = await channel.api.list(channelId);\n\n    // channel.api.list() will include the channelInfo.json file.\n    // Remove it from list as I don't want to download and interpret it as a profile.\n    const channelInfoIndex = profileIds.indexOf(CHANNEL_INFO_NAME);\n    if (channelInfoIndex > -1) {\n      profileIds.splice(channelInfoIndex, 1);\n    }\n\n    // Only get up to CHANNEL_CONNECTION_LIMIT profiles\n    profileIds = profileIds.slice(0, CHANNEL_CONNECTION_LIMIT);\n    const knownProfileIds = selectAllPendingConnectionIds(getState());\n    if (__DEV__ && profileIds.length > knownProfileIds.length + 1) {\n      console.log(`Got ${profileIds.length} profileIds:`, profileIds);\n    }\n\n    /*\n  Polling logic:\n  type STAR:\n   - Channel creator: Load all profiles\n   - Other participant: Only load creator profile\n  type GROUP:\n   - everybody load all profiles\n  type SINGLE:\n   - Channel creator: Load participant profile\n   - Other participant: Load creator profile\n */\n    let stopPolling = false;\n    switch (channel.type) {\n      case channel_types.STAR:\n        if (channel.initiatorProfileId === channel.myProfileId) {\n          // Channel creator: Load all profiles\n          for (const profileId of profileIds) {\n            if (\n              profileId !== channel.myProfileId &&\n              !knownProfileIds.includes(profileId)\n            ) {\n              await dispatch(\n                newPendingConnection({\n                  channelId,\n                  profileId,\n                  api,\n                }),\n              );\n            }\n          }\n          // stop polling when channel limit is reached\n          stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n        } else {\n          // other participant: Only load initiator profile\n          console.log(\n            `STAR channel - Participant waiting for initiator profile`,\n          );\n          const foundInitiator = profileIds.includes(\n            channel.initiatorProfileId,\n          );\n          if (\n            foundInitiator &&\n            !knownProfileIds.includes(channel.initiatorProfileId)\n          ) {\n            console.log(\n              `STAR channel - Participant found initiator profileID ${channel.initiatorProfileId}`,\n            );\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId: channel.initiatorProfileId,\n                api,\n              }),\n            );\n          }\n          // stop polling when initiator profile is found\n          stopPolling = foundInitiator;\n        }\n        break;\n      case channel_types.GROUP:\n        // Always load all profiles\n        for (const profileId of profileIds) {\n          if (\n            profileId !== channel.myProfileId &&\n            !knownProfileIds.includes(profileId)\n          ) {\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId,\n                api,\n              }),\n            );\n          }\n        }\n        // stop polling only when channel limit is reached\n        stopPolling = profileIds.length >= CHANNEL_CONNECTION_LIMIT;\n        break;\n      case channel_types.SINGLE:\n        // there should be only 2 profiles in the channel. Just load all.\n        for (const profileId of profileIds) {\n          if (\n            profileId !== channel.myProfileId &&\n            !knownProfileIds.includes(profileId)\n          ) {\n            await dispatch(\n              newPendingConnection({\n                channelId,\n                profileId,\n                api,\n              }),\n            );\n          }\n        }\n        // stop polling when 2 profiles are found (own profile and peer profile)\n        stopPolling = profileIds.length >= 2;\n        break;\n    }\n\n    if (stopPolling) {\n      console.log(\n        `Got expected profiles for channel ${channel.id}. Unsubscribing.`,\n      );\n      dispatch(unsubscribeFromConnectionRequests(channel.id));\n    }\n  };\n\nexport const encryptAndUploadProfileToChannel =\n  (channelId: string) => async (dispatch: Dispatch, getState: GetState) => {\n    // get channel\n    const channel = selectChannelById(getState(), channelId);\n    // get user data\n    const {\n      id,\n      photo: { filename },\n      name,\n    } = getState().user;\n\n    const { notificationToken } = getState().notifications;\n\n    const socialMedia = selectAllSocialMediaToShare(getState());\n\n    // retrieve photo\n    const photo = await retrieveImage(filename);\n    const profileTimestamp = Date.now();\n\n    const dataObj: SharedProfile = {\n      id,\n      photo,\n      name,\n      socialMedia,\n      profileTimestamp,\n      notificationToken,\n      version: PROFILE_VERSION,\n    };\n\n    if (channel.initiatorProfileId === channel.myProfileId) {\n      // create request proof that proves the user requested\n      // the connection by creating the qr code\n      const message = `${id}|${profileTimestamp}`;\n      const { secretKey } = getState().keypair;\n      dataObj.requestProof = uInt8ArrayToB64(\n        nacl.sign.detached(strToUint8Array(message), secretKey),\n      );\n    }\n\n    console.log(`Encrypting profile data with key ${channel.aesKey}`);\n    const encrypted = encryptData(dataObj, channel.aesKey);\n    console.log(`Posting profile data...`);\n    await channel.api.upload({\n      channelId,\n      data: encrypted,\n      dataId: channel.myProfileId,\n    });\n    dispatch(\n      updateChannel({\n        id: channelId,\n        changes: {\n          myProfileTimestamp: profileTimestamp,\n        },\n      }),\n    );\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}