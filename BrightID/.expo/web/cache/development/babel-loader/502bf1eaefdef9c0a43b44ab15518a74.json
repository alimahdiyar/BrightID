{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { hash } from \"./encoding\";\nimport { RECOVERY_CHANNEL_TTL } from \"./constants\";\nexport var buildRecoveryChannelQrUrl = function buildRecoveryChannelQrUrl(_ref) {\n  var aesKey = _ref.aesKey,\n      url = _ref.url,\n      t = _ref.t;\n  var qrUrl = new URL(url.href);\n  qrUrl.searchParams.append('aes', aesKey);\n  qrUrl.searchParams.append('t', t);\n  return qrUrl;\n};\nexport var uploadRecoveryData = function _callee(recoveryData, channelApi) {\n  var channelId, dataObj, data;\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          channelId = hash(recoveryData.aesKey);\n          dataObj = {\n            signingKey: recoveryData.publicKey,\n            timestamp: recoveryData.timestamp\n          };\n          data = JSON.stringify(dataObj);\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(channelApi.upload({\n            channelId: channelId,\n            data: data,\n            dataId: 'data',\n            requestedTtl: RECOVERY_CHANNEL_TTL\n          }));\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\nexport var loadRecoveryData = function _callee2(channelApi, aesKey) {\n  var dataString, data;\n  return _regeneratorRuntime.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regeneratorRuntime.awrap(channelApi.download({\n            channelId: hash(aesKey),\n            dataId: 'data'\n          }));\n\n        case 2:\n          dataString = _context2.sent;\n          data = JSON.parse(dataString);\n\n          if (!(!data.signingKey || !data.timestamp)) {\n            _context2.next = 6;\n            break;\n          }\n\n          throw new Error('Please ask the connection to reload their QR code and try again');\n\n        case 6:\n          return _context2.abrupt(\"return\", data);\n\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/utils/recovery.ts"],"names":["buildRecoveryChannelQrUrl","aesKey","url","t","qrUrl","uploadRecoveryData","channelId","hash","recoveryData","dataObj","signingKey","timestamp","data","JSON","channelApi","dataId","requestedTtl","loadRecoveryData","dataString"],"mappings":"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","sourcesContent":["import ChannelAPI from '@/api/channelService';\nimport { hash } from '@/utils/encoding';\nimport { RECOVERY_CHANNEL_TTL } from '@/utils/constants';\n\nexport const buildRecoveryChannelQrUrl = ({\n  aesKey,\n  url,\n  t,\n}: RecoveryChannel) => {\n  const qrUrl = new URL(url.href);\n  qrUrl.searchParams.append('aes', aesKey);\n  qrUrl.searchParams.append('t', t);\n  return qrUrl;\n};\n\nexport const uploadRecoveryData = async (\n  recoveryData: RecoveryData,\n  channelApi: ChannelAPI,\n) => {\n  const channelId = hash(recoveryData.aesKey);\n  const dataObj = {\n    signingKey: recoveryData.publicKey,\n    timestamp: recoveryData.timestamp,\n  };\n  const data = JSON.stringify(dataObj);\n  await channelApi.upload({\n    channelId,\n    data,\n    dataId: 'data',\n    requestedTtl: RECOVERY_CHANNEL_TTL,\n  });\n};\n\nexport const loadRecoveryData = async (\n  channelApi: ChannelAPI,\n  aesKey: string,\n): Promise<{ signingKey: string; timestamp: number }> => {\n  const dataString = await channelApi.download({\n    channelId: hash(aesKey),\n    dataId: 'data',\n  });\n  const data = JSON.parse(dataString);\n  if (!data.signingKey || !data.timestamp) {\n    throw new Error(\n      'Please ask the connection to reload their QR code and try again',\n    );\n  }\n  return data;\n};\n"]},"metadata":{},"sourceType":"module"}