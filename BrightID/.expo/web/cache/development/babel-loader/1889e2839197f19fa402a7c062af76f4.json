{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { hash, urlSafeRandomKey } from \"../../../../utils/encoding\";\nimport { store } from \"../../../../store\";\nimport ChannelAPI from \"../../../../api/channelService\";\nimport { selectBaseUrl } from \"../../../../reducer/settingsSlice\";\nimport { CHANNEL_POLL_INTERVAL } from \"../../RecoveryFlow/thunks/channelThunks\";\nimport { init, setRecoveryChannel } from \"../../RecoveryFlow/recoveryDataSlice\";\nimport { downloadConnections, downloadGroups } from \"../../RecoveryFlow/thunks/channelDownloadThunks\";\nimport { checkCompletedFlags, downloadBlindSigs, downloadContextInfo, downloadUserInfo } from \"./channelDownloadThunks\";\nimport { uploadAllInfoAfter, uploadDeviceInfo } from \"./channelUploadThunks\";\nimport { IMPORT_PREFIX } from \"../../../../utils/constants\";\nexport var setupSync = function setupSync() {\n  return function _callee(dispatch, getState) {\n    var _getState, recoveryData, aesKey;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _getState = getState(), recoveryData = _getState.recoveryData;\n\n            if (recoveryData.aesKey) {\n              _context.next = 6;\n              break;\n            }\n\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(urlSafeRandomKey(16));\n\n          case 4:\n            aesKey = _context.sent;\n            dispatch(init({\n              aesKey: aesKey\n            }));\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var createSyncChannel = function createSyncChannel() {\n  return function _callee2(dispatch, getState) {\n    var _getState2, aesKey, baseUrl, url, channelId, _getState3, settings, lastSyncTime, after;\n\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _getState2 = getState(), aesKey = _getState2.recoveryData.aesKey;\n            baseUrl = selectBaseUrl(getState());\n            url = new URL(baseUrl + \"/profile\");\n            channelId = hash(aesKey);\n            console.log(\"created channel \" + channelId + \" for sync data\");\n            dispatch(setRecoveryChannel({\n              channelId: channelId,\n              url: url\n            }));\n            _getState3 = getState(), settings = _getState3.settings;\n            lastSyncTime = 0;\n\n            if (settings.isPrimaryDevice) {\n              _context2.next = 14;\n              break;\n            }\n\n            _context2.next = 11;\n            return _regeneratorRuntime.awrap(uploadDeviceInfo());\n\n          case 11:\n            console.log(\"Finished uploading last sync time to the channel \" + channelId);\n            _context2.next = 19;\n            break;\n\n          case 14:\n            console.log(\"Polling last sync time from the scanner of the channel \" + channelId);\n            _context2.next = 17;\n            return _regeneratorRuntime.awrap(pollOtherSideDeviceInfo());\n\n          case 17:\n            lastSyncTime = _context2.sent.lastSyncTime;\n            console.log(\"Last sync time was \" + lastSyncTime);\n\n          case 19:\n            after = settings.isPrimaryDevice ? lastSyncTime : settings.lastSyncTime;\n            uploadAllInfoAfter(after).then(function () {\n              console.log(\"Finished uploading sync data to the channel \" + channelId);\n            });\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var getOtherSideDeviceInfo = function _callee3() {\n  var _store$getState, _store$getState$recov, url, channelId, channelApi, dataString;\n\n  return _regeneratorRuntime.async(function _callee3$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _store$getState = store.getState(), _store$getState$recov = _store$getState.recoveryData.channel, url = _store$getState$recov.url, channelId = _store$getState$recov.channelId;\n          channelApi = new ChannelAPI(url.href);\n          _context3.prev = 2;\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(channelApi.download({\n            channelId: channelId,\n            dataId: IMPORT_PREFIX + \"data\",\n            deleteAfterDownload: true\n          }));\n\n        case 5:\n          dataString = _context3.sent;\n          return _context3.abrupt(\"return\", JSON.parse(dataString));\n\n        case 9:\n          _context3.prev = 9;\n          _context3.t0 = _context3[\"catch\"](2);\n          return _context3.abrupt(\"return\", {\n            isPrimaryDevice: true\n          });\n\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[2, 9]], Promise);\n};\nexport var pollOtherSideDeviceInfo = function _callee4() {\n  var data;\n  return _regeneratorRuntime.async(function _callee4$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return _regeneratorRuntime.awrap(getOtherSideDeviceInfo());\n\n        case 2:\n          data = _context4.sent;\n\n        case 3:\n          if (!(data.lastSyncTime === undefined)) {\n            _context4.next = 11;\n            break;\n          }\n\n          _context4.next = 6;\n          return _regeneratorRuntime.awrap(new Promise(function (r) {\n            return setTimeout(r, CHANNEL_POLL_INTERVAL);\n          }));\n\n        case 6:\n          _context4.next = 8;\n          return _regeneratorRuntime.awrap(getOtherSideDeviceInfo());\n\n        case 8:\n          data = _context4.sent;\n          _context4.next = 3;\n          break;\n\n        case 11:\n          return _context4.abrupt(\"return\", data);\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\nvar channelIntervalId;\nvar checkInProgress = false;\nexport var pollImportChannel = function pollImportChannel() {\n  return function _callee5(dispatch) {\n    return _regeneratorRuntime.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            clearInterval(channelIntervalId);\n            channelIntervalId = setInterval(function () {\n              if (!checkInProgress) {\n                checkInProgress = true;\n                dispatch(checkImportChannel()).then(function () {\n                  checkInProgress = false;\n                }).catch(function (err) {\n                  checkInProgress = false;\n                  console.error(\"error polling sync/import channel: \" + err.message);\n                });\n              }\n            }, CHANNEL_POLL_INTERVAL);\n            console.log(\"start polling sync/import channel (\" + channelIntervalId + \")\");\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var clearImportChannel = function clearImportChannel() {\n  console.log(\"stop polling sync/import channel (\" + channelIntervalId + \")\");\n  clearInterval(channelIntervalId);\n};\nexport var checkImportChannel = function checkImportChannel() {\n  return function _callee6(dispatch, getState) {\n    var _getState4, _getState4$recoveryDa, channelId, url, isPrimaryDevice, channelApi, dataIds;\n\n    return _regeneratorRuntime.async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _getState4 = getState(), _getState4$recoveryDa = _getState4.recoveryData.channel, channelId = _getState4$recoveryDa.channelId, url = _getState4$recoveryDa.url, isPrimaryDevice = _getState4.settings.isPrimaryDevice;\n            channelApi = new ChannelAPI(url.href);\n            _context6.next = 4;\n            return _regeneratorRuntime.awrap(channelApi.list(channelId));\n\n          case 4:\n            dataIds = _context6.sent;\n            _context6.next = 7;\n            return _regeneratorRuntime.awrap(dispatch(downloadUserInfo({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 7:\n            _context6.next = 9;\n            return _regeneratorRuntime.awrap(dispatch(downloadConnections({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 9:\n            _context6.next = 11;\n            return _regeneratorRuntime.awrap(dispatch(downloadGroups({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 11:\n            _context6.next = 13;\n            return _regeneratorRuntime.awrap(dispatch(downloadContextInfo({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 13:\n            if (isPrimaryDevice) {\n              _context6.next = 16;\n              break;\n            }\n\n            _context6.next = 16;\n            return _regeneratorRuntime.awrap(dispatch(downloadBlindSigs({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 16:\n            _context6.next = 18;\n            return _regeneratorRuntime.awrap(dispatch(checkCompletedFlags({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 18:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"names":["hash","urlSafeRandomKey","store","ChannelAPI","selectBaseUrl","CHANNEL_POLL_INTERVAL","init","setRecoveryChannel","downloadConnections","downloadGroups","checkCompletedFlags","downloadBlindSigs","downloadContextInfo","downloadUserInfo","uploadAllInfoAfter","uploadDeviceInfo","IMPORT_PREFIX","setupSync","dispatch","getState","recoveryData","aesKey","createSyncChannel","baseUrl","url","URL","channelId","console","log","settings","lastSyncTime","isPrimaryDevice","pollOtherSideDeviceInfo","after","then","getOtherSideDeviceInfo","channel","channelApi","href","download","dataId","deleteAfterDownload","dataString","JSON","parse","data","undefined","Promise","r","setTimeout","channelIntervalId","checkInProgress","pollImportChannel","clearInterval","setInterval","checkImportChannel","catch","err","error","message","clearImportChannel","list","dataIds"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/ImportFlow/thunks/channelThunks.ts"],"sourcesContent":["import { hash, urlSafeRandomKey } from '@/utils/encoding';\nimport { store } from '@/store';\nimport ChannelAPI from '@/api/channelService';\nimport { selectBaseUrl } from '@/reducer/settingsSlice';\nimport { CHANNEL_POLL_INTERVAL } from '../../RecoveryFlow/thunks/channelThunks';\nimport { init, setRecoveryChannel } from '../../RecoveryFlow/recoveryDataSlice';\nimport {\n  downloadConnections,\n  downloadGroups,\n} from '../../RecoveryFlow/thunks/channelDownloadThunks';\nimport {\n  checkCompletedFlags,\n  downloadBlindSigs,\n  downloadContextInfo,\n  downloadUserInfo,\n} from './channelDownloadThunks';\nimport { uploadAllInfoAfter, uploadDeviceInfo } from './channelUploadThunks';\nimport { IMPORT_PREFIX } from '@/utils/constants';\n\nexport const setupSync =\n  () => async (dispatch: dispatch, getState: getState) => {\n    const { recoveryData } = getState();\n    // setup recovery data\n    if (!recoveryData.aesKey) {\n      const aesKey = await urlSafeRandomKey(16);\n      // setup recovery data slice with sync info\n      dispatch(init({ aesKey }));\n    }\n  };\n\nexport const createSyncChannel =\n  () => async (dispatch: dispatch, getState: getState) => {\n    const {\n      recoveryData: { aesKey },\n    } = getState();\n    const baseUrl = selectBaseUrl(getState());\n    const url = new URL(`${baseUrl}/profile`);\n    // use this for local running profile service\n    // const url = new URL(`http://10.0.2.2:3000/`);\n    const channelId = hash(aesKey);\n    console.log(`created channel ${channelId} for sync data`);\n    dispatch(setRecoveryChannel({ channelId, url }));\n    const { settings } = getState();\n    let lastSyncTime = 0;\n    if (!settings.isPrimaryDevice) {\n      await uploadDeviceInfo();\n      console.log(\n        `Finished uploading last sync time to the channel ${channelId}`,\n      );\n    } else {\n      console.log(\n        `Polling last sync time from the scanner of the channel ${channelId}`,\n      );\n      lastSyncTime = (await pollOtherSideDeviceInfo()).lastSyncTime;\n      console.log(`Last sync time was ${lastSyncTime}`);\n    }\n    const after = settings.isPrimaryDevice\n      ? lastSyncTime\n      : settings.lastSyncTime;\n    uploadAllInfoAfter(after).then(() => {\n      console.log(`Finished uploading sync data to the channel ${channelId}`);\n    });\n  };\n\nexport const getOtherSideDeviceInfo = async (): Promise<SyncDeviceInfo> => {\n  const {\n    recoveryData: {\n      channel: { url, channelId },\n    },\n  } = store.getState();\n  const channelApi = new ChannelAPI(url.href);\n  try {\n    const dataString = await channelApi.download({\n      channelId,\n      dataId: `${IMPORT_PREFIX}data`,\n      deleteAfterDownload: true,\n    });\n    return JSON.parse(dataString) as SyncDeviceInfo;\n  } catch (err) {\n    // TODO: handle real errors, like network issues etc?\n    // if other side (code generator) did not push its info, it was primary.\n    return {\n      isPrimaryDevice: true,\n    };\n  }\n};\n\nexport const pollOtherSideDeviceInfo = async (): Promise<SyncDeviceInfo> => {\n  // TODO: This is an endless loop. Needs refactoring and error handling.\n  let data = await getOtherSideDeviceInfo();\n  while (data.lastSyncTime === undefined) {\n    await new Promise((r) => setTimeout(r, CHANNEL_POLL_INTERVAL));\n    data = await getOtherSideDeviceInfo();\n  }\n  return data;\n};\n\nlet channelIntervalId: IntervalId;\nlet checkInProgress = false;\n\nexport const pollImportChannel = () => async (dispatch: dispatch) => {\n  clearInterval(channelIntervalId);\n\n  channelIntervalId = setInterval(() => {\n    if (!checkInProgress) {\n      checkInProgress = true;\n      dispatch(checkImportChannel())\n        .then(() => {\n          checkInProgress = false;\n        })\n        .catch((err) => {\n          checkInProgress = false;\n          console.error(`error polling sync/import channel: ${err.message}`);\n        });\n    }\n  }, CHANNEL_POLL_INTERVAL);\n\n  console.log(`start polling sync/import channel (${channelIntervalId})`);\n};\n\nexport const clearImportChannel = () => {\n  console.log(`stop polling sync/import channel (${channelIntervalId})`);\n  clearInterval(channelIntervalId);\n};\n\nexport const checkImportChannel =\n  () => async (dispatch: dispatch, getState: getState) => {\n    const {\n      recoveryData: {\n        channel: { channelId, url },\n      },\n      settings: { isPrimaryDevice },\n    } = getState();\n    const channelApi = new ChannelAPI(url.href);\n    const dataIds = await channelApi.list(channelId);\n    await dispatch(downloadUserInfo({ channelApi, dataIds }));\n    await dispatch(downloadConnections({ channelApi, dataIds }));\n    await dispatch(downloadGroups({ channelApi, dataIds }));\n    await dispatch(downloadContextInfo({ channelApi, dataIds }));\n    if (!isPrimaryDevice) {\n      await dispatch(downloadBlindSigs({ channelApi, dataIds }));\n    }\n    await dispatch(checkCompletedFlags({ channelApi, dataIds }));\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}