{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport any from 'promise.any';\nimport { satisfies } from 'compare-versions';\nimport { NODE_CHOOSER_TIMEOUT_MS, requiredSemVer } from \"./constants\";\nany.shim();\n\nvar chooseNode = function _callee(nodeUrls) {\n  var promises, _iterator, _step, baseUrl, winner;\n\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          promises = [];\n          promises.push(new Promise(function (resolve) {\n            setTimeout(resolve, NODE_CHOOSER_TIMEOUT_MS, 'TIMEOUT');\n          }));\n\n          for (_iterator = _createForOfIteratorHelperLoose(nodeUrls); !(_step = _iterator()).done;) {\n            baseUrl = _step.value;\n            promises.push(validateNode(baseUrl));\n          }\n\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(Promise.any(promises));\n\n        case 5:\n          winner = _context.sent;\n          return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n            if (winner === 'TIMEOUT') {\n              return reject(new Error('No node responded in time'));\n            } else {\n              console.log(\"Nodechooser: Fastest node is \" + winner + \".\");\n              return resolve(winner);\n            }\n          }));\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar validateNode = function _callee2(baseUrl) {\n  var start, validationTasks, elapsed;\n  return _regeneratorRuntime.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          start = Date.now();\n          validationTasks = [validateAPI(baseUrl, 5), validateAPI(baseUrl, 6), validateProfileService(baseUrl)];\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(Promise.all(validationTasks));\n\n        case 4:\n          elapsed = Date.now() - start;\n          console.log(\"Nodechooser: Node \" + baseUrl + \" passed all tests after \" + elapsed + \"ms\");\n          return _context2.abrupt(\"return\", baseUrl);\n\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nvar validateProfileService = function validateProfileService(baseUrl) {\n  return new Promise(function (resolve, reject) {\n    fetch(baseUrl + \"/profile/list/abc123\").then(function (response) {\n      if (!response.ok) {\n        console.log(\"Nodechooser profile service: Invalid http response from \" + baseUrl + \": \" + response.status + \" \" + response.statusText);\n        throw new Error('Profile Response not ok');\n      } else {\n        return response.json();\n      }\n    }).then(function (json) {\n      validateProfileJsonResponse(json);\n      resolve(baseUrl);\n    }).catch(function (error) {\n      console.log(\"Nodechooser: Node \" + baseUrl + \" failed with \" + error);\n      reject(error);\n    });\n  });\n};\n\nvar validateAPI = function validateAPI(baseUrl, apiVersion) {\n  return new Promise(function (resolve, reject) {\n    var stateUrl = baseUrl + \"/brightid/v\" + apiVersion + \"/state\";\n    fetch(stateUrl).then(function (response) {\n      if (!response.ok) {\n        console.log(\"Nodechooser: Invalid http response from \" + stateUrl + \": \" + response.status + \" \" + response.statusText);\n        throw new Error('Response not ok');\n      } else {\n        return response.json();\n      }\n    }).then(function (json) {\n      validateAPIJsonResponse(json, apiVersion);\n      resolve(baseUrl);\n    }).catch(function (error) {\n      console.log(\"Nodechooser: Node \" + baseUrl + \" failed v\" + apiVersion + \" test with \" + error);\n      reject(error);\n    });\n  });\n};\n\nvar expectedAPIRootKey = 'data';\nvar expectedAPIBodyKeys = {\n  5: ['lastProcessedBlock', 'verificationsBlock', 'initOp', 'sentOp', 'verificationsHashes'],\n  6: ['lastProcessedBlock', 'verificationsBlock', 'initOp', 'sentOp', 'verificationsHashes', 'wISchnorrPublic', 'ethSigningAddress', 'consensusSenderAddress', 'version']\n};\n\nvar validateAPIJsonResponse = function validateAPIJsonResponse(json, apiVersion) {\n  var body = json[expectedAPIRootKey];\n\n  if (!body) {\n    throw new Error(\"Missing rootkey \" + expectedAPIRootKey);\n  }\n\n  var keys = Object.keys(body);\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(expectedAPIBodyKeys[apiVersion]), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n\n    if (keys.indexOf(key) === -1) {\n      throw new Error(\"Missing bodykey \" + key);\n    }\n  }\n\n  if (apiVersion >= 6) {\n    if (!satisfies(body.version, requiredSemVer)) {\n      throw new Error(\"Node version \" + body.version + \" does not satisfy required version \" + requiredSemVer);\n    }\n  }\n};\n\nvar expectedProfileKey = 'profileIds';\n\nvar validateProfileJsonResponse = function validateProfileJsonResponse(json) {\n  var keys = Object.keys(json);\n\n  if (keys.indexOf(expectedProfileKey) === -1) {\n    throw new Error(\"Missing profile key \" + expectedProfileKey);\n  }\n\n  var data = json[expectedProfileKey];\n\n  if (JSON.stringify(data) !== '[]') {\n    throw new Error(\"Unexpected profile response \" + data + \" - Expected empty array\");\n  }\n\n  return true;\n};\n\nexport default chooseNode;","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/utils/nodeChooser.ts"],"names":["any","chooseNode","promises","setTimeout","baseUrl","validateNode","winner","Promise","reject","console","resolve","start","Date","validationTasks","validateAPI","validateProfileService","elapsed","fetch","response","validateProfileJsonResponse","stateUrl","validateAPIJsonResponse","expectedAPIRootKey","expectedAPIBodyKeys","body","json","keys","Object","key","apiVersion","satisfies","expectedProfileKey","data","JSON"],"mappings":"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","sourcesContent":["// Shim Promise.any() which is not yet available in react native\nimport any from 'promise.any';\nimport { satisfies } from 'compare-versions';\nimport { NODE_CHOOSER_TIMEOUT_MS, requiredSemVer } from '@/utils/constants';\n\nany.shim();\n\n/**\n * Returns a promise that\n *  -> Resolves with the baseUrl that is providing the fastest response\n *  -> Rejects if no url is providing a valid answer in time\n * @param nodeUrls String array of baseUrls\n */\nconst chooseNode = async (nodeUrls: Array<string>) => {\n  const promises: Array<Promise<string>> = [];\n\n  // add timeout promise to limit waiting time\n  promises.push(\n    new Promise((resolve) => {\n      setTimeout(resolve, NODE_CHOOSER_TIMEOUT_MS, 'TIMEOUT');\n    }),\n  );\n\n  // create validation promise for each candidate\n  for (const baseUrl of nodeUrls) {\n    promises.push(validateNode(baseUrl));\n  }\n\n  // Wait for the first promise to resolve with Promise.any()\n  // @ts-ignore: Property 'any' does not exist on type 'PromiseConstructor'\n  const winner: string = await Promise.any(promises);\n\n  return new Promise<string>((resolve, reject) => {\n    if (winner === 'TIMEOUT') {\n      // no node responded within my time limit\n      return reject(new Error('No node responded in time'));\n    } else {\n      console.log(`Nodechooser: Fastest node is ${winner}.`);\n      return resolve(winner);\n    }\n  });\n};\n\n/*\n */\nconst validateNode = async (baseUrl: string) => {\n  const start = Date.now();\n  const validationTasks = [\n    validateAPI(baseUrl, 5),\n    validateAPI(baseUrl, 6),\n    validateProfileService(baseUrl),\n  ];\n  await Promise.all(validationTasks);\n  const elapsed = Date.now() - start;\n  console.log(\n    `Nodechooser: Node ${baseUrl} passed all tests after ${elapsed}ms`,\n  );\n  return baseUrl;\n};\n\n/**\n *   Check if the provided Url points to a working BrightID profile service.\n *   Get the response from /brightid/profile/list endpoint and check\n *   if the reply makes sense.\n * @param baseUrl\n */\nconst validateProfileService = (baseUrl: string) =>\n  new Promise<string>((resolve, reject) => {\n    // fetch a random channel. Response should be an empty array\n    fetch(`${baseUrl}/profile/list/abc123`)\n      .then((response) => {\n        // network request was okay, now check server response on http level\n        if (!response.ok) {\n          console.log(\n            `Nodechooser profile service: Invalid http response from ${baseUrl}: ${response.status} ${response.statusText}`,\n          );\n          throw new Error('Profile Response not ok');\n        } else {\n          // Response is fine on http level. Now see if the content is also fine.\n          return response.json(); // will throw if response body is not JSON\n        }\n      })\n      .then((json) => {\n        // Body contains JSON. Now check if JSON content is acceptable.\n        validateProfileJsonResponse(json); // will throw if invalid\n        resolve(baseUrl);\n      })\n      .catch((error) => {\n        console.log(`Nodechooser: Node ${baseUrl} failed with ${error}`);\n        reject(error);\n      });\n  });\n\n/**\n *   Check if the provided Url points to a working BrightID node.\n *   Get the response from /brightid/v5/state endpoint and check\n *   if the reply makes sense.\n * @param baseUrl\n */\nconst validateAPI = (baseUrl: string, apiVersion: number) =>\n  new Promise<string>((resolve, reject) => {\n    const stateUrl = `${baseUrl}/brightid/v${apiVersion}/state`;\n    fetch(stateUrl)\n      .then((response) => {\n        // network request was okay, now check server response on http level\n        if (!response.ok) {\n          console.log(\n            `Nodechooser: Invalid http response from ${stateUrl}: ${response.status} ${response.statusText}`,\n          );\n          throw new Error('Response not ok');\n        } else {\n          // Response is fine on http level. Now see if the content is also fine.\n          return response.json(); // will throw if response body is not JSON\n        }\n      })\n      .then((json) => {\n        // Body contains JSON. Now check if JSON content is acceptable.\n        validateAPIJsonResponse(json, apiVersion); // will throw if invalid\n        resolve(baseUrl);\n      })\n      .catch((error) => {\n        console.log(\n          `Nodechooser: Node ${baseUrl} failed v${apiVersion} test with ${error}`,\n        );\n        reject(error);\n      });\n  });\n\n/**\n * Check if json API response contains expected content.\n *\n * Expected schema:\n * {\n *   \"data\": {\n *     \"lastProcessedBlock\": number,\n *     \"verificationsBlock\": number,\n *     \"initOp\": number,\n *     \"sentOp\": number,\n *     \"verificationsHashes\": object\n *   }\n * }\n *\n * @param json\n */\nconst expectedAPIRootKey = 'data';\nconst expectedAPIBodyKeys = {\n  5: [\n    'lastProcessedBlock',\n    'verificationsBlock',\n    'initOp',\n    'sentOp',\n    'verificationsHashes',\n  ],\n  6: [\n    'lastProcessedBlock',\n    'verificationsBlock',\n    'initOp',\n    'sentOp',\n    'verificationsHashes',\n    'wISchnorrPublic',\n    'ethSigningAddress',\n    'consensusSenderAddress',\n    'version',\n  ],\n};\n\nconst validateAPIJsonResponse = (json, apiVersion: number) => {\n  const body = json[expectedAPIRootKey];\n  if (!body) {\n    throw new Error(`Missing rootkey ${expectedAPIRootKey}`);\n  }\n  const keys = Object.keys(body);\n  for (const key of expectedAPIBodyKeys[apiVersion]) {\n    if (keys.indexOf(key) === -1) {\n      throw new Error(`Missing bodykey ${key}`);\n    }\n  }\n  if (apiVersion >= 6) {\n    // starting with v6, BrightID node state response includes a version string. Check if it satisfies client requirements\n    if (!satisfies(body.version, requiredSemVer)) {\n      throw new Error(\n        `Node version ${body.version} does not satisfy required version ${requiredSemVer}`,\n      );\n    }\n  }\n};\n\n/**\n * Check if json profile server response contains expected content.\n *\n * Expected schema:\n * {\n *   \"profileIds\": []\n * }\n *\n * @param json\n */\n\nconst expectedProfileKey = 'profileIds';\nconst validateProfileJsonResponse = (json) => {\n  const keys = Object.keys(json);\n  if (keys.indexOf(expectedProfileKey) === -1) {\n    throw new Error(`Missing profile key ${expectedProfileKey}`);\n  }\n  const data = json[expectedProfileKey];\n  if (JSON.stringify(data) !== '[]') {\n    throw new Error(\n      `Unexpected profile response ${data} - Expected empty array`,\n    );\n  }\n  return true;\n};\n\nexport default chooseNode;\n"]},"metadata":{},"sourceType":"module"}