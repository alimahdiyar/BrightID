{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _ from 'lodash';\nimport CryptoJS from 'crypto-js';\nimport nacl from 'tweetnacl';\nimport stringify from 'fast-json-stable-stringify';\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport { store } from \"../store\";\nimport { setApps, upsertSig, removeSig, updateSig, selectAllSigs, selectExpireableBlindSigApps } from \"../reducer/appsSlice\";\nimport { hash, strToUint8Array, uInt8ArrayToB64 } from \"../utils/encoding\";\nimport { NodeApi } from \"../api/brightId\";\nimport { isVerified } from \"../utils/verifications\";\nimport backupApi from \"../api/backupService\";\nimport { CACHED_PARAMS_NOT_FOUND } from \"../api/brightidError\";\nimport { BrightIdNetwork } from \"../components/Apps/types.d\";\n\nvar WISchnorrClient = require(\"../utils/WISchnorrClient\");\n\nexport var updateBlindSig = function updateBlindSig(app) {\n  return function _callee2(dispatch, getState) {\n    var _getState, _getState$user, verifications, id, secretKey, sigs, verificationsByName, vel, roundedTimestamp, _loop, _iterator, _step, verification, _ret;\n\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _getState = getState(), _getState$user = _getState.user, verifications = _getState$user.verifications, id = _getState$user.id, secretKey = _getState.keypair.secretKey;\n            sigs = selectAllSigs(getState());\n            verificationsByName = _.keyBy(verifications, function (v) {\n              return v.name;\n            });\n            vel = app.verificationExpirationLength;\n            roundedTimestamp = vel ? Math.floor(Date.now() / vel) * vel : 0;\n\n            _loop = function _callee(verification) {\n              var sigInfo, network, url, api, info, _await$api$getState, wISchnorrPublic, client, pub, uid, challenge, s, sig, response, blindSig, backupData, backupKey;\n\n              return _regeneratorRuntime.async(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      sigInfo = sigs.find(function (sig) {\n                        return sig.app === app.id && sig.verification === verification && sig.roundedTimestamp === roundedTimestamp;\n                      });\n\n                      if (!(sigInfo && sigInfo.sig)) {\n                        _context.next = 4;\n                        break;\n                      }\n\n                      console.log(\"sig exists for \" + app.name + \" (\" + verification + \")\");\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 4:\n                      if (isVerified(verificationsByName, verification)) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      console.log(\"user is not verified for \" + app.name + \" (\" + verification + \")\");\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 7:\n                      _context.prev = 7;\n                      network = __DEV__ ? BrightIdNetwork.TEST : BrightIdNetwork.NODE;\n                      url = app.nodeUrl || \"http://\" + network + \".brightid.org\";\n                      api = new NodeApi({\n                        url: url,\n                        id: id,\n                        secretKey: secretKey\n                      });\n                      info = stringify({\n                        app: app.id,\n                        roundedTimestamp: roundedTimestamp,\n                        verification: verification\n                      });\n                      console.log(info, 'info');\n                      _context.next = 15;\n                      return _regeneratorRuntime.awrap(api.getState());\n\n                    case 15:\n                      _await$api$getState = _context.sent;\n                      wISchnorrPublic = _await$api$getState.wISchnorrPublic;\n\n                      if (wISchnorrPublic) {\n                        _context.next = 20;\n                        break;\n                      }\n\n                      console.log('wISchnorrPublic is not set');\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 20:\n                      client = new WISchnorrClient(wISchnorrPublic);\n\n                      if (sigInfo) {\n                        _context.next = 33;\n                        break;\n                      }\n\n                      _context.next = 24;\n                      return _regeneratorRuntime.awrap(api.getPublic(app.id, roundedTimestamp, verification));\n\n                    case 24:\n                      pub = _context.sent;\n                      uid = CryptoJS.enc.Base64.stringify(CryptoJS.lib.WordArray.random(16));\n                      console.log(\"using \" + uid + \" for \" + app.name + \" (\" + verification + \") as uid\");\n                      challenge = client.GenerateWISchnorrClientChallenge(pub, info, uid);\n                      console.log(challenge, 'challenge');\n                      sigInfo = {\n                        uid: uid,\n                        app: app.id,\n                        roundedTimestamp: roundedTimestamp,\n                        verification: verification,\n                        pub: pub,\n                        challenge: challenge,\n                        linked: false,\n                        linkedTimestamp: 0,\n                        signedTimestamp: Date.now()\n                      };\n                      dispatch(upsertSig(sigInfo));\n                      _context.next = 34;\n                      break;\n\n                    case 33:\n                      if (sigInfo && !sigInfo.sig) {\n                        pub = sigInfo.pub;\n                        uid = sigInfo.uid;\n                        challenge = sigInfo.challenge;\n                      }\n\n                    case 34:\n                      s = stringify({\n                        id: id,\n                        public: pub\n                      });\n                      sig = uInt8ArrayToB64(nacl.sign.detached(strToUint8Array(s), secretKey));\n                      _context.next = 38;\n                      return _regeneratorRuntime.awrap(api.getBlindedSig(stringify(pub), sig, challenge.e));\n\n                    case 38:\n                      response = _context.sent;\n                      console.log(response, 'response');\n                      blindSig = client.GenerateWISchnorrBlindSignature(challenge.t, response);\n                      console.log('final sig', blindSig);\n\n                      if (client.VerifyWISchnorrBlindSignature(blindSig, info, uid)) {\n                        _context.next = 45;\n                        break;\n                      }\n\n                      console.log(\"wrong signature for \" + app.name + \" (\" + verification + \")!\");\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 45:\n                      backupData = stringify(_objectSpread(_objectSpread({}, sigInfo), {}, {\n                        sig: blindSig\n                      }));\n                      backupKey = hash(app.id + \" \" + verification + \" \" + roundedTimestamp);\n                      _context.next = 49;\n                      return _regeneratorRuntime.awrap(encryptAndBackup(backupKey, backupData));\n\n                    case 49:\n                      dispatch(updateSig({\n                        id: uid,\n                        changes: {\n                          sig: blindSig\n                        }\n                      }));\n                      _context.next = 60;\n                      break;\n\n                    case 52:\n                      _context.prev = 52;\n                      _context.t0 = _context[\"catch\"](7);\n                      console.log(\"error in getting sig for \" + app.name + \" (\" + verification + \")\", _context.t0);\n\n                      if (!(_context.t0.errorNum === CACHED_PARAMS_NOT_FOUND && sigInfo && sigInfo.uid)) {\n                        _context.next = 60;\n                        break;\n                      }\n\n                      console.log('removing sig and retrying');\n                      dispatch(removeSig(sigInfo.uid));\n                      _context.next = 60;\n                      return _regeneratorRuntime.awrap(dispatch(updateBlindSig(app)));\n\n                    case 60:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, null, null, [[7, 52]], Promise);\n            };\n\n            _iterator = _createForOfIteratorHelperLoose(app.verifications);\n\n          case 7:\n            if ((_step = _iterator()).done) {\n              _context2.next = 16;\n              break;\n            }\n\n            verification = _step.value;\n            _context2.next = 11;\n            return _regeneratorRuntime.awrap(_loop(verification));\n\n          case 11:\n            _ret = _context2.sent;\n\n            if (!(_ret === \"continue\")) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 14);\n\n          case 14:\n            _context2.next = 7;\n            break;\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var updateBlindSigs = function updateBlindSigs() {\n  return function _callee4(dispatch, getState) {\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", new Promise(function () {\n              InteractionManager.runAfterInteractions(function _callee3() {\n                var expireableBlindSigApps, _iterator2, _step2, app;\n\n                return _regeneratorRuntime.async(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        expireableBlindSigApps = selectExpireableBlindSigApps(getState());\n                        _iterator2 = _createForOfIteratorHelperLoose(expireableBlindSigApps);\n\n                      case 2:\n                        if ((_step2 = _iterator2()).done) {\n                          _context3.next = 8;\n                          break;\n                        }\n\n                        app = _step2.value;\n                        _context3.next = 6;\n                        return _regeneratorRuntime.awrap(dispatch(updateBlindSig(app)));\n\n                      case 6:\n                        _context3.next = 2;\n                        break;\n\n                      case 8:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, null, null, null, Promise);\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nvar encryptAndBackup = function _callee5(key, data) {\n  var _store$getState, _store$getState$user, id, password, hashedId, encrypted;\n\n  return _regeneratorRuntime.async(function _callee5$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _store$getState = store.getState(), _store$getState$user = _store$getState.user, id = _store$getState$user.id, password = _store$getState$user.password;\n          hashedId = hash(id + password);\n          _context5.prev = 2;\n          encrypted = CryptoJS.AES.encrypt(data, password).toString();\n          _context5.next = 6;\n          return _regeneratorRuntime.awrap(backupApi.putRecovery(hashedId, key, encrypted));\n\n        case 6:\n          _context5.next = 11;\n          break;\n\n        case 8:\n          _context5.prev = 8;\n          _context5.t0 = _context5[\"catch\"](2);\n          _context5.t0 instanceof Error ? console.warn(_context5.t0.message) : console.warn(_context5.t0);\n\n        case 11:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, [[2, 8]], Promise);\n};\n\nexport var fetchApps = function fetchApps(api) {\n  return function _callee6(dispatch, _) {\n    var apps;\n    return _regeneratorRuntime.async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _context6.next = 3;\n            return _regeneratorRuntime.awrap(api.getApps());\n\n          case 3:\n            apps = _context6.sent;\n            _context6.next = 6;\n            return _regeneratorRuntime.awrap(dispatch(setApps(apps)));\n\n          case 6:\n            _context6.next = 11;\n            break;\n\n          case 8:\n            _context6.prev = 8;\n            _context6.t0 = _context6[\"catch\"](0);\n            console.log(_context6.t0);\n\n          case 11:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, [[0, 8]], Promise);\n  };\n};","map":{"version":3,"names":["_","CryptoJS","nacl","stringify","store","setApps","upsertSig","removeSig","updateSig","selectAllSigs","selectExpireableBlindSigApps","hash","strToUint8Array","uInt8ArrayToB64","NodeApi","isVerified","backupApi","CACHED_PARAMS_NOT_FOUND","BrightIdNetwork","WISchnorrClient","require","updateBlindSig","app","dispatch","getState","user","verifications","id","secretKey","keypair","sigs","verificationsByName","keyBy","v","name","vel","verificationExpirationLength","roundedTimestamp","Math","floor","Date","now","verification","sigInfo","find","sig","console","log","network","__DEV__","TEST","NODE","url","nodeUrl","api","info","wISchnorrPublic","client","getPublic","pub","uid","enc","Base64","lib","WordArray","random","challenge","GenerateWISchnorrClientChallenge","linked","linkedTimestamp","signedTimestamp","s","public","sign","detached","getBlindedSig","e","response","blindSig","GenerateWISchnorrBlindSignature","t","VerifyWISchnorrBlindSignature","backupData","backupKey","encryptAndBackup","changes","errorNum","updateBlindSigs","Promise","InteractionManager","runAfterInteractions","expireableBlindSigApps","key","data","password","hashedId","encrypted","AES","encrypt","toString","putRecovery","Error","warn","message","fetchApps","getApps","apps"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/actions/apps.ts"],"sourcesContent":["import _ from 'lodash';\nimport CryptoJS from 'crypto-js';\nimport nacl from 'tweetnacl';\nimport stringify from 'fast-json-stable-stringify';\nimport { InteractionManager } from 'react-native';\nimport { store } from '@/store';\nimport {\n  setApps,\n  upsertSig,\n  removeSig,\n  updateSig,\n  selectAllSigs,\n  selectExpireableBlindSigApps,\n} from '@/reducer/appsSlice';\nimport { hash, strToUint8Array, uInt8ArrayToB64 } from '@/utils/encoding';\nimport { NodeApi } from '@/api/brightId';\nimport { isVerified } from '@/utils/verifications';\nimport backupApi from '@/api/backupService';\nimport { CACHED_PARAMS_NOT_FOUND } from '@/api/brightidError';\nimport { BrightIdNetwork } from '@/components/Apps/types.d';\n\nconst WISchnorrClient = require('@/utils/WISchnorrClient');\n\nexport const updateBlindSig =\n  (app) => async (dispatch: dispatch, getState: GetState) => {\n    const {\n      user: { verifications, id },\n      keypair: { secretKey },\n    } = getState();\n    const sigs = selectAllSigs(getState());\n    const verificationsByName = _.keyBy(verifications, (v) => v.name);\n    const vel = app.verificationExpirationLength;\n    const roundedTimestamp = vel ? Math.floor(Date.now() / vel) * vel : 0;\n    for (const verification of app.verifications) {\n      let sigInfo = sigs.find(\n        (sig) =>\n          sig.app === app.id &&\n          sig.verification === verification &&\n          sig.roundedTimestamp === roundedTimestamp,\n      );\n      if (sigInfo && sigInfo.sig) {\n        console.log(`sig exists for ${app.name} (${verification})`);\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (!isVerified(verificationsByName, verification)) {\n        console.log(`user is not verified for ${app.name} (${verification})`);\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      try {\n        const network = __DEV__ ? BrightIdNetwork.TEST : BrightIdNetwork.NODE;\n        // TODO: Don't fallback to node.brightid.org. 'app.nodeUrl' should be mandatory.\n        // noinspection HttpUrlsUsage\n        const url = app.nodeUrl || `http://${network}.brightid.org`;\n        const api = new NodeApi({ url, id, secretKey });\n        const info = stringify({\n          app: app.id,\n          roundedTimestamp,\n          verification,\n        });\n        console.log(info, 'info');\n        const { wISchnorrPublic } = await api.getState();\n        if (!wISchnorrPublic) {\n          console.log('wISchnorrPublic is not set');\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        const client = new WISchnorrClient(wISchnorrPublic);\n        let pub, uid: string;\n        let challenge: WISchnorrChallenge;\n        if (!sigInfo) {\n          pub = await api.getPublic(app.id, roundedTimestamp, verification);\n          uid = CryptoJS.enc.Base64.stringify(\n            CryptoJS.lib.WordArray.random(16),\n          );\n          console.log(`using ${uid} for ${app.name} (${verification}) as uid`);\n          challenge = client.GenerateWISchnorrClientChallenge(pub, info, uid);\n          console.log(challenge, 'challenge');\n          // store sig info before getting sig to be able to receive sig from server again\n          // if app stopped just after querying the one time sig from the server\n          sigInfo = {\n            uid,\n            app: app.id,\n            roundedTimestamp,\n            verification,\n            pub,\n            challenge,\n            linked: false,\n            linkedTimestamp: 0,\n            signedTimestamp: Date.now(),\n          };\n          dispatch(upsertSig(sigInfo));\n        } else if (sigInfo && !sigInfo.sig) {\n          pub = sigInfo.pub;\n          uid = sigInfo.uid;\n          challenge = sigInfo.challenge;\n        }\n\n        const s = stringify({ id, public: pub });\n        const sig = uInt8ArrayToB64(\n          nacl.sign.detached(strToUint8Array(s), secretKey),\n        );\n\n        const response = await api.getBlindedSig(\n          stringify(pub),\n          sig,\n          challenge.e,\n        );\n        console.log(response, 'response');\n        const blindSig = client.GenerateWISchnorrBlindSignature(\n          challenge.t,\n          response,\n        );\n        console.log('final sig', blindSig);\n        if (!client.VerifyWISchnorrBlindSignature(blindSig, info, uid)) {\n          console.log(`wrong signature for ${app.name} (${verification})!`);\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        const backupData = stringify({ ...sigInfo, sig: blindSig });\n        const backupKey = hash(`${app.id} ${verification} ${roundedTimestamp}`);\n        await encryptAndBackup(backupKey, backupData);\n\n        dispatch(\n          updateSig({\n            id: uid,\n            changes: { sig: blindSig },\n          }),\n        );\n      } catch (err) {\n        console.log(\n          `error in getting sig for ${app.name} (${verification})`,\n          err,\n        );\n        if (\n          err.errorNum === CACHED_PARAMS_NOT_FOUND &&\n          sigInfo &&\n          sigInfo.uid\n        ) {\n          console.log('removing sig and retrying');\n          dispatch(removeSig(sigInfo.uid));\n          await dispatch(updateBlindSig(app));\n        }\n      }\n    }\n  };\n\nexport const updateBlindSigs =\n  () => async (dispatch: dispatch, getState: GetState) => {\n    return new Promise(() => {\n      InteractionManager.runAfterInteractions(async () => {\n        const expireableBlindSigApps = selectExpireableBlindSigApps(getState());\n        for (const app of expireableBlindSigApps) {\n          await dispatch(updateBlindSig(app));\n        }\n      });\n    });\n  };\n\nconst encryptAndBackup = async (key: string, data: string) => {\n  const {\n    user: { id, password },\n  } = store.getState();\n  const hashedId = hash(id + password);\n  try {\n    const encrypted = CryptoJS.AES.encrypt(data, password).toString();\n    await backupApi.putRecovery(hashedId, key, encrypted);\n  } catch (err) {\n    err instanceof Error ? console.warn(err.message) : console.warn(err);\n  }\n};\n\nexport const fetchApps = (api) => async (dispatch: dispatch, _) => {\n  try {\n    const apps = await api.getApps();\n    await dispatch(setApps(apps));\n  } catch (err) {\n    console.log(err);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}