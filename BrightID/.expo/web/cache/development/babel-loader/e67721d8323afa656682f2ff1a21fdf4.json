{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { create } from 'apisauce';\nimport { CHANNEL_UPLOAD_RETRY_COUNT, CHANNEL_UPLOAD_RETRY_INTERVAL } from \"../utils/constants\";\n\nvar ChannelAPI = function () {\n  function ChannelAPI(baseURL) {\n    _classCallCheck(this, ChannelAPI);\n\n    this.api = create({\n      baseURL: baseURL,\n      headers: {\n        'Cache-Control': 'no-cache'\n      }\n    });\n  }\n\n  _createClass(ChannelAPI, [{\n    key: \"upload\",\n    value: function upload(params) {\n      var _this = this;\n\n      var channelId, data, dataId, requestedTtl, requestedTtlSecs, body, retries, result, _loop;\n\n      return _regeneratorRuntime.async(function upload$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              channelId = params.channelId, data = params.data, dataId = params.dataId, requestedTtl = params.requestedTtl;\n              requestedTtlSecs = requestedTtl ? Math.floor(requestedTtl / 1000) : undefined;\n              body = JSON.stringify({\n                data: data,\n                uuid: dataId,\n                requestedTtl: requestedTtlSecs\n              });\n              retries = 0;\n              _context2.next = 6;\n              return _regeneratorRuntime.awrap(this.api.post(\"/upload/\" + channelId, body));\n\n            case 6:\n              result = _context2.sent;\n\n              _loop = function _callee() {\n                var retryDelay;\n                return _regeneratorRuntime.async(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        retries++;\n                        retryDelay = CHANNEL_UPLOAD_RETRY_INTERVAL * retries;\n                        console.log(\"Uploading \" + dataId + \" to \" + channelId + \" failed with status \" + result.status + \" at try \" + (retries - 1) + \". Retrying in \" + retryDelay + \"ms.\");\n                        _context.next = 5;\n                        return _regeneratorRuntime.awrap(new Promise(function (r) {\n                          return setTimeout(r, retryDelay);\n                        }));\n\n                      case 5:\n                        _context.next = 7;\n                        return _regeneratorRuntime.awrap(_this.api.post(\"/upload/\" + channelId, body));\n\n                      case 7:\n                        result = _context.sent;\n\n                      case 8:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, null, null, null, Promise);\n              };\n\n            case 8:\n              if (!(!result.ok && retries < CHANNEL_UPLOAD_RETRY_COUNT)) {\n                _context2.next = 13;\n                break;\n              }\n\n              _context2.next = 11;\n              return _regeneratorRuntime.awrap(_loop());\n\n            case 11:\n              _context2.next = 8;\n              break;\n\n            case 13:\n              ChannelAPI.throwOnError(result);\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"list\",\n    value: function list(channelId) {\n      var result;\n      return _regeneratorRuntime.async(function list$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _regeneratorRuntime.awrap(this.api.get(\"/list/\" + channelId));\n\n            case 2:\n              result = _context3.sent;\n              ChannelAPI.throwOnError(result);\n\n              if (!(result.data && result.data.profileIds)) {\n                _context3.next = 8;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", result.data.profileIds);\n\n            case 8:\n              throw new Error(\"list for channel \" + channelId + \": Unexpected response format\");\n\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"download\",\n    value: function download(params) {\n      var channelId, dataId, deleteAfterDownload, result;\n      return _regeneratorRuntime.async(function download$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              channelId = params.channelId, dataId = params.dataId, deleteAfterDownload = params.deleteAfterDownload;\n              _context4.next = 3;\n              return _regeneratorRuntime.awrap(this.api.get(\"/download/\" + channelId + \"/\" + dataId));\n\n            case 3:\n              result = _context4.sent;\n              ChannelAPI.throwOnError(result);\n\n              if (!deleteAfterDownload) {\n                _context4.next = 14;\n                break;\n              }\n\n              _context4.prev = 6;\n              _context4.next = 9;\n              return _regeneratorRuntime.awrap(this.api.delete(\"/\" + channelId + \"/\" + dataId));\n\n            case 9:\n              _context4.next = 14;\n              break;\n\n            case 11:\n              _context4.prev = 11;\n              _context4.t0 = _context4[\"catch\"](6);\n              console.log(\"Ignoring error while deleting \" + dataId + \" from channel \" + channelId + \": \" + _context4.t0);\n\n            case 14:\n              if (!(result.data && result.data.data)) {\n                _context4.next = 18;\n                break;\n              }\n\n              return _context4.abrupt(\"return\", result.data.data);\n\n            case 18:\n              throw new Error(\"download \" + dataId + \" from channel \" + channelId + \": Unexpected response format\");\n\n            case 19:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, [[6, 11]], Promise);\n    }\n  }], [{\n    key: \"throwOnError\",\n    value: function throwOnError(response) {\n      if (response.ok) {\n        return;\n      }\n\n      if (response.data && response.data.error) {\n        throw new Error(response.data.error);\n      }\n\n      throw new Error(response.problem);\n    }\n  }]);\n\n  return ChannelAPI;\n}();\n\nexport default ChannelAPI;","map":{"version":3,"names":["create","CHANNEL_UPLOAD_RETRY_COUNT","CHANNEL_UPLOAD_RETRY_INTERVAL","ChannelAPI","baseURL","api","headers","params","channelId","data","dataId","requestedTtl","requestedTtlSecs","Math","floor","undefined","body","JSON","stringify","uuid","retries","post","result","retryDelay","console","log","status","Promise","r","setTimeout","ok","throwOnError","get","profileIds","Error","deleteAfterDownload","delete","response","error","problem"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/api/channelService.ts"],"sourcesContent":["/*\n    Channel Service API\n\n    Operations:\n\n    - Upload data with unique ID to channel\n        -> POST /profile/upload/${channelID}\n    - Get list of data IDs in channel\n        -> GET /profile/list/${channelID}\n    - Download data from channel\n        -> GET /profile/download/${channelID}/${dataID}\n\n    We need to support multiple different hosts, so\n    we can not use a global API instance. Instead it needs to be created per channel.\n */\nimport { create, ApisauceInstance, ApiResponse } from 'apisauce';\nimport {\n  CHANNEL_UPLOAD_RETRY_COUNT,\n  CHANNEL_UPLOAD_RETRY_INTERVAL,\n} from '@/utils/constants';\n\ntype UploadParams = {\n  channelId: string;\n  data: any;\n  dataId: string;\n  // Use requestedTtl to override default channel TTL on the backend. Only taken into account when\n  // creating a channel (upload of first entry).\n  requestedTtl?: number;\n};\n\ntype DownloadParams = {\n  channelId: string;\n  dataId: string;\n  deleteAfterDownload?: boolean;\n};\n\nclass ChannelAPI {\n  api: ApisauceInstance;\n\n  constructor(baseURL: string) {\n    this.api = create({\n      baseURL,\n      headers: { 'Cache-Control': 'no-cache' },\n    });\n  }\n\n  static throwOnError(response: ApiResponse<any>) {\n    if (response.ok) {\n      return;\n    }\n    if (response.data && response.data.error) {\n      throw new Error(response.data.error);\n    }\n    throw new Error(response.problem);\n  }\n\n  async upload(params: UploadParams) {\n    const { channelId, data, dataId, requestedTtl } = params;\n\n    // convert TTL from ms to seconds\n    const requestedTtlSecs = requestedTtl\n      ? Math.floor(requestedTtl / 1000)\n      : undefined;\n\n    const body = JSON.stringify({\n      data,\n      uuid: dataId,\n      requestedTtl: requestedTtlSecs,\n    });\n\n    let retries = 0;\n    let result = await this.api.post(`/upload/${channelId}`, body);\n\n    // Upload failed. Wait to try again with increasing delay, give up after max attempts\n    while (!result.ok && retries < CHANNEL_UPLOAD_RETRY_COUNT) {\n      retries++;\n      const retryDelay = CHANNEL_UPLOAD_RETRY_INTERVAL * retries;\n      console.log(\n        `Uploading ${dataId} to ${channelId} failed with status ${\n          result.status\n        } at try ${retries - 1}. Retrying in ${retryDelay}ms.`,\n      );\n      await new Promise((r) => setTimeout(r, retryDelay));\n      result = await this.api.post(`/upload/${channelId}`, body);\n    }\n\n    ChannelAPI.throwOnError(result);\n  }\n\n  async list(channelId: string) {\n    const result = await this.api.get<{ profileIds: string[] }>(\n      `/list/${channelId}`,\n    );\n    ChannelAPI.throwOnError(result);\n    if (result.data && result.data.profileIds) {\n      return result.data.profileIds;\n    } else {\n      throw new Error(\n        `list for channel ${channelId}: Unexpected response format`,\n      );\n    }\n  }\n\n  async download(params: DownloadParams) {\n    const { channelId, dataId, deleteAfterDownload } = params;\n    const result = await this.api.get<{ data: any }>(\n      `/download/${channelId}/${dataId}`,\n    );\n    ChannelAPI.throwOnError(result);\n    if (deleteAfterDownload) {\n      try {\n        await this.api.delete(`/${channelId}/${dataId}`);\n      } catch (e) {\n        console.log(\n          `Ignoring error while deleting ${dataId} from channel ${channelId}: ${e}`,\n        );\n      }\n    }\n    if (result.data && result.data.data) {\n      return result.data.data;\n    } else {\n      throw new Error(\n        `download ${dataId} from channel ${channelId}: Unexpected response format`,\n      );\n    }\n  }\n}\n\nexport default ChannelAPI;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}