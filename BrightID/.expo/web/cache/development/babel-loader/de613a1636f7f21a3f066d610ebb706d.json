{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _ from 'lodash';\nimport nacl from 'tweetnacl';\nimport stringify from 'fast-json-stable-stringify';\nimport { b64ToUrlSafeB64, strToUint8Array, uInt8ArrayToB64, hash } from \"../../../../utils/encoding\";\nimport { selectAllConnections } from \"../../../../reducer/connectionsSlice\";\nimport { store } from \"../../../../store\";\nimport { loadRecoveryData } from \"../../../../utils/recovery\";\nimport { uploadConnection, uploadGroup } from \"../../../../utils/channels\";\nexport var uploadSig = function uploadSig(_ref) {\n  var id = _ref.id,\n      aesKey = _ref.aesKey,\n      channelApi = _ref.channelApi;\n  return function _callee(_, getState) {\n    var _getState, secretKey, signer, _await$loadRecoveryDa, signingKey, timestamp, op, message, sig, data;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _getState = getState(), secretKey = _getState.keypair.secretKey, signer = _getState.user.id;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(loadRecoveryData(channelApi, aesKey));\n\n          case 3:\n            _await$loadRecoveryDa = _context.sent;\n            signingKey = _await$loadRecoveryDa.signingKey;\n            timestamp = _await$loadRecoveryDa.timestamp;\n            op = {\n              name: 'Social Recovery',\n              id: id,\n              signingKey: signingKey,\n              timestamp: timestamp,\n              v: 6\n            };\n            message = stringify(op);\n            sig = uInt8ArrayToB64(nacl.sign.detached(strToUint8Array(message), secretKey));\n            data = {\n              signer: signer,\n              id: id,\n              sig: sig\n            };\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(channelApi.upload({\n              channelId: hash(aesKey),\n              dataId: \"sig_\" + signer,\n              data: data\n            }));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var uploadMutualInfo = function _callee2(_ref2) {\n  var conn, aesKey, channelApi, nodeApi, _store$getState, signingKey, groups, user, dataIds, connections, connectionsById, groupsById, otherSideConnections, knownLevels, mutualConnections, otherSideGroups, mutualGroups, _iterator, _step, c, _iterator2, _step2, g;\n\n  return _regeneratorRuntime.async(function _callee2$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          conn = _ref2.conn, aesKey = _ref2.aesKey, channelApi = _ref2.channelApi, nodeApi = _ref2.nodeApi;\n          _store$getState = store.getState(), signingKey = _store$getState.keypair.publicKey, groups = _store$getState.groups.groups, user = _store$getState.user;\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(channelApi.list(hash(aesKey)));\n\n        case 4:\n          dataIds = _context2.sent;\n\n          if (dataIds.includes(\"connection_\" + conn.id + \":\" + b64ToUrlSafeB64(signingKey))) {\n            _context2.next = 9;\n            break;\n          }\n\n          console.log(\"uploading recovery data for connection\");\n          _context2.next = 9;\n          return _regeneratorRuntime.awrap(uploadConnection({\n            conn: conn,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 9:\n          connections = selectAllConnections(store.getState());\n          connectionsById = _.keyBy(connections, 'id');\n          groupsById = _.keyBy(groups, 'id');\n          _context2.next = 14;\n          return _regeneratorRuntime.awrap(nodeApi.getConnections(conn.id, 'inbound'));\n\n        case 14:\n          otherSideConnections = _context2.sent;\n          knownLevels = ['just met', 'already known', 'recovery'];\n          mutualConnections = otherSideConnections ? otherSideConnections.filter(function (c) {\n            return connectionsById[c.id] && connectionsById[c.id].name && knownLevels.includes(c.level) && !dataIds.includes(\"connection_\" + c.id + \":\" + b64ToUrlSafeB64(signingKey));\n          }).map(function (c) {\n            return connectionsById[c.id];\n          }) : [];\n\n          if (!dataIds.includes(\"connection_\" + user.id + \":\" + b64ToUrlSafeB64(signingKey))) {\n            mutualConnections.push(user);\n          }\n\n          _context2.next = 20;\n          return _regeneratorRuntime.awrap(nodeApi.getMemberships(conn.id));\n\n        case 20:\n          otherSideGroups = _context2.sent;\n          mutualGroups = otherSideGroups ? otherSideGroups.filter(function (g) {\n            return groupsById[g.id];\n          }).map(function (g) {\n            return groupsById[g.id];\n          }) : [];\n          console.log('uploading mutual connections');\n          _iterator = _createForOfIteratorHelperLoose(mutualConnections);\n\n        case 24:\n          if ((_step = _iterator()).done) {\n            _context2.next = 30;\n            break;\n          }\n\n          c = _step.value;\n          _context2.next = 28;\n          return _regeneratorRuntime.awrap(uploadConnection({\n            conn: c,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 28:\n          _context2.next = 24;\n          break;\n\n        case 30:\n          console.log('uploading mutual groups');\n          _iterator2 = _createForOfIteratorHelperLoose(mutualGroups);\n\n        case 32:\n          if ((_step2 = _iterator2()).done) {\n            _context2.next = 38;\n            break;\n          }\n\n          g = _step2.value;\n          _context2.next = 36;\n          return _regeneratorRuntime.awrap(uploadGroup({\n            group: g,\n            channelApi: channelApi,\n            aesKey: aesKey,\n            signingKey: signingKey\n          }));\n\n        case 36:\n          _context2.next = 32;\n          break;\n\n        case 38:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"names":["_","nacl","stringify","b64ToUrlSafeB64","strToUint8Array","uInt8ArrayToB64","hash","selectAllConnections","store","loadRecoveryData","uploadConnection","uploadGroup","uploadSig","id","aesKey","channelApi","getState","secretKey","keypair","signer","user","signingKey","timestamp","op","name","v","message","sig","sign","detached","data","upload","channelId","dataId","uploadMutualInfo","conn","nodeApi","publicKey","groups","list","dataIds","includes","console","log","connections","connectionsById","keyBy","groupsById","getConnections","otherSideConnections","knownLevels","mutualConnections","filter","c","level","map","push","getMemberships","otherSideGroups","mutualGroups","g","group"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/channelUploadThunks.ts"],"sourcesContent":["import _ from 'lodash';\nimport nacl from 'tweetnacl';\nimport stringify from 'fast-json-stable-stringify';\nimport {\n  b64ToUrlSafeB64,\n  strToUint8Array,\n  uInt8ArrayToB64,\n  hash,\n} from '@/utils/encoding';\nimport { selectAllConnections } from '@/reducer/connectionsSlice';\nimport ChannelAPI from '@/api/channelService';\nimport { NodeApi } from '@/api/brightId';\nimport { store } from '@/store';\nimport { loadRecoveryData } from '@/utils/recovery';\nimport { uploadConnection, uploadGroup } from '@/utils/channels';\n\nexport const uploadSig =\n  ({\n    id,\n    aesKey,\n    channelApi,\n  }: {\n    id: string;\n    aesKey: string;\n    channelApi: ChannelAPI;\n  }) =>\n  async (_, getState) => {\n    const {\n      keypair: { secretKey },\n      user: { id: signer },\n    } = getState();\n\n    const { signingKey, timestamp } = await loadRecoveryData(\n      channelApi,\n      aesKey,\n    );\n\n    const op = {\n      name: 'Social Recovery',\n      id,\n      signingKey,\n      timestamp,\n      v: 6,\n    };\n    const message = stringify(op);\n    const sig = uInt8ArrayToB64(\n      nacl.sign.detached(strToUint8Array(message), secretKey),\n    );\n\n    const data = { signer, id, sig };\n\n    await channelApi.upload({\n      channelId: hash(aesKey),\n      dataId: `sig_${signer}`,\n      data,\n    });\n  };\n\nexport const uploadMutualInfo = async ({\n  conn,\n  aesKey,\n  channelApi,\n  nodeApi,\n}: {\n  conn: Connection;\n  aesKey: string;\n  channelApi: ChannelAPI;\n  nodeApi: NodeApi;\n}) => {\n  const {\n    keypair: { publicKey: signingKey },\n    groups: { groups },\n    user,\n  } = store.getState();\n  const dataIds = await channelApi.list(hash(aesKey));\n  if (\n    !dataIds.includes(`connection_${conn.id}:${b64ToUrlSafeB64(signingKey)}`)\n  ) {\n    console.log(`uploading recovery data for connection`);\n    await uploadConnection({\n      conn,\n      channelApi,\n      aesKey,\n      signingKey,\n    });\n  }\n  const connections = selectAllConnections(store.getState());\n\n  const connectionsById = _.keyBy(connections, 'id');\n  const groupsById = _.keyBy(groups, 'id');\n\n  const otherSideConnections = await nodeApi.getConnections(conn.id, 'inbound');\n  const knownLevels = ['just met', 'already known', 'recovery'];\n  const mutualConnections = otherSideConnections\n    ? otherSideConnections\n        .filter(\n          (c) =>\n            connectionsById[c.id] &&\n            connectionsById[c.id].name &&\n            knownLevels.includes(c.level) &&\n            !dataIds.includes(\n              `connection_${c.id}:${b64ToUrlSafeB64(signingKey)}`,\n            ),\n        )\n        .map((c) => connectionsById[c.id])\n    : [];\n\n  if (\n    !dataIds.includes(`connection_${user.id}:${b64ToUrlSafeB64(signingKey)}`)\n  ) {\n    mutualConnections.push(user);\n  }\n\n  const otherSideGroups = await nodeApi.getMemberships(conn.id);\n  const mutualGroups = otherSideGroups\n    ? otherSideGroups\n        .filter((g) => groupsById[g.id])\n        .map((g) => groupsById[g.id])\n    : [];\n\n  console.log('uploading mutual connections');\n  for (const c of mutualConnections) {\n    await uploadConnection({\n      conn: c,\n      channelApi,\n      aesKey,\n      signingKey,\n    });\n  }\n  console.log('uploading mutual groups');\n  for (const g of mutualGroups) {\n    await uploadGroup({ group: g, channelApi, aesKey, signingKey });\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}