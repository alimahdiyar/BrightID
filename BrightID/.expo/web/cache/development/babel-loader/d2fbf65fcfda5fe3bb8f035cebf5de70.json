{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.downloadSigs = exports.downloadNamePhoto = exports.downloadGroups = exports.downloadConnections = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _filesystem = require(\"../../../../utils/filesystem\");\n\nvar _cryptoHelper = require(\"../../../../utils/cryptoHelper\");\n\nvar _encoding = require(\"../../../../utils/encoding\");\n\nvar _actions = require(\"../../../../actions\");\n\nvar _RecoveryError = require(\"../RecoveryError\");\n\nvar _recoveryDataSlice = require(\"../recoveryDataSlice\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar downloadConnection = function _callee(_ref) {\n  var dataId, channelApi, aesKey, channelId, encrypted, connectionData;\n  return _regenerator.default.async(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          dataId = _ref.dataId, channelApi = _ref.channelApi, aesKey = _ref.aesKey, channelId = _ref.channelId;\n          _context.prev = 1;\n          console.log(channelId, dataId);\n          _context.next = 5;\n          return _regenerator.default.awrap(channelApi.download({\n            channelId: channelId,\n            dataId: dataId,\n            deleteAfterDownload: true\n          }));\n\n        case 5:\n          encrypted = _context.sent;\n          connectionData = (0, _cryptoHelper.decryptData)(encrypted, aesKey);\n\n          if (!(!connectionData || !(connectionData != null && connectionData.id) || !(connectionData != null && connectionData.name))) {\n            _context.next = 10;\n            break;\n          }\n\n          console.log('missing connection data');\n          return _context.abrupt(\"return\");\n\n        case 10:\n          console.log(\"Downloaded profile data of \" + connectionData.name + \" (\" + (connectionData == null ? void 0 : connectionData.id) + \")\");\n          return _context.abrupt(\"return\", connectionData);\n\n        case 14:\n          _context.prev = 14;\n          _context.t0 = _context[\"catch\"](1);\n          console.error(\"downloadConnection: \" + _context.t0.message);\n          throw _context.t0;\n\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[1, 14]], Promise);\n};\n\nvar downloadConnections = function downloadConnections(_ref2) {\n  var channelApi = _ref2.channelApi,\n      dataIds = _ref2.dataIds;\n  return function _callee2(dispatch, getState) {\n    var _getState, signingKey, _getState$recoveryDat, recoveryId, aesKey, channelId, connections, existingConnIds, isConn, connId, uploader, connectionDataIds, count, _iterator, _step, dataId, connectionData, filename, newConnection;\n\n    return _regenerator.default.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _getState = getState(), signingKey = _getState.keypair.publicKey, _getState$recoveryDat = _getState.recoveryData, recoveryId = _getState$recoveryDat.id, aesKey = _getState$recoveryDat.aesKey, channelId = _getState$recoveryDat.channel.channelId;\n            connections = (0, _actions.selectAllConnections)(getState());\n            existingConnIds = connections.map(function (c) {\n              return c.id;\n            });\n\n            isConn = function isConn(id) {\n              return id.startsWith('connection_');\n            };\n\n            connId = function connId(id) {\n              return id.replace('connection_', '').split(':')[0];\n            };\n\n            uploader = function uploader(id) {\n              return id.replace('connection_', '').split(':')[1];\n            };\n\n            connectionDataIds = dataIds.filter(function (id) {\n              return isConn(id) && uploader(id) !== (0, _encoding.b64ToUrlSafeB64)(signingKey) && !existingConnIds.includes(connId(id)) && connId(id) !== recoveryId;\n            });\n            count = 0;\n            _iterator = _createForOfIteratorHelperLoose(connectionDataIds);\n\n          case 10:\n            if ((_step = _iterator()).done) {\n              _context2.next = 26;\n              break;\n            }\n\n            dataId = _step.value;\n            _context2.next = 14;\n            return _regenerator.default.awrap(downloadConnection({\n              dataId: dataId,\n              channelApi: channelApi,\n              aesKey: aesKey,\n              channelId: channelId\n            }));\n\n          case 14:\n            connectionData = _context2.sent;\n\n            if (!connectionData) {\n              _context2.next = 24;\n              break;\n            }\n\n            filename = void 0;\n\n            if (!connectionData.photo) {\n              _context2.next = 21;\n              break;\n            }\n\n            _context2.next = 20;\n            return _regenerator.default.awrap((0, _filesystem.saveImage)({\n              imageName: connectionData.id,\n              base64Image: connectionData.photo\n            }));\n\n          case 20:\n            filename = _context2.sent;\n\n          case 21:\n            newConnection = (0, _extends2.default)({}, connectionData, {\n              photo: {\n                filename: filename\n              }\n            });\n            dispatch((0, _actions.addConnection)(newConnection));\n            count++;\n\n          case 24:\n            _context2.next = 10;\n            break;\n\n          case 26:\n            if (count > 0) {\n              dispatch((0, _recoveryDataSlice.increaseRecoveredConnections)(count));\n            }\n\n            return _context2.abrupt(\"return\", connectionDataIds.length);\n\n          case 30:\n            _context2.prev = 30;\n            _context2.t0 = _context2[\"catch\"](0);\n            console.error(\"downloadingConnections: \" + _context2.t0.message);\n\n          case 33:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 30]], Promise);\n  };\n};\n\nexports.downloadConnections = downloadConnections;\n\nvar downloadNamePhoto = function downloadNamePhoto(_ref3) {\n  var channelApi = _ref3.channelApi,\n      dataIds = _ref3.dataIds;\n  return function _callee3(dispatch, getState) {\n    var _getState2, signingKey, _getState2$recoveryDa, recoveryId, aesKey, channelId, connId, uploader, dataId, connectionData, _getState3, name, filename;\n\n    return _regenerator.default.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _getState2 = getState(), signingKey = _getState2.keypair.publicKey, _getState2$recoveryDa = _getState2.recoveryData, recoveryId = _getState2$recoveryDa.id, aesKey = _getState2$recoveryDa.aesKey, channelId = _getState2$recoveryDa.channel.channelId;\n\n            connId = function connId(id) {\n              return id.replace('connection_', '').split(':')[0];\n            };\n\n            uploader = function uploader(id) {\n              return id.replace('connection_', '').split(':')[1];\n            };\n\n            dataId = dataIds.find(function (id) {\n              return connId(id) === recoveryId && uploader(id) !== (0, _encoding.b64ToUrlSafeB64)(signingKey);\n            });\n\n            if (!dataId) {\n              _context3.next = 15;\n              break;\n            }\n\n            _context3.next = 7;\n            return _regenerator.default.awrap(downloadConnection({\n              dataId: dataId,\n              channelApi: channelApi,\n              aesKey: aesKey,\n              channelId: channelId\n            }));\n\n          case 7:\n            connectionData = _context3.sent;\n            _getState3 = getState(), name = _getState3.recoveryData.name;\n\n            if (!(!name && connectionData)) {\n              _context3.next = 15;\n              break;\n            }\n\n            if (!connectionData.photo) {\n              _context3.next = 14;\n              break;\n            }\n\n            _context3.next = 13;\n            return _regenerator.default.awrap((0, _filesystem.saveImage)({\n              imageName: connectionData.id,\n              base64Image: connectionData.photo\n            }));\n\n          case 13:\n            filename = _context3.sent;\n\n          case 14:\n            dispatch((0, _recoveryDataSlice.updateNamePhoto)({\n              name: connectionData.name,\n              photo: {\n                filename: filename\n              }\n            }));\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\n\nexports.downloadNamePhoto = downloadNamePhoto;\n\nvar downloadGroup = function _callee4(_ref4) {\n  var dataId, channelApi, aesKey, channelId, encrypted, groupData, filename;\n  return _regenerator.default.async(function _callee4$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          dataId = _ref4.dataId, channelApi = _ref4.channelApi, aesKey = _ref4.aesKey, channelId = _ref4.channelId;\n          _context4.prev = 1;\n          _context4.next = 4;\n          return _regenerator.default.awrap(channelApi.download({\n            channelId: channelId,\n            dataId: dataId,\n            deleteAfterDownload: true\n          }));\n\n        case 4:\n          encrypted = _context4.sent;\n          groupData = (0, _cryptoHelper.decryptData)(encrypted, aesKey);\n\n          if (!(!groupData || !(groupData != null && groupData.id) || !(groupData != null && groupData.aesKey))) {\n            _context4.next = 9;\n            break;\n          }\n\n          console.log('missing group data');\n          return _context4.abrupt(\"return\");\n\n        case 9:\n          if (!groupData.photo) {\n            _context4.next = 13;\n            break;\n          }\n\n          _context4.next = 12;\n          return _regenerator.default.awrap((0, _filesystem.saveImage)({\n            imageName: groupData.id,\n            base64Image: groupData.photo\n          }));\n\n        case 12:\n          filename = _context4.sent;\n\n        case 13:\n          groupData.photo = {\n            filename: filename\n          };\n          return _context4.abrupt(\"return\", groupData);\n\n        case 17:\n          _context4.prev = 17;\n          _context4.t0 = _context4[\"catch\"](1);\n          console.error(\"downloadGroup: \" + _context4.t0.message);\n\n        case 20:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[1, 17]], Promise);\n};\n\nvar downloadGroups = function downloadGroups(_ref5) {\n  var channelApi = _ref5.channelApi,\n      dataIds = _ref5.dataIds;\n  return function _callee5(dispatch, getState) {\n    var _getState4, signingKey, _getState4$recoveryDa, aesKey, channelId, isGroup, uploader, groupDataIds, count, _iterator2, _step2, dataId, groupData;\n\n    return _regenerator.default.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            _getState4 = getState(), signingKey = _getState4.keypair.publicKey, _getState4$recoveryDa = _getState4.recoveryData, aesKey = _getState4$recoveryDa.aesKey, channelId = _getState4$recoveryDa.channel.channelId;\n\n            isGroup = function isGroup(id) {\n              return id.startsWith('group_');\n            };\n\n            uploader = function uploader(id) {\n              return id.replace('group_', '').split(':')[1];\n            };\n\n            groupDataIds = dataIds.filter(function (id) {\n              return isGroup(id) && uploader(id) !== (0, _encoding.b64ToUrlSafeB64)(signingKey);\n            });\n            count = 0;\n            _iterator2 = _createForOfIteratorHelperLoose(groupDataIds);\n\n          case 7:\n            if ((_step2 = _iterator2()).done) {\n              _context5.next = 15;\n              break;\n            }\n\n            dataId = _step2.value;\n            _context5.next = 11;\n            return _regenerator.default.awrap(downloadGroup({\n              dataId: dataId,\n              channelApi: channelApi,\n              aesKey: aesKey,\n              channelId: channelId\n            }));\n\n          case 11:\n            groupData = _context5.sent;\n\n            if (groupData) {\n              dispatch((0, _actions.upsertGroup)(groupData));\n              count++;\n            }\n\n          case 13:\n            _context5.next = 7;\n            break;\n\n          case 15:\n            if (count > 0) {\n              dispatch((0, _recoveryDataSlice.increaseRecoveredGroups)(count));\n            }\n\n            return _context5.abrupt(\"return\", groupDataIds.length);\n\n          case 19:\n            _context5.prev = 19;\n            _context5.t0 = _context5[\"catch\"](0);\n            console.error(\"downloadingGroups: \" + _context5.t0.message);\n\n          case 22:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, [[0, 19]], Promise);\n  };\n};\n\nexports.downloadGroups = downloadGroups;\n\nvar downloadSigs = function downloadSigs(_ref6) {\n  var channelApi = _ref6.channelApi,\n      dataIds = _ref6.dataIds;\n  return function _callee6(dispatch, getState) {\n    var _getState5, _getState5$recoveryDa, sigs, channelId, id, isSig, sigId, sigDataIds, _iterator3, _step3, dataId, signer, sig;\n\n    return _regenerator.default.async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _getState5 = getState(), _getState5$recoveryDa = _getState5.recoveryData, sigs = _getState5$recoveryDa.sigs, channelId = _getState5$recoveryDa.channel.channelId, id = _getState5$recoveryDa.id;\n\n            isSig = function isSig(id) {\n              return id.startsWith('sig_');\n            };\n\n            sigId = function sigId(id) {\n              return id.replace('sig_', '').split(':')[0];\n            };\n\n            sigDataIds = dataIds.filter(function (dataId) {\n              return isSig(dataId) && !sigs[sigId(dataId)];\n            });\n            _iterator3 = _createForOfIteratorHelperLoose(sigDataIds);\n\n          case 6:\n            if ((_step3 = _iterator3()).done) {\n              _context6.next = 17;\n              break;\n            }\n\n            dataId = _step3.value;\n            signer = sigId(dataId);\n            _context6.next = 11;\n            return _regenerator.default.awrap(channelApi.download({\n              channelId: channelId,\n              dataId: dataId\n            }));\n\n          case 11:\n            sig = _context6.sent;\n\n            if (!(id && sig.id !== id)) {\n              _context6.next = 14;\n              break;\n            }\n\n            throw new _RecoveryError.RecoveryError(_RecoveryError.RecoveryErrorType.MISMATCH_ID);\n\n          case 14:\n            dispatch((0, _recoveryDataSlice.setSig)({\n              signer: signer,\n              sig: sig\n            }));\n\n          case 15:\n            _context6.next = 6;\n            break;\n\n          case 17:\n            return _context6.abrupt(\"return\", sigDataIds.length);\n\n          case 20:\n            _context6.prev = 20;\n            _context6.t0 = _context6[\"catch\"](0);\n\n            if (_context6.t0 instanceof _RecoveryError.RecoveryError) {\n              console.error(\"downloadingSigs: \" + _context6.t0.errorType);\n              dispatch((0, _recoveryDataSlice.setRecoveryError)({\n                errorType: _context6.t0.errorType\n              }));\n            } else {\n              console.error(\"downloadingSigs: \" + _context6.t0.message);\n              dispatch((0, _recoveryDataSlice.setRecoveryError)({\n                errorType: _RecoveryError.RecoveryErrorType.GENERIC,\n                errorMessage: _context6.t0.message\n              }));\n            }\n\n          case 23:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, [[0, 20]], Promise);\n  };\n};\n\nexports.downloadSigs = downloadSigs;","map":{"version":3,"names":["downloadConnection","dataId","channelApi","aesKey","channelId","console","log","download","deleteAfterDownload","encrypted","connectionData","decryptData","id","name","error","message","downloadConnections","dataIds","dispatch","getState","signingKey","keypair","publicKey","recoveryData","recoveryId","channel","connections","selectAllConnections","existingConnIds","map","c","isConn","startsWith","connId","replace","split","uploader","connectionDataIds","filter","b64ToUrlSafeB64","includes","count","filename","photo","saveImage","imageName","base64Image","newConnection","addConnection","increaseRecoveredConnections","length","downloadNamePhoto","find","updateNamePhoto","downloadGroup","groupData","downloadGroups","isGroup","groupDataIds","upsertGroup","increaseRecoveredGroups","downloadSigs","sigs","isSig","sigId","sigDataIds","signer","sig","RecoveryError","RecoveryErrorType","MISMATCH_ID","setSig","errorType","setRecoveryError","GENERIC","errorMessage"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/channelDownloadThunks.ts"],"sourcesContent":["import ChannelAPI from '@/api/channelService';\nimport { saveImage } from '@/utils/filesystem';\nimport { decryptData } from '@/utils/cryptoHelper';\nimport { hash, b64ToUrlSafeB64 } from '@/utils/encoding';\nimport { addConnection, upsertGroup, selectAllConnections } from '@/actions';\nimport {\n  RecoveryError,\n  RecoveryErrorType,\n} from '@/components/Onboarding/RecoveryFlow/RecoveryError';\nimport {\n  setSig,\n  updateNamePhoto,\n  increaseRecoveredConnections,\n  increaseRecoveredGroups,\n  setRecoveryError,\n} from '../recoveryDataSlice';\n\nconst downloadConnection = async ({\n  dataId,\n  channelApi,\n  aesKey,\n  channelId,\n}: {\n  dataId: string;\n  channelApi: ChannelAPI;\n  aesKey: string;\n  channelId: string;\n}): Promise<SyncConnection> => {\n  try {\n    console.log(channelId, dataId);\n    const encrypted = await channelApi.download({\n      channelId,\n      dataId,\n      deleteAfterDownload: true,\n    });\n    const connectionData = decryptData(encrypted, aesKey) as SyncConnection;\n\n    // missing data\n    if (!connectionData || !connectionData?.id || !connectionData?.name) {\n      console.log('missing connection data');\n      return;\n    }\n    console.log(\n      `Downloaded profile data of ${connectionData.name} (${connectionData?.id})`,\n    );\n\n    return connectionData;\n  } catch (err) {\n    console.error(`downloadConnection: ${err.message}`);\n    throw err;\n  }\n};\n\nexport const downloadConnections =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        keypair: { publicKey: signingKey },\n        recoveryData: {\n          id: recoveryId,\n          aesKey,\n          channel: { channelId },\n        },\n      } = getState();\n\n      const connections = selectAllConnections(getState());\n\n      const existingConnIds = connections.map((c) => c.id);\n\n      const isConn = (id) => id.startsWith('connection_');\n      const connId = (id) => id.replace('connection_', '').split(':')[0];\n      const uploader = (id) => id.replace('connection_', '').split(':')[1];\n\n      const connectionDataIds = dataIds.filter(\n        (id) =>\n          isConn(id) &&\n          uploader(id) !== b64ToUrlSafeB64(signingKey) &&\n          !existingConnIds.includes(connId(id)) &&\n          connId(id) !== recoveryId,\n      );\n\n      let count = 0;\n      for (const dataId of connectionDataIds) {\n        const connectionData = await downloadConnection({\n          dataId,\n          channelApi,\n          aesKey,\n          channelId,\n        });\n        if (connectionData) {\n          let filename: string;\n          if (connectionData.photo) {\n            filename = await saveImage({\n              imageName: connectionData.id,\n              base64Image: connectionData.photo,\n            });\n          }\n          const newConnection: Connection = {\n            ...connectionData,\n            photo: { filename },\n          };\n\n          dispatch(addConnection(newConnection));\n          count++;\n        }\n      }\n      if (count > 0) {\n        dispatch(increaseRecoveredConnections(count));\n      }\n      return connectionDataIds.length;\n    } catch (err) {\n      console.error(`downloadingConnections: ${err.message}`);\n    }\n  };\n\nexport const downloadNamePhoto =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    const {\n      keypair: { publicKey: signingKey },\n      recoveryData: {\n        id: recoveryId,\n        aesKey,\n        channel: { channelId },\n      },\n    } = getState();\n\n    const connId = (id) => id.replace('connection_', '').split(':')[0];\n    const uploader = (id) => id.replace('connection_', '').split(':')[1];\n\n    const dataId = dataIds.find(\n      (id) =>\n        connId(id) === recoveryId &&\n        uploader(id) !== b64ToUrlSafeB64(signingKey),\n    );\n\n    if (dataId) {\n      const connectionData = await downloadConnection({\n        dataId,\n        channelApi,\n        aesKey,\n        channelId,\n      });\n\n      const {\n        recoveryData: { name },\n      } = getState();\n\n      if (!name && connectionData) {\n        let filename: string;\n        if (connectionData.photo) {\n          filename = await saveImage({\n            imageName: connectionData.id,\n            base64Image: connectionData.photo,\n          });\n        }\n        dispatch(\n          updateNamePhoto({ name: connectionData.name, photo: { filename } }),\n        );\n      }\n    }\n  };\n\nconst downloadGroup = async ({\n  dataId,\n  channelApi,\n  aesKey,\n  channelId,\n}: {\n  dataId: string;\n  channelApi: ChannelAPI;\n  aesKey: string;\n  channelId: string;\n}) => {\n  try {\n    const encrypted = await channelApi.download({\n      channelId,\n      dataId,\n      deleteAfterDownload: true,\n    });\n    const groupData = decryptData(encrypted, aesKey);\n    // group data missing\n    if (!groupData || !groupData?.id || !groupData?.aesKey) {\n      console.log('missing group data');\n      return;\n    }\n\n    let filename;\n    if (groupData.photo) {\n      filename = await saveImage({\n        imageName: groupData.id,\n        base64Image: groupData.photo,\n      });\n    }\n    groupData.photo = { filename };\n    return groupData;\n  } catch (err) {\n    console.error(`downloadGroup: ${err.message}`);\n  }\n};\n\nexport const downloadGroups =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        keypair: { publicKey: signingKey },\n        recoveryData: {\n          aesKey,\n          channel: { channelId },\n        },\n      } = getState();\n\n      const isGroup = (id) => id.startsWith('group_');\n      const uploader = (id) => id.replace('group_', '').split(':')[1];\n      const groupDataIds = dataIds.filter(\n        (id) => isGroup(id) && uploader(id) !== b64ToUrlSafeB64(signingKey),\n      );\n      let count = 0;\n      for (const dataId of groupDataIds) {\n        const groupData = await downloadGroup({\n          dataId,\n          channelApi,\n          aesKey,\n          channelId,\n        });\n        if (groupData) {\n          dispatch(upsertGroup(groupData));\n          count++;\n        }\n      }\n      if (count > 0) {\n        dispatch(increaseRecoveredGroups(count));\n      }\n      return groupDataIds.length;\n    } catch (err) {\n      console.error(`downloadingGroups: ${err.message}`);\n    }\n  };\n\nexport const downloadSigs =\n  ({\n    channelApi,\n    dataIds,\n  }: {\n    channelApi: ChannelAPI;\n    dataIds: Array<string>;\n  }) =>\n  async (dispatch: dispatch, getState: getState) => {\n    try {\n      const {\n        recoveryData: {\n          sigs,\n          channel: { channelId },\n          id,\n        },\n      } = getState();\n\n      const isSig = (id: string) => id.startsWith('sig_');\n      const sigId = (id: string) => id.replace('sig_', '').split(':')[0];\n\n      const sigDataIds = dataIds.filter(\n        (dataId) => isSig(dataId) && !sigs[sigId(dataId)],\n      );\n\n      for (const dataId of sigDataIds) {\n        const signer = sigId(dataId);\n        const sig: Signature = await channelApi.download({ channelId, dataId });\n        if (id && sig.id !== id) {\n          // recovery connections disagree on which account is being recovered!\n          throw new RecoveryError(RecoveryErrorType.MISMATCH_ID);\n        }\n        dispatch(setSig({ signer, sig }));\n      }\n      return sigDataIds.length;\n    } catch (err) {\n      if (err instanceof RecoveryError) {\n        console.error(`downloadingSigs: ${err.errorType}`);\n        dispatch(setRecoveryError({ errorType: err.errorType }));\n      } else {\n        console.error(`downloadingSigs: ${err.message}`);\n        dispatch(\n          setRecoveryError({\n            errorType: RecoveryErrorType.GENERIC,\n            errorMessage: err.message,\n          }),\n        );\n      }\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}