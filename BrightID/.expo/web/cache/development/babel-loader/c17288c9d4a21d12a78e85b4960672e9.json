{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { channel_types, selectChannelById } from \"../channelSlice\";\nimport { addConnection, addOperation } from \"../../../actions\";\nimport { saveImage } from \"../../../utils/filesystem\";\nimport { backupPhoto, backupUser } from \"../../Onboarding/RecoveryFlow/thunks/backupThunks\";\nimport { confirmPendingConnection, pendingConnection_states, selectPendingConnectionById, updatePendingConnection } from \"../pendingConnectionSlice\";\nimport { leaveChannel, encryptAndUploadProfileToChannel } from \"./channelThunks\";\nimport { connection_levels } from \"../../../utils/constants\";\nexport var confirmPendingConnectionThunk = function confirmPendingConnectionThunk(id, level, api, reportReason) {\n  return function _callee(dispatch, getState) {\n    var connection, _connection$pendingCo, profileInfo, sharedProfile, channel, _getState, _getState$user, brightId, backupCompleted, connectionTimestamp, op, _op, filename, connectionData, reported;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            connection = selectPendingConnectionById(getState(), id);\n\n            if (!(connection.state !== pendingConnection_states.UNCONFIRMED)) {\n              _context.next = 4;\n              break;\n            }\n\n            console.log(\"Can't confirm - Connection is in state \" + connection.state);\n            return _context.abrupt(\"return\");\n\n          case 4:\n            _connection$pendingCo = connection.pendingConnectionData, profileInfo = _connection$pendingCo.profileInfo, sharedProfile = _connection$pendingCo.sharedProfile;\n            dispatch(updatePendingConnection({\n              id: id,\n              changes: {\n                state: pendingConnection_states.CONFIRMING\n              }\n            }));\n            channel = selectChannelById(getState(), connection.channelId);\n            console.log(\"confirming connection \" + id + \" in channel \" + channel.id + \" with level '\" + level + \"'\");\n            _getState = getState(), _getState$user = _getState.user, brightId = _getState$user.id, backupCompleted = _getState$user.backupCompleted;\n            connectionTimestamp = sharedProfile.profileTimestamp;\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(api.addConnection(brightId, sharedProfile.id, level, connectionTimestamp, reportReason, sharedProfile.requestProof));\n\n          case 12:\n            op = _context.sent;\n            dispatch(addOperation(op));\n\n            if (!__DEV__) {\n              _context.next = 20;\n              break;\n            }\n\n            if (!sharedProfile.secretKey) {\n              _context.next = 20;\n              break;\n            }\n\n            _context.next = 18;\n            return _regeneratorRuntime.awrap(api.addConnection(sharedProfile.id, brightId, level, connectionTimestamp, reportReason, sharedProfile.requestProof, {\n              id: sharedProfile.id,\n              secretKey: sharedProfile.secretKey\n            }));\n\n          case 18:\n            _op = _context.sent;\n            dispatch(addOperation(_op));\n\n          case 20:\n            _context.next = 22;\n            return _regeneratorRuntime.awrap(saveImage({\n              imageName: sharedProfile.id,\n              base64Image: sharedProfile.photo\n            }));\n\n          case 22:\n            filename = _context.sent;\n            connectionData = {\n              id: sharedProfile.id,\n              name: sharedProfile.name,\n              connectionDate: connectionTimestamp,\n              photo: {\n                filename: filename\n              },\n              status: 'initiated',\n              notificationToken: sharedProfile.notificationToken,\n              secretKey: sharedProfile.secretKey,\n              level: level,\n              reportReason: reportReason,\n              socialMedia: sharedProfile.socialMedia,\n              verifications: (profileInfo == null ? void 0 : profileInfo.verifications) || []\n            };\n            dispatch(addConnection(connectionData));\n            dispatch(confirmPendingConnection(connection.profileId));\n            reported = Array(connection_levels.SUSPICIOUS, connection_levels.REPORTED).includes(level);\n\n            if (!(connection.profileId === channel.initiatorProfileId)) {\n              _context.next = 34;\n              break;\n            }\n\n            if (reported) {\n              _context.next = 33;\n              break;\n            }\n\n            _context.next = 31;\n            return _regeneratorRuntime.awrap(dispatch(encryptAndUploadProfileToChannel(channel.id)));\n\n          case 31:\n            _context.next = 34;\n            break;\n\n          case 33:\n            if (channel.type === channel_types.GROUP) {\n              console.log(\"Leaving group channel \" + channel.id + \" cause I don't trust the initiator (level: '\" + level + \"')\");\n              dispatch(leaveChannel(channel.id));\n            }\n\n          case 34:\n            if (channel.type === channel_types.SINGLE || channel.type === channel_types.STAR && channel.initiatorProfileId !== channel.myProfileId) {\n              dispatch(leaveChannel(channel.id));\n            }\n\n            if (!backupCompleted) {\n              _context.next = 40;\n              break;\n            }\n\n            _context.next = 38;\n            return _regeneratorRuntime.awrap(dispatch(backupPhoto(sharedProfile.id, filename)));\n\n          case 38:\n            _context.next = 40;\n            return _regeneratorRuntime.awrap(dispatch(backupUser()));\n\n          case 40:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/PendingConnections/actions/pendingConnectionThunks.ts"],"names":["confirmPendingConnectionThunk","connection","selectPendingConnectionById","getState","pendingConnection_states","console","profileInfo","sharedProfile","dispatch","updatePendingConnection","id","changes","state","channel","selectChannelById","brightId","backupCompleted","connectionTimestamp","op","api","addOperation","secretKey","filename","saveImage","imageName","base64Image","connectionData","name","connectionDate","photo","status","notificationToken","level","reportReason","socialMedia","verifications","addConnection","confirmPendingConnection","reported","Array","connection_levels","encryptAndUploadProfileToChannel","channel_types","leaveChannel","backupPhoto","backupUser"],"mappings":"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","sourcesContent":["import {\n  channel_types,\n  selectChannelById,\n} from '@/components/PendingConnections/channelSlice';\nimport { addConnection, addOperation } from '@/actions';\nimport { saveImage } from '@/utils/filesystem';\nimport {\n  backupPhoto,\n  backupUser,\n} from '@/components/Onboarding/RecoveryFlow/thunks/backupThunks';\nimport {\n  confirmPendingConnection,\n  pendingConnection_states,\n  selectPendingConnectionById,\n  updatePendingConnection,\n} from '@/components/PendingConnections/pendingConnectionSlice';\nimport {\n  leaveChannel,\n  encryptAndUploadProfileToChannel,\n} from '@/components/PendingConnections/actions/channelThunks';\nimport { NodeApi } from '@/api/brightId';\nimport { connection_levels } from '@/utils/constants';\n\nexport const confirmPendingConnectionThunk =\n  (\n    id: string,\n    level: ConnectionLevel,\n    api: NodeApi,\n    reportReason?: ReportReason,\n  ) =>\n  async (dispatch: dispatch, getState: getState) => {\n    const connection: PendingConnection = selectPendingConnectionById(\n      getState(),\n      id,\n    );\n    // validate pendingConnection state\n    if (connection.state !== pendingConnection_states.UNCONFIRMED) {\n      console.log(`Can't confirm - Connection is in state ${connection.state}`);\n      return;\n    }\n\n    const {\n      pendingConnectionData: { profileInfo, sharedProfile },\n    } = connection;\n\n    dispatch(\n      updatePendingConnection({\n        id,\n        changes: {\n          state: pendingConnection_states.CONFIRMING,\n        },\n      }),\n    );\n\n    const channel = selectChannelById(getState(), connection.channelId);\n    console.log(\n      `confirming connection ${id} in channel ${channel.id} with level '${level}'`,\n    );\n\n    const {\n      user: { id: brightId, backupCompleted },\n    } = getState();\n\n    const connectionTimestamp = sharedProfile.profileTimestamp;\n    const op = await api.addConnection(\n      brightId,\n      sharedProfile.id,\n      level,\n      connectionTimestamp,\n      reportReason,\n      sharedProfile.requestProof,\n    );\n    dispatch(addOperation(op));\n\n    if (__DEV__) {\n      // if peer is a fake connection also submit opposite addConnection operation\n      if (sharedProfile.secretKey) {\n        const op = await api.addConnection(\n          sharedProfile.id,\n          brightId,\n          level,\n          connectionTimestamp,\n          reportReason,\n          sharedProfile.requestProof,\n          {\n            id: sharedProfile.id,\n            secretKey: sharedProfile.secretKey,\n          },\n        );\n        dispatch(addOperation(op));\n      }\n    }\n\n    // save connection photo\n    const filename = await saveImage({\n      imageName: sharedProfile.id,\n      base64Image: sharedProfile.photo,\n    });\n\n    // create established connection from pendingConnection\n    const connectionData: LocalConnectionData = {\n      id: sharedProfile.id,\n      name: sharedProfile.name,\n      connectionDate: connectionTimestamp,\n      photo: { filename },\n      status: 'initiated',\n      notificationToken: sharedProfile.notificationToken,\n      secretKey: sharedProfile.secretKey,\n      level,\n      reportReason,\n      socialMedia: sharedProfile.socialMedia,\n      verifications: profileInfo?.verifications || [],\n    };\n\n    dispatch(addConnection(connectionData));\n    dispatch(confirmPendingConnection(connection.profileId));\n\n    const reported = Array<ConnectionLevel>(\n      connection_levels.SUSPICIOUS,\n      connection_levels.REPORTED,\n    ).includes(level);\n\n    // check connection level with initiator to decide next steps\n    if (connection.profileId === channel.initiatorProfileId) {\n      if (!reported) {\n        // upload profile to channel only *after* accepting the connection with creator\n        // to prevent leaking my profile info to unwanted connections\n        await dispatch(encryptAndUploadProfileToChannel(channel.id));\n      } else if (channel.type === channel_types.GROUP) {\n        // immediately leave group connection channel if initiator got reported\n        console.log(\n          `Leaving group channel ${channel.id} cause I don't trust the initiator (level: '${level}')`,\n        );\n        dispatch(leaveChannel(channel.id));\n      }\n    }\n\n    // Leave channel if no additional connections are expected\n    if (\n      channel.type === channel_types.SINGLE ||\n      (channel.type === channel_types.STAR &&\n        channel.initiatorProfileId !== channel.myProfileId)\n    ) {\n      dispatch(leaveChannel(channel.id));\n    }\n\n    if (backupCompleted) {\n      await dispatch(backupPhoto(sharedProfile.id, filename));\n      await dispatch(backupUser());\n    }\n  };\n"]},"metadata":{},"sourceType":"module"}