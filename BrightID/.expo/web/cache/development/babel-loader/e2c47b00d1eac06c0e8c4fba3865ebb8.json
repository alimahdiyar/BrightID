{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _apisauce = require(\"apisauce\");\n\nvar _constants = require(\"../utils/constants\");\n\nvar ChannelAPI = function () {\n  function ChannelAPI(baseURL) {\n    (0, _classCallCheck2.default)(this, ChannelAPI);\n    this.api = (0, _apisauce.create)({\n      baseURL: baseURL,\n      headers: {\n        'Cache-Control': 'no-cache'\n      }\n    });\n  }\n\n  (0, _createClass2.default)(ChannelAPI, [{\n    key: \"upload\",\n    value: function upload(params) {\n      var _this = this;\n\n      var channelId, data, dataId, requestedTtl, requestedTtlSecs, body, retries, result, _loop;\n\n      return _regenerator.default.async(function upload$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              channelId = params.channelId, data = params.data, dataId = params.dataId, requestedTtl = params.requestedTtl;\n              requestedTtlSecs = requestedTtl ? Math.floor(requestedTtl / 1000) : undefined;\n              body = JSON.stringify({\n                data: data,\n                uuid: dataId,\n                requestedTtl: requestedTtlSecs\n              });\n              retries = 0;\n              _context2.next = 6;\n              return _regenerator.default.awrap(this.api.post(\"/upload/\" + channelId, body));\n\n            case 6:\n              result = _context2.sent;\n\n              _loop = function _callee() {\n                var retryDelay;\n                return _regenerator.default.async(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        retries++;\n                        retryDelay = _constants.CHANNEL_UPLOAD_RETRY_INTERVAL * retries;\n                        console.log(\"Uploading \" + dataId + \" to \" + channelId + \" failed with status \" + result.status + \" at try \" + (retries - 1) + \". Retrying in \" + retryDelay + \"ms.\");\n                        _context.next = 5;\n                        return _regenerator.default.awrap(new Promise(function (r) {\n                          return setTimeout(r, retryDelay);\n                        }));\n\n                      case 5:\n                        _context.next = 7;\n                        return _regenerator.default.awrap(_this.api.post(\"/upload/\" + channelId, body));\n\n                      case 7:\n                        result = _context.sent;\n\n                      case 8:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, null, null, null, Promise);\n              };\n\n            case 8:\n              if (!(!result.ok && retries < _constants.CHANNEL_UPLOAD_RETRY_COUNT)) {\n                _context2.next = 13;\n                break;\n              }\n\n              _context2.next = 11;\n              return _regenerator.default.awrap(_loop());\n\n            case 11:\n              _context2.next = 8;\n              break;\n\n            case 13:\n              ChannelAPI.throwOnError(result);\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"list\",\n    value: function list(channelId) {\n      var result;\n      return _regenerator.default.async(function list$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _regenerator.default.awrap(this.api.get(\"/list/\" + channelId));\n\n            case 2:\n              result = _context3.sent;\n              ChannelAPI.throwOnError(result);\n\n              if (!(result.data && result.data.profileIds)) {\n                _context3.next = 8;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", result.data.profileIds);\n\n            case 8:\n              throw new Error(\"list for channel \" + channelId + \": Unexpected response format\");\n\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"download\",\n    value: function download(params) {\n      var channelId, dataId, deleteAfterDownload, result;\n      return _regenerator.default.async(function download$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              channelId = params.channelId, dataId = params.dataId, deleteAfterDownload = params.deleteAfterDownload;\n              _context4.next = 3;\n              return _regenerator.default.awrap(this.api.get(\"/download/\" + channelId + \"/\" + dataId));\n\n            case 3:\n              result = _context4.sent;\n              ChannelAPI.throwOnError(result);\n\n              if (!deleteAfterDownload) {\n                _context4.next = 14;\n                break;\n              }\n\n              _context4.prev = 6;\n              _context4.next = 9;\n              return _regenerator.default.awrap(this.api.delete(\"/\" + channelId + \"/\" + dataId));\n\n            case 9:\n              _context4.next = 14;\n              break;\n\n            case 11:\n              _context4.prev = 11;\n              _context4.t0 = _context4[\"catch\"](6);\n              console.log(\"Ignoring error while deleting \" + dataId + \" from channel \" + channelId + \": \" + _context4.t0);\n\n            case 14:\n              if (!(result.data && result.data.data)) {\n                _context4.next = 18;\n                break;\n              }\n\n              return _context4.abrupt(\"return\", result.data.data);\n\n            case 18:\n              throw new Error(\"download \" + dataId + \" from channel \" + channelId + \": Unexpected response format\");\n\n            case 19:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, [[6, 11]], Promise);\n    }\n  }], [{\n    key: \"throwOnError\",\n    value: function throwOnError(response) {\n      if (response.ok) {\n        return;\n      }\n\n      if (response.data && response.data.error) {\n        throw new Error(response.data.error);\n      }\n\n      throw new Error(response.problem);\n    }\n  }]);\n  return ChannelAPI;\n}();\n\nvar _default = ChannelAPI;\nexports.default = _default;","map":{"version":3,"names":["ChannelAPI","baseURL","api","create","headers","params","channelId","data","dataId","requestedTtl","requestedTtlSecs","Math","floor","undefined","body","JSON","stringify","uuid","retries","post","result","retryDelay","CHANNEL_UPLOAD_RETRY_INTERVAL","console","log","status","Promise","r","setTimeout","ok","CHANNEL_UPLOAD_RETRY_COUNT","throwOnError","get","profileIds","Error","deleteAfterDownload","delete","response","error","problem"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/api/channelService.ts"],"sourcesContent":["/*\n    Channel Service API\n\n    Operations:\n\n    - Upload data with unique ID to channel\n        -> POST /profile/upload/${channelID}\n    - Get list of data IDs in channel\n        -> GET /profile/list/${channelID}\n    - Download data from channel\n        -> GET /profile/download/${channelID}/${dataID}\n\n    We need to support multiple different hosts, so\n    we can not use a global API instance. Instead it needs to be created per channel.\n */\nimport { create, ApisauceInstance, ApiResponse } from 'apisauce';\nimport {\n  CHANNEL_UPLOAD_RETRY_COUNT,\n  CHANNEL_UPLOAD_RETRY_INTERVAL,\n} from '@/utils/constants';\n\ntype UploadParams = {\n  channelId: string;\n  data: any;\n  dataId: string;\n  // Use requestedTtl to override default channel TTL on the backend. Only taken into account when\n  // creating a channel (upload of first entry).\n  requestedTtl?: number;\n};\n\ntype DownloadParams = {\n  channelId: string;\n  dataId: string;\n  deleteAfterDownload?: boolean;\n};\n\nclass ChannelAPI {\n  api: ApisauceInstance;\n\n  constructor(baseURL: string) {\n    this.api = create({\n      baseURL,\n      headers: { 'Cache-Control': 'no-cache' },\n    });\n  }\n\n  static throwOnError(response: ApiResponse<any>) {\n    if (response.ok) {\n      return;\n    }\n    if (response.data && response.data.error) {\n      throw new Error(response.data.error);\n    }\n    throw new Error(response.problem);\n  }\n\n  async upload(params: UploadParams) {\n    const { channelId, data, dataId, requestedTtl } = params;\n\n    // convert TTL from ms to seconds\n    const requestedTtlSecs = requestedTtl\n      ? Math.floor(requestedTtl / 1000)\n      : undefined;\n\n    const body = JSON.stringify({\n      data,\n      uuid: dataId,\n      requestedTtl: requestedTtlSecs,\n    });\n\n    let retries = 0;\n    let result = await this.api.post(`/upload/${channelId}`, body);\n\n    // Upload failed. Wait to try again with increasing delay, give up after max attempts\n    while (!result.ok && retries < CHANNEL_UPLOAD_RETRY_COUNT) {\n      retries++;\n      const retryDelay = CHANNEL_UPLOAD_RETRY_INTERVAL * retries;\n      console.log(\n        `Uploading ${dataId} to ${channelId} failed with status ${\n          result.status\n        } at try ${retries - 1}. Retrying in ${retryDelay}ms.`,\n      );\n      await new Promise((r) => setTimeout(r, retryDelay));\n      result = await this.api.post(`/upload/${channelId}`, body);\n    }\n\n    ChannelAPI.throwOnError(result);\n  }\n\n  async list(channelId: string) {\n    const result = await this.api.get<{ profileIds: string[] }>(\n      `/list/${channelId}`,\n    );\n    ChannelAPI.throwOnError(result);\n    if (result.data && result.data.profileIds) {\n      return result.data.profileIds;\n    } else {\n      throw new Error(\n        `list for channel ${channelId}: Unexpected response format`,\n      );\n    }\n  }\n\n  async download(params: DownloadParams) {\n    const { channelId, dataId, deleteAfterDownload } = params;\n    const result = await this.api.get<{ data: any }>(\n      `/download/${channelId}/${dataId}`,\n    );\n    ChannelAPI.throwOnError(result);\n    if (deleteAfterDownload) {\n      try {\n        await this.api.delete(`/${channelId}/${dataId}`);\n      } catch (e) {\n        console.log(\n          `Ignoring error while deleting ${dataId} from channel ${channelId}: ${e}`,\n        );\n      }\n    }\n    if (result.data && result.data.data) {\n      return result.data.data;\n    } else {\n      throw new Error(\n        `download ${dataId} from channel ${channelId}: Unexpected response format`,\n      );\n    }\n  }\n}\n\nexport default ChannelAPI;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}