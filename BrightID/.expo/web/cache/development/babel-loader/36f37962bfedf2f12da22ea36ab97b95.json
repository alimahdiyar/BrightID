{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport NativeEventEmitter from \"react-native-web/dist/exports/NativeEventEmitter\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport invariant from 'invariant';\nvar RNCPushNotificationIOS = NativeModules.RNCPushNotificationIOS;\nvar PushNotificationEmitter = new NativeEventEmitter(RNCPushNotificationIOS);\n\nvar _notifHandlers = new Map();\n\nvar DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';\nvar NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';\nvar NOTIF_REGISTRATION_ERROR_EVENT = 'remoteNotificationRegistrationError';\nvar DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';\n\nvar PushNotificationIOS = function () {\n  function PushNotificationIOS(nativeNotif) {\n    var _this = this;\n\n    _classCallCheck(this, PushNotificationIOS);\n\n    this._data = {};\n    this._remoteNotificationCompleteCallbackCalled = false;\n    this._isRemote = nativeNotif.remote;\n\n    if (this._isRemote) {\n      this._notificationId = nativeNotif.notificationId;\n    }\n\n    this._actionIdentifier = nativeNotif.actionIdentifier;\n    this._userText = nativeNotif.userText;\n\n    if (nativeNotif.remote) {\n      Object.keys(nativeNotif).forEach(function (notifKey) {\n        var notifVal = nativeNotif[notifKey];\n\n        if (notifKey === 'aps') {\n          _this._alert = notifVal.alert;\n          _this._title = notifVal == null ? void 0 : notifVal.alertTitle;\n          _this._subtitle = notifVal == null ? void 0 : notifVal.subtitle;\n          _this._sound = notifVal.sound;\n          _this._badgeCount = notifVal.badge;\n          _this._category = notifVal.category;\n          _this._contentAvailable = notifVal['content-available'];\n          _this._threadID = notifVal['thread-id'];\n          _this._fireDate = notifVal.fireDate;\n        } else {\n          _this._data[notifKey] = notifVal;\n        }\n      });\n    } else {\n      this._badgeCount = nativeNotif.badge || nativeNotif.applicationIconBadgeNumber;\n      this._sound = nativeNotif.sound || nativeNotif.soundName;\n      this._alert = nativeNotif.body;\n      this._title = nativeNotif == null ? void 0 : nativeNotif.title;\n      this._subtitle = nativeNotif == null ? void 0 : nativeNotif.subtitle;\n      this._threadID = nativeNotif['thread-id'];\n      this._data = nativeNotif.userInfo;\n      this._category = nativeNotif.category;\n      this._fireDate = nativeNotif.fireDate;\n    }\n  }\n\n  _createClass(PushNotificationIOS, [{\n    key: \"finish\",\n    value: function finish(fetchResult) {\n      if (!this._isRemote || !this._notificationId || this._remoteNotificationCompleteCallbackCalled) {\n        return;\n      }\n\n      this._remoteNotificationCompleteCallbackCalled = true;\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.onFinishRemoteNotification(this._notificationId, fetchResult);\n    }\n  }, {\n    key: \"getMessage\",\n    value: function getMessage() {\n      if (typeof this._alert === 'object') {\n        var _this$_alert;\n\n        return (_this$_alert = this._alert) == null ? void 0 : _this$_alert.body;\n      }\n\n      return this._alert;\n    }\n  }, {\n    key: \"getSound\",\n    value: function getSound() {\n      return this._sound;\n    }\n  }, {\n    key: \"getCategory\",\n    value: function getCategory() {\n      return this._category;\n    }\n  }, {\n    key: \"getAlert\",\n    value: function getAlert() {\n      return this._alert;\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      if (typeof this._alert === 'object') {\n        var _this$_alert2;\n\n        return (_this$_alert2 = this._alert) == null ? void 0 : _this$_alert2.title;\n      }\n\n      return this._title;\n    }\n  }, {\n    key: \"getSubtitle\",\n    value: function getSubtitle() {\n      if (typeof this._alert === 'object') {\n        var _this$_alert3;\n\n        return (_this$_alert3 = this._alert) == null ? void 0 : _this$_alert3.subtitle;\n      }\n\n      return this._subtitle;\n    }\n  }, {\n    key: \"getContentAvailable\",\n    value: function getContentAvailable() {\n      return this._contentAvailable;\n    }\n  }, {\n    key: \"getBadgeCount\",\n    value: function getBadgeCount() {\n      return this._badgeCount;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this._data;\n    }\n  }, {\n    key: \"getThreadID\",\n    value: function getThreadID() {\n      return this._threadID;\n    }\n  }, {\n    key: \"getActionIdentifier\",\n    value: function getActionIdentifier() {\n      return this._actionIdentifier;\n    }\n  }, {\n    key: \"getUserText\",\n    value: function getUserText() {\n      return this._userText;\n    }\n  }], [{\n    key: \"presentLocalNotification\",\n    value: function presentLocalNotification(details) {\n      RNCPushNotificationIOS.presentLocalNotification(details);\n    }\n  }, {\n    key: \"scheduleLocalNotification\",\n    value: function scheduleLocalNotification(details) {\n      RNCPushNotificationIOS.scheduleLocalNotification(details);\n    }\n  }, {\n    key: \"addNotificationRequest\",\n    value: function addNotificationRequest(request) {\n      var handledRequest = request.fireDate instanceof Date ? _objectSpread(_objectSpread({}, request), {}, {\n        fireDate: request.fireDate.toISOString()\n      }) : request;\n\n      var finalRequest = _objectSpread(_objectSpread({}, handledRequest), {}, {\n        repeatsComponent: request.repeatsComponent || {}\n      });\n\n      RNCPushNotificationIOS.addNotificationRequest(finalRequest);\n    }\n  }, {\n    key: \"setNotificationCategories\",\n    value: function setNotificationCategories(categories) {\n      RNCPushNotificationIOS.setNotificationCategories(categories);\n    }\n  }, {\n    key: \"cancelAllLocalNotifications\",\n    value: function cancelAllLocalNotifications() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.cancelAllLocalNotifications();\n    }\n  }, {\n    key: \"removeAllPendingNotificationRequests\",\n    value: function removeAllPendingNotificationRequests() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removeAllPendingNotificationRequests();\n    }\n  }, {\n    key: \"removePendingNotificationRequests\",\n    value: function removePendingNotificationRequests(identifiers) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removePendingNotificationRequests(identifiers);\n    }\n  }, {\n    key: \"removeAllDeliveredNotifications\",\n    value: function removeAllDeliveredNotifications() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removeAllDeliveredNotifications();\n    }\n  }, {\n    key: \"getDeliveredNotifications\",\n    value: function getDeliveredNotifications(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getDeliveredNotifications(callback);\n    }\n  }, {\n    key: \"removeDeliveredNotifications\",\n    value: function removeDeliveredNotifications(identifiers) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.removeDeliveredNotifications(identifiers);\n    }\n  }, {\n    key: \"setApplicationIconBadgeNumber\",\n    value: function setApplicationIconBadgeNumber(number) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.setApplicationIconBadgeNumber(number);\n    }\n  }, {\n    key: \"getApplicationIconBadgeNumber\",\n    value: function getApplicationIconBadgeNumber(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getApplicationIconBadgeNumber(callback);\n    }\n  }, {\n    key: \"cancelLocalNotifications\",\n    value: function cancelLocalNotifications(userInfo) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.cancelLocalNotifications(userInfo);\n    }\n  }, {\n    key: \"getScheduledLocalNotifications\",\n    value: function getScheduledLocalNotifications(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getScheduledLocalNotifications(callback);\n    }\n  }, {\n    key: \"getPendingNotificationRequests\",\n    value: function getPendingNotificationRequests(callback) {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.getPendingNotificationRequests(callback);\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, handler) {\n      invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');\n      var listener;\n\n      if (type === 'notification') {\n        listener = PushNotificationEmitter.addListener(DEVICE_NOTIF_EVENT, function (notifData) {\n          handler(new PushNotificationIOS(notifData));\n        });\n      } else if (type === 'localNotification') {\n        listener = PushNotificationEmitter.addListener(DEVICE_LOCAL_NOTIF_EVENT, function (notifData) {\n          handler(new PushNotificationIOS(notifData));\n        });\n      } else if (type === 'register') {\n        listener = PushNotificationEmitter.addListener(NOTIF_REGISTER_EVENT, function (registrationInfo) {\n          handler(registrationInfo.deviceToken);\n        });\n      } else if (type === 'registrationError') {\n        listener = PushNotificationEmitter.addListener(NOTIF_REGISTRATION_ERROR_EVENT, function (errorInfo) {\n          handler(errorInfo);\n        });\n      }\n\n      _notifHandlers.set(type, listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type) {\n      invariant(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');\n\n      var listener = _notifHandlers.get(type);\n\n      if (!listener) {\n        return;\n      }\n\n      listener.remove();\n\n      _notifHandlers.delete(type);\n    }\n  }, {\n    key: \"requestPermissions\",\n    value: function requestPermissions(permissions) {\n      var requestedPermissions = {\n        alert: true,\n        badge: true,\n        sound: true\n      };\n\n      if (permissions) {\n        requestedPermissions = {\n          alert: !!permissions.alert,\n          badge: !!permissions.badge,\n          sound: !!permissions.sound,\n          critical: !!permissions.critical\n        };\n      }\n\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      return RNCPushNotificationIOS.requestPermissions(requestedPermissions);\n    }\n  }, {\n    key: \"abandonPermissions\",\n    value: function abandonPermissions() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.abandonPermissions();\n    }\n  }, {\n    key: \"checkPermissions\",\n    value: function checkPermissions(callback) {\n      invariant(typeof callback === 'function', 'Must provide a valid callback');\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      RNCPushNotificationIOS.checkPermissions(callback);\n    }\n  }, {\n    key: \"getInitialNotification\",\n    value: function getInitialNotification() {\n      invariant(RNCPushNotificationIOS, 'PushNotificationManager is not available.');\n      return RNCPushNotificationIOS.getInitialNotification().then(function (notification) {\n        return notification && new PushNotificationIOS(notification);\n      });\n    }\n  }]);\n\n  return PushNotificationIOS;\n}();\n\nPushNotificationIOS.FetchResult = {\n  NewData: 'UIBackgroundFetchResultNewData',\n  NoData: 'UIBackgroundFetchResultNoData',\n  ResultFailed: 'UIBackgroundFetchResultFailed'\n};\nPushNotificationIOS.AuthorizationStatus = {\n  UNAuthorizationStatusNotDetermined: 0,\n  UNAuthorizationStatusDenied: 1,\n  UNAuthorizationStatusAuthorized: 2,\n  UNAuthorizationStatusProvisional: 3\n};\nexport default PushNotificationIOS;","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/node_modules/@react-native-community/push-notification-ios/js/index.js"],"names":["RNCPushNotificationIOS","NativeModules","PushNotificationEmitter","_notifHandlers","DEVICE_NOTIF_EVENT","NOTIF_REGISTER_EVENT","NOTIF_REGISTRATION_ERROR_EVENT","DEVICE_LOCAL_NOTIF_EVENT","PushNotificationIOS","FetchResult","NewData","NoData","ResultFailed","AuthorizationStatus","UNAuthorizationStatusNotDetermined","UNAuthorizationStatusDenied","UNAuthorizationStatusAuthorized","UNAuthorizationStatusProvisional","handledRequest","request","fireDate","finalRequest","repeatsComponent","invariant","type","listener","handler","registrationInfo","requestedPermissions","alert","badge","sound","permissions","critical","notification","nativeNotif","Object","notifVal","notifKey"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport {NativeEventEmitter, NativeModules} from 'react-native';\nimport invariant from 'invariant';\nimport type {\n  NotificationAlert,\n  NotificationRequest,\n  NotificationCategory,\n  NotificationAction,\n} from './types';\nconst {RNCPushNotificationIOS} = NativeModules;\n\nconst PushNotificationEmitter = new NativeEventEmitter(RNCPushNotificationIOS);\n\nconst _notifHandlers = new Map();\n\nconst DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';\nconst NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';\nconst NOTIF_REGISTRATION_ERROR_EVENT = 'remoteNotificationRegistrationError';\nconst DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';\n\nexport type {\n  NotificationAlert,\n  NotificationRequest,\n  NotificationCategory,\n  NotificationAction,\n};\n\nexport type ContentAvailable = 1 | null | void;\n\nexport type FetchResult = {\n  NewData: string,\n  NoData: string,\n  ResultFailed: string,\n};\n\nexport type AuthorizationStatus = {\n  UNAuthorizationStatusNotDetermined: 0,\n  UNAuthorizationStatusDenied: 1,\n  UNAuthorizationStatusAuthorized: 2,\n  UNAuthorizationStatusProvisional: 3,\n};\n\n/**\n * An event emitted by PushNotificationIOS.\n */\nexport type PushNotificationEventName = $Keys<{\n  /**\n   * Fired when a remote notification is received. The handler will be invoked\n   * with an instance of `PushNotificationIOS`.\n   */\n  notification: string,\n  /**\n   * Fired when a local notification is received. The handler will be invoked\n   * with an instance of `PushNotificationIOS`.\n   */\n  localNotification: string,\n  /**\n   * Fired when the user registers for remote notifications. The handler will be\n   * invoked with a hex string representing the deviceToken.\n   */\n  register: string,\n  /**\n   * Fired when the user fails to register for remote notifications. Typically\n   * occurs when APNS is having issues, or the device is a simulator. The\n   * handler will be invoked with {message: string, code: number, details: any}.\n   */\n  registrationError: string,\n}>;\n\n/**\n *\n * Handle push notifications for your app, including permission handling and\n * icon badge number.\n *\n * See https://reactnative.dev/docs/pushnotificationios.html\n */\nclass PushNotificationIOS {\n  _data: Object;\n  _alert: string | NotificationAlert;\n  _title: string;\n  _subtitle: string;\n  _sound: string;\n  _category: string;\n  _contentAvailable: ContentAvailable;\n  _badgeCount: number;\n  _notificationId: string;\n  /**\n   * The id of action the user has taken taken.\n   */\n  _actionIdentifier: ?string;\n  /**\n   * The text user has input if user responded with a text action.\n   */\n  _userText: ?string;\n  _isRemote: boolean;\n  _remoteNotificationCompleteCallbackCalled: boolean;\n  _threadID: string;\n  _fireDate: string | Date;\n\n  static FetchResult: FetchResult = {\n    NewData: 'UIBackgroundFetchResultNewData',\n    NoData: 'UIBackgroundFetchResultNoData',\n    ResultFailed: 'UIBackgroundFetchResultFailed',\n  };\n\n  static AuthorizationStatus: AuthorizationStatus = {\n    UNAuthorizationStatusNotDetermined: 0,\n    UNAuthorizationStatusDenied: 1,\n    UNAuthorizationStatusAuthorized: 2,\n    UNAuthorizationStatusProvisional: 3,\n  };\n\n  /**\n   * Schedules the localNotification for immediate presentation.\n   * @deprecated use `addNotificationRequest` instead\n   */\n  static presentLocalNotification(details: Object) {\n    RNCPushNotificationIOS.presentLocalNotification(details);\n  }\n\n  /**\n   * Schedules the localNotification for future presentation.\n   * @deprecated use `addNotificationRequest` instead\n   */\n  static scheduleLocalNotification(details: Object) {\n    RNCPushNotificationIOS.scheduleLocalNotification(details);\n  }\n\n  /**\n   * Sends notificationRequest to notification center at specified firedate.\n   * Fires immediately if firedate is not set.\n   */\n  static addNotificationRequest(request: NotificationRequest) {\n    const handledRequest =\n      request.fireDate instanceof Date\n        ? {...request, fireDate: request.fireDate.toISOString()}\n        : request;\n    const finalRequest = {\n      ...handledRequest,\n      repeatsComponent: request.repeatsComponent || {},\n    };\n\n    RNCPushNotificationIOS.addNotificationRequest(finalRequest);\n  }\n\n  /**\n   * Sets notification category to notification center.\n   * Used to set specific actions for notifications that contains specified category\n   */\n  static setNotificationCategories(categories: NotificationCategory[]) {\n    RNCPushNotificationIOS.setNotificationCategories(categories);\n  }\n\n  /**\n   * Cancels all scheduled localNotifications.\n   * @deprecated use `removeAllPendingNotificationRequests` instead\n   * - This method is deprecated in iOS 10 and will be removed from future release\n   */\n  static cancelAllLocalNotifications() {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.cancelAllLocalNotifications();\n  }\n\n  /**\n   * Removes all pending notifications\n   */\n  static removeAllPendingNotificationRequests() {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removeAllPendingNotificationRequests();\n  }\n\n  /**\n   * Removes pending notifications with given identifier strings.\n   */\n  static removePendingNotificationRequests(identifiers: string[]) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removePendingNotificationRequests(identifiers);\n  }\n\n  /**\n   * Remove all delivered notifications from Notification Center.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#removealldeliverednotifications\n   */\n  static removeAllDeliveredNotifications(): void {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removeAllDeliveredNotifications();\n  }\n\n  /**\n   * Provides you with a list of the app’s notifications that are still displayed in Notification Center.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getdeliverednotifications\n   */\n  static getDeliveredNotifications(\n    callback: (notifications: Array<Object>) => void,\n  ): void {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getDeliveredNotifications(callback);\n  }\n\n  /**\n   * Removes the specified notifications from Notification Center\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#removedeliverednotifications\n   */\n  static removeDeliveredNotifications(identifiers: Array<string>): void {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.removeDeliveredNotifications(identifiers);\n  }\n\n  /**\n   * Sets the badge number for the app icon on the home screen.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#setapplicationiconbadgenumber\n   */\n  static setApplicationIconBadgeNumber(number: number) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.setApplicationIconBadgeNumber(number);\n  }\n\n  /**\n   * Gets the current badge number for the app icon on the home screen.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getapplicationiconbadgenumber\n   */\n  static getApplicationIconBadgeNumber(callback: Function) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getApplicationIconBadgeNumber(callback);\n  }\n\n  /**\n   * Cancel local notifications.\n   * @deprecated - use `removePendingNotifications`\n   * See https://reactnative.dev/docs/pushnotificationios.html#cancellocalnotification\n   */\n  static cancelLocalNotifications(userInfo: Object) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.cancelLocalNotifications(userInfo);\n  }\n\n  /**\n   * Gets the local notifications that are currently scheduled.\n   * @deprecated - use `getPendingNotificationRequests`\n   */\n  static getScheduledLocalNotifications(callback: Function) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getScheduledLocalNotifications(callback);\n  }\n\n  /**\n   * Gets the pending local notification requests.\n   */\n  static getPendingNotificationRequests(\n    callback: (requests: NotificationRequest[]) => void,\n  ) {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.getPendingNotificationRequests(callback);\n  }\n\n  /**\n   * Attaches a listener to remote or local notification events while the app\n   * is running in the foreground or the background.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#addeventlistener\n   */\n  static addEventListener(type: PushNotificationEventName, handler: Function) {\n    invariant(\n      type === 'notification' ||\n        type === 'register' ||\n        type === 'registrationError' ||\n        type === 'localNotification',\n      'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events',\n    );\n    let listener;\n    if (type === 'notification') {\n      listener = PushNotificationEmitter.addListener(\n        DEVICE_NOTIF_EVENT,\n        (notifData) => {\n          handler(new PushNotificationIOS(notifData));\n        },\n      );\n    } else if (type === 'localNotification') {\n      listener = PushNotificationEmitter.addListener(\n        DEVICE_LOCAL_NOTIF_EVENT,\n        (notifData) => {\n          handler(new PushNotificationIOS(notifData));\n        },\n      );\n    } else if (type === 'register') {\n      listener = PushNotificationEmitter.addListener(\n        NOTIF_REGISTER_EVENT,\n        (registrationInfo) => {\n          handler(registrationInfo.deviceToken);\n        },\n      );\n    } else if (type === 'registrationError') {\n      listener = PushNotificationEmitter.addListener(\n        NOTIF_REGISTRATION_ERROR_EVENT,\n        (errorInfo) => {\n          handler(errorInfo);\n        },\n      );\n    }\n    _notifHandlers.set(type, listener);\n  }\n\n  /**\n   * Removes the event listener. Do this in `componentWillUnmount` to prevent\n   * memory leaks.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#removeeventlistener\n   */\n  static removeEventListener(type: PushNotificationEventName) {\n    invariant(\n      type === 'notification' ||\n        type === 'register' ||\n        type === 'registrationError' ||\n        type === 'localNotification',\n      'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events',\n    );\n    const listener = _notifHandlers.get(type);\n    if (!listener) {\n      return;\n    }\n    listener.remove();\n    _notifHandlers.delete(type);\n  }\n\n  /**\n   * Requests notification permissions from iOS, prompting the user's\n   * dialog box. By default, it will request all notification permissions, but\n   * a subset of these can be requested by passing a map of requested\n   * permissions.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#requestpermissions\n   */\n  static requestPermissions(permissions?: {\n    alert?: boolean,\n    badge?: boolean,\n    sound?: boolean,\n    critical?: boolean,\n  }): Promise<{\n    alert: boolean,\n    badge: boolean,\n    sound: boolean,\n    critical: boolean,\n  }> {\n    let requestedPermissions = {\n      alert: true,\n      badge: true,\n      sound: true,\n    };\n    if (permissions) {\n      requestedPermissions = {\n        alert: !!permissions.alert,\n        badge: !!permissions.badge,\n        sound: !!permissions.sound,\n        critical: !!permissions.critical,\n      };\n    }\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    return RNCPushNotificationIOS.requestPermissions(requestedPermissions);\n  }\n\n  /**\n   * Unregister for all remote notifications received via Apple Push Notification service.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#abandonpermissions\n   */\n  static abandonPermissions() {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.abandonPermissions();\n  }\n\n  /**\n   * See what push permissions are currently enabled. `callback` will be\n   * invoked with a `permissions` object.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#checkpermissions\n   */\n  static checkPermissions(callback: Function) {\n    invariant(typeof callback === 'function', 'Must provide a valid callback');\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.checkPermissions(callback);\n  }\n\n  /**\n   * This method returns a promise that resolves to either the notification\n   * object if the app was launched by a push notification, or `null` otherwise.\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getinitialnotification\n   */\n  static getInitialNotification(): Promise<?PushNotificationIOS> {\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    return RNCPushNotificationIOS.getInitialNotification().then(\n      (notification) => {\n        return notification && new PushNotificationIOS(notification);\n      },\n    );\n  }\n\n  /**\n   * You will never need to instantiate `PushNotificationIOS` yourself.\n   * Listening to the `notification` event and invoking\n   * `getInitialNotification` is sufficient\n   *\n   */\n  constructor(nativeNotif: Object) {\n    this._data = {};\n    this._remoteNotificationCompleteCallbackCalled = false;\n    this._isRemote = nativeNotif.remote;\n    if (this._isRemote) {\n      this._notificationId = nativeNotif.notificationId;\n    }\n\n    this._actionIdentifier = nativeNotif.actionIdentifier;\n    this._userText = nativeNotif.userText;\n    if (nativeNotif.remote) {\n      // Extract data from Apple's `aps` dict as defined:\n      // https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html\n      Object.keys(nativeNotif).forEach((notifKey) => {\n        const notifVal = nativeNotif[notifKey];\n\n        if (notifKey === 'aps') {\n          this._alert = notifVal.alert;\n          this._title = notifVal?.alertTitle;\n          this._subtitle = notifVal?.subtitle;\n          this._sound = notifVal.sound;\n          this._badgeCount = notifVal.badge;\n          this._category = notifVal.category;\n          this._contentAvailable = notifVal['content-available'];\n          this._threadID = notifVal['thread-id'];\n          this._fireDate = notifVal.fireDate;\n        } else {\n          this._data[notifKey] = notifVal;\n        }\n      });\n    } else {\n      // Local notifications aren't being sent down with `aps` dict.\n      // TODO: remove applicationIconBadgeNumber on next major version\n      this._badgeCount =\n        nativeNotif.badge || nativeNotif.applicationIconBadgeNumber;\n      // TODO: remove soundName on next major version\n      this._sound = nativeNotif.sound || nativeNotif.soundName;\n      this._alert = nativeNotif.body;\n      this._title = nativeNotif?.title;\n      this._subtitle = nativeNotif?.subtitle;\n      this._threadID = nativeNotif['thread-id'];\n      this._data = nativeNotif.userInfo;\n      this._category = nativeNotif.category;\n      this._fireDate = nativeNotif.fireDate;\n    }\n  }\n\n  /**\n   * This method is available for remote notifications that have been received via:\n   * `application:didReceiveRemoteNotification:fetchCompletionHandler:`\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#finish\n   */\n  finish(fetchResult: string) {\n    if (\n      !this._isRemote ||\n      !this._notificationId ||\n      this._remoteNotificationCompleteCallbackCalled\n    ) {\n      return;\n    }\n    this._remoteNotificationCompleteCallbackCalled = true;\n\n    invariant(\n      RNCPushNotificationIOS,\n      'PushNotificationManager is not available.',\n    );\n    RNCPushNotificationIOS.onFinishRemoteNotification(\n      this._notificationId,\n      fetchResult,\n    );\n  }\n\n  /**\n   * An alias for `getAlert` to get the notification's main message string\n   */\n  getMessage(): ?string | ?Object {\n    if (typeof this._alert === 'object') {\n      return this._alert?.body;\n    }\n    return this._alert;\n  }\n\n  /**\n   * Gets the sound string from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getsound\n   */\n  getSound(): ?string {\n    return this._sound;\n  }\n\n  /**\n   * Gets the category string from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getcategory\n   */\n  getCategory(): ?string {\n    return this._category;\n  }\n\n  /**\n   * Gets the notification's main message from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getalert\n   */\n  getAlert(): ?string | ?Object {\n    return this._alert;\n  }\n\n  /**\n   * Gets the notification's title from the `aps` object\n   *\n   */\n  getTitle(): ?string | ?Object {\n    if (typeof this._alert === 'object') {\n      return this._alert?.title;\n    }\n    return this._title;\n  }\n\n  /**\n   * Gets the notification's subtitle from the `aps` object\n   *\n   */\n  getSubtitle(): ?string | ?Object {\n    if (typeof this._alert === 'object') {\n      return this._alert?.subtitle;\n    }\n    return this._subtitle;\n  }\n\n  /**\n   * Gets the content-available number from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getcontentavailable\n   */\n  getContentAvailable(): ContentAvailable {\n    return this._contentAvailable;\n  }\n\n  /**\n   * Gets the badge count number from the `aps` object\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getbadgecount\n   */\n  getBadgeCount(): ?number {\n    return this._badgeCount;\n  }\n\n  /**\n   * Gets the data object on the notif\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getdata\n   */\n  getData(): ?Object {\n    return this._data;\n  }\n\n  /**\n   * Gets the thread ID on the notif\n   *\n   * See https://reactnative.dev/docs/pushnotificationios.html#getthreadid\n   */\n  getThreadID(): ?string {\n    return this._threadID;\n  }\n\n  /**\n   * Get's the action id of the notification action user has taken.\n   */\n  getActionIdentifier(): ?string {\n    return this._actionIdentifier;\n  }\n\n  /**\n   * Gets the text user has inputed if user has taken the text action response.\n   */\n  getUserText(): ?string {\n    return this._userText;\n  }\n}\n\nexport default PushNotificationIOS;\n"]},"metadata":{},"sourceType":"module"}