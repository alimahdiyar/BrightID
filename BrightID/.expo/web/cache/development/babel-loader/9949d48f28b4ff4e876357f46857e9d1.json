{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { SET_BACKUP_PENDING, SET_RECOVERY_CONNECTIONS_PENDING, SET_DEVICE_TOKEN, SET_ACTIVE_NOTIFICATION, SET_NOTIFICATION_TOKEN, REMOVE_ACTIVE_NOTIFICATION, RESET_STORE } from \"../actions\";\nimport { CONNECTIONS_TYPE, GROUPS_TYPE, MISC_TYPE } from \"../utils/constants\";\nvar initialState = {\n  activeNotification: null,\n  backupPending: false,\n  recoveryConnectionsPending: false,\n  deviceToken: null,\n  notificationToken: null,\n  sessionNotifications: []\n};\nexport var reducer = function reducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case SET_BACKUP_PENDING:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          backupPending: action.backupPending\n        });\n      }\n\n    case SET_RECOVERY_CONNECTIONS_PENDING:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          recoveryConnectionsPending: action.recoveryConnectionsPending\n        });\n      }\n\n    case SET_DEVICE_TOKEN:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          deviceToken: action.deviceToken\n        });\n      }\n\n    case SET_NOTIFICATION_TOKEN:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          notificationToken: action.notificationToken\n        });\n      }\n\n    case SET_ACTIVE_NOTIFICATION:\n      {\n        var _state$activeNotifica, _state$activeNotifica2;\n\n        var notification = action.notification;\n\n        if (!notification) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            activeNotification: null\n          });\n        }\n\n        if (notification.oncePerSession) {\n          if (state.sessionNotifications.includes(notification.title)) {\n            return state;\n          }\n        }\n\n        if (((_state$activeNotifica = state.activeNotification) == null ? void 0 : _state$activeNotifica.type) === CONNECTIONS_TYPE && (notification == null ? void 0 : notification.type) !== CONNECTIONS_TYPE) return state;\n        if (((_state$activeNotifica2 = state.activeNotification) == null ? void 0 : _state$activeNotifica2.type) === GROUPS_TYPE && (notification == null ? void 0 : notification.type) === MISC_TYPE) return state;\n\n        var sessionNotifications = _toConsumableArray(state.sessionNotifications);\n\n        if (notification != null && notification.oncePerSession) {\n          sessionNotifications.push(notification.title);\n        }\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          activeNotification: notification,\n          sessionNotifications: sessionNotifications\n        });\n      }\n\n    case REMOVE_ACTIVE_NOTIFICATION:\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          activeNotification: {}\n        });\n      }\n\n    case RESET_STORE:\n      {\n        return _objectSpread({}, initialState);\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n};\nexport default reducer;","map":{"version":3,"names":["SET_BACKUP_PENDING","SET_RECOVERY_CONNECTIONS_PENDING","SET_DEVICE_TOKEN","SET_ACTIVE_NOTIFICATION","SET_NOTIFICATION_TOKEN","REMOVE_ACTIVE_NOTIFICATION","RESET_STORE","CONNECTIONS_TYPE","GROUPS_TYPE","MISC_TYPE","initialState","activeNotification","backupPending","recoveryConnectionsPending","deviceToken","notificationToken","sessionNotifications","reducer","state","action","type","notification","oncePerSession","includes","title","push"],"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/reducer/notifications.ts"],"sourcesContent":["import {\n  SET_BACKUP_PENDING,\n  SET_RECOVERY_CONNECTIONS_PENDING,\n  SET_DEVICE_TOKEN,\n  SET_ACTIVE_NOTIFICATION,\n  SET_NOTIFICATION_TOKEN,\n  REMOVE_ACTIVE_NOTIFICATION,\n  RESET_STORE,\n} from '@/actions';\nimport { CONNECTIONS_TYPE, GROUPS_TYPE, MISC_TYPE } from '@/utils/constants';\n\nconst initialState = {\n  activeNotification: null,\n  backupPending: false,\n  recoveryConnectionsPending: false,\n  deviceToken: null,\n  notificationToken: null,\n  sessionNotifications: [],\n};\n\n// not sure if this is the best way...\n\nexport const reducer = (\n  state: NotificationsState = initialState,\n  action: action,\n) => {\n  switch (action.type) {\n    case SET_BACKUP_PENDING: {\n      return { ...state, backupPending: action.backupPending };\n    }\n    case SET_RECOVERY_CONNECTIONS_PENDING: {\n      return {\n        ...state,\n        recoveryConnectionsPending: action.recoveryConnectionsPending,\n      };\n    }\n    case SET_DEVICE_TOKEN: {\n      return { ...state, deviceToken: action.deviceToken };\n    }\n    case SET_NOTIFICATION_TOKEN: {\n      return { ...state, notificationToken: action.notificationToken };\n    }\n    case SET_ACTIVE_NOTIFICATION: {\n      const { notification } = action;\n      // set null activeNotifications\n      if (!notification) {\n        return { ...state, activeNotification: null };\n      }\n\n      // handle once-per-session notifications\n      if (notification.oncePerSession) {\n        if (state.sessionNotifications.includes(notification.title)) {\n          // Ignore if already notified before\n          return state;\n        }\n      }\n\n      // do not update the notification banner if the active is set as a new connection\n      if (\n        state.activeNotification?.type === CONNECTIONS_TYPE &&\n        notification?.type !== CONNECTIONS_TYPE\n      )\n        return state;\n\n      // do not update the notification banner if the alert is for backups,\n      // and a notification is already displayed\n      if (\n        state.activeNotification?.type === GROUPS_TYPE &&\n        notification?.type === MISC_TYPE\n      )\n        return state;\n\n      const sessionNotifications = [...state.sessionNotifications];\n      if (notification?.oncePerSession) {\n        sessionNotifications.push(notification.title);\n      }\n\n      return {\n        ...state,\n        activeNotification: notification,\n        sessionNotifications,\n      };\n    }\n    case REMOVE_ACTIVE_NOTIFICATION: {\n      return { ...state, activeNotification: {} };\n    }\n    case RESET_STORE: {\n      return { ...initialState };\n    }\n    default: {\n      return state;\n    }\n  }\n};\n\nexport default reducer;\n"],"mappings":";;;;;;;AAAA,SACEA,kBADF,EAEEC,gCAFF,EAGEC,gBAHF,EAIEC,uBAJF,EAKEC,sBALF,EAMEC,0BANF,EAOEC,WAPF;AASA,SAASC,gBAAT,EAA2BC,WAA3B,EAAwCC,SAAxC;AAEA,IAAMC,YAAY,GAAG;EACnBC,kBAAkB,EAAE,IADD;EAEnBC,aAAa,EAAE,KAFI;EAGnBC,0BAA0B,EAAE,KAHT;EAInBC,WAAW,EAAE,IAJM;EAKnBC,iBAAiB,EAAE,IALA;EAMnBC,oBAAoB,EAAE;AANH,CAArB;AAWA,OAAO,IAAMC,OAAO,GAAG,SAAVA,OAAU,GAGlB;EAAA,IAFHC,KAEG,uEAFyBR,YAEzB;EAAA,IADHS,MACG;;EACH,QAAQA,MAAM,CAACC,IAAf;IACE,KAAKpB,kBAAL;MAAyB;QACvB,uCAAYkB,KAAZ;UAAmBN,aAAa,EAAEO,MAAM,CAACP;QAAzC;MACD;;IACD,KAAKX,gCAAL;MAAuC;QACrC,uCACKiB,KADL;UAEEL,0BAA0B,EAAEM,MAAM,CAACN;QAFrC;MAID;;IACD,KAAKX,gBAAL;MAAuB;QACrB,uCAAYgB,KAAZ;UAAmBJ,WAAW,EAAEK,MAAM,CAACL;QAAvC;MACD;;IACD,KAAKV,sBAAL;MAA6B;QAC3B,uCAAYc,KAAZ;UAAmBH,iBAAiB,EAAEI,MAAM,CAACJ;QAA7C;MACD;;IACD,KAAKZ,uBAAL;MAA8B;QAAA;;QAC5B,IAAQkB,YAAR,GAAyBF,MAAzB,CAAQE,YAAR;;QAEA,IAAI,CAACA,YAAL,EAAmB;UACjB,uCAAYH,KAAZ;YAAmBP,kBAAkB,EAAE;UAAvC;QACD;;QAGD,IAAIU,YAAY,CAACC,cAAjB,EAAiC;UAC/B,IAAIJ,KAAK,CAACF,oBAAN,CAA2BO,QAA3B,CAAoCF,YAAY,CAACG,KAAjD,CAAJ,EAA6D;YAE3D,OAAON,KAAP;UACD;QACF;;QAGD,IACE,0BAAAA,KAAK,CAACP,kBAAN,2CAA0BS,IAA1B,MAAmCb,gBAAnC,IACA,CAAAc,YAAY,QAAZ,YAAAA,YAAY,CAAED,IAAd,MAAuBb,gBAFzB,EAIE,OAAOW,KAAP;QAIF,IACE,2BAAAA,KAAK,CAACP,kBAAN,4CAA0BS,IAA1B,MAAmCZ,WAAnC,IACA,CAAAa,YAAY,QAAZ,YAAAA,YAAY,CAAED,IAAd,MAAuBX,SAFzB,EAIE,OAAOS,KAAP;;QAEF,IAAMF,oBAAoB,sBAAOE,KAAK,CAACF,oBAAb,CAA1B;;QACA,IAAIK,YAAJ,YAAIA,YAAY,CAAEC,cAAlB,EAAkC;UAChCN,oBAAoB,CAACS,IAArB,CAA0BJ,YAAY,CAACG,KAAvC;QACD;;QAED,uCACKN,KADL;UAEEP,kBAAkB,EAAEU,YAFtB;UAGEL,oBAAoB,EAApBA;QAHF;MAKD;;IACD,KAAKX,0BAAL;MAAiC;QAC/B,uCAAYa,KAAZ;UAAmBP,kBAAkB,EAAE;QAAvC;MACD;;IACD,KAAKL,WAAL;MAAkB;QAChB,yBAAYI,YAAZ;MACD;;IACD;MAAS;QACP,OAAOQ,KAAP;MACD;EAjEH;AAmED,CAvEM;AAyEP,eAAeD,OAAf"},"metadata":{},"sourceType":"module"}