{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { hash } from \"../../../../utils/encoding\";\nimport ChannelAPI from \"../../../../api/channelService\";\nimport { selectBaseUrl } from \"../../../../reducer/settingsSlice\";\nimport { downloadConnections, downloadGroups, downloadSigs, downloadNamePhoto } from \"./channelDownloadThunks\";\nimport { setRecoveryChannel } from \"../recoveryDataSlice\";\nimport { uploadRecoveryData } from \"../../../../utils/recovery\";\nexport var CHANNEL_POLL_INTERVAL = 3000;\nexport var createChannel = function createChannel() {\n  return function _callee(dispatch, getState) {\n    var _getState, recoveryData, baseUrl, url, channelApi, channelId, msg;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _getState = getState(), recoveryData = _getState.recoveryData;\n            baseUrl = selectBaseUrl(getState());\n            url = new URL(baseUrl + \"/profile\");\n            channelApi = new ChannelAPI(url.href);\n            channelId = hash(recoveryData.aesKey);\n            console.log(\"created channel \" + channelId + \" for recovery data\");\n            dispatch(setRecoveryChannel({\n              channelId: channelId,\n              url: url\n            }));\n            _context.next = 10;\n            return _regeneratorRuntime.awrap(uploadRecoveryData(recoveryData, channelApi));\n\n          case 10:\n            console.log(\"Finished uploading recovery data to channel \" + channelId);\n            _context.next = 18;\n            break;\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](0);\n            msg = 'Profile data already exists in channel';\n\n            if (_context.t0.message.startsWith(msg)) {\n              _context.next = 18;\n              break;\n            }\n\n            throw _context.t0;\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 13]], Promise);\n  };\n};\nvar channelIntervalId;\nvar checkInProgress = false;\nexport var pollChannel = function pollChannel() {\n  return function _callee2(dispatch) {\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            clearInterval(channelIntervalId);\n            channelIntervalId = setInterval(function () {\n              if (!checkInProgress) {\n                checkInProgress = true;\n                dispatch(checkChannel()).then(function () {\n                  checkInProgress = false;\n                }).catch(function (err) {\n                  checkInProgress = false;\n                  console.error(\"Error polling recovery channel: \" + err.message);\n                });\n              }\n            }, CHANNEL_POLL_INTERVAL);\n            console.log(\"start polling recovery channel (\" + channelIntervalId);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};\nexport var clearChannel = function clearChannel() {\n  console.log(\"stop polling recovery channel (\" + channelIntervalId + \")\");\n  clearInterval(channelIntervalId);\n};\nexport var checkChannel = function checkChannel() {\n  return function _callee3(dispatch, getState) {\n    var _getState2, _getState2$recoveryDa, recoveryId, name, _getState2$recoveryDa2, channelId, url, channelApi, dataIds;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _getState2 = getState(), _getState2$recoveryDa = _getState2.recoveryData, recoveryId = _getState2$recoveryDa.id, name = _getState2$recoveryDa.name, _getState2$recoveryDa2 = _getState2$recoveryDa.channel, channelId = _getState2$recoveryDa2.channelId, url = _getState2$recoveryDa2.url;\n            channelApi = new ChannelAPI(url.href);\n            _context3.next = 4;\n            return _regeneratorRuntime.awrap(channelApi.list(channelId));\n\n          case 4:\n            dataIds = _context3.sent;\n\n            if (!recoveryId) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 8;\n            return _regeneratorRuntime.awrap(dispatch(downloadConnections({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 8:\n            _context3.next = 10;\n            return _regeneratorRuntime.awrap(dispatch(downloadGroups({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 10:\n            if (name) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 13;\n            return _regeneratorRuntime.awrap(dispatch(downloadNamePhoto({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 13:\n            _context3.next = 15;\n            return _regeneratorRuntime.awrap(dispatch(downloadSigs({\n              channelApi: channelApi,\n              dataIds: dataIds\n            })));\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n};","map":{"version":3,"sources":["/home/ali/Desktop/brightid/BrightID/BrightID/src/components/Onboarding/RecoveryFlow/thunks/channelThunks.ts"],"names":["CHANNEL_POLL_INTERVAL","createChannel","recoveryData","getState","baseUrl","selectBaseUrl","url","channelApi","channelId","hash","console","dispatch","setRecoveryChannel","uploadRecoveryData","msg","checkInProgress","pollChannel","clearInterval","channelIntervalId","setInterval","checkChannel","err","clearChannel","recoveryId","name","dataIds","downloadConnections","downloadGroups","downloadNamePhoto","downloadSigs"],"mappings":"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","sourcesContent":["import { hash } from '@/utils/encoding';\nimport ChannelAPI from '@/api/channelService';\nimport { selectBaseUrl } from '@/reducer/settingsSlice';\nimport {\n  downloadConnections,\n  downloadGroups,\n  downloadSigs,\n  downloadNamePhoto,\n} from './channelDownloadThunks';\nimport { setRecoveryChannel } from '../recoveryDataSlice';\nimport { uploadRecoveryData } from '@/utils/recovery';\n\n// CONSTANTS\n\nexport const CHANNEL_POLL_INTERVAL = 3000;\n\n// THUNKS\n\nexport const createChannel =\n  () => async (dispatch: dispatch, getState: getState) => {\n    try {\n      const { recoveryData } = getState();\n      const baseUrl = selectBaseUrl(getState());\n      const url = new URL(`${baseUrl}/profile`);\n      // use this for local running profile service\n      // const url = new URL(`http://10.0.2.2:3000/`);\n      const channelApi = new ChannelAPI(url.href);\n      const channelId = hash(recoveryData.aesKey);\n      console.log(`created channel ${channelId} for recovery data`);\n      dispatch(setRecoveryChannel({ channelId, url }));\n      await uploadRecoveryData(recoveryData, channelApi);\n      console.log(`Finished uploading recovery data to channel ${channelId}`);\n    } catch (e) {\n      const msg = 'Profile data already exists in channel';\n      if (!e.message.startsWith(msg)) {\n        throw e;\n      }\n    }\n  };\n\nlet channelIntervalId: IntervalId;\nlet checkInProgress = false;\n\nexport const pollChannel = () => async (dispatch: dispatch) => {\n  clearInterval(channelIntervalId);\n\n  channelIntervalId = setInterval(() => {\n    if (!checkInProgress) {\n      checkInProgress = true;\n      dispatch(checkChannel())\n        .then(() => {\n          checkInProgress = false;\n        })\n        .catch((err) => {\n          checkInProgress = false;\n          console.error(`Error polling recovery channel: ${err.message}`);\n        });\n    }\n  }, CHANNEL_POLL_INTERVAL);\n\n  console.log(`start polling recovery channel (${channelIntervalId}`);\n};\n\nexport const clearChannel = () => {\n  console.log(`stop polling recovery channel (${channelIntervalId})`);\n  clearInterval(channelIntervalId);\n};\n\nexport const checkChannel =\n  () => async (dispatch: dispatch, getState: getState) => {\n    const {\n      recoveryData: {\n        id: recoveryId,\n        name,\n        channel: { channelId, url },\n      },\n    } = getState();\n    const channelApi = new ChannelAPI(url.href);\n    const dataIds = await channelApi.list(channelId);\n\n    if (recoveryId) {\n      // process connections uploaded to the channel\n      // returns true if downloading connecion data this cycle\n      await dispatch(downloadConnections({ channelApi, dataIds }));\n\n      // process groups uploaded to the channel\n      // returns true if downloading group data this cycle\n      await dispatch(downloadGroups({ channelApi, dataIds }));\n\n      if (!name) {\n        await dispatch(downloadNamePhoto({ channelApi, dataIds }));\n      }\n    }\n\n    // process signatures uploaded to the channel\n    // returns true if downloading sigs this cycle\n    await dispatch(downloadSigs({ channelApi, dataIds }));\n  };\n"]},"metadata":{},"sourceType":"module"}